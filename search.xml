<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <url>/2020/11/30/001.%20Two%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of integers, return <strong>indices</strong> of the <strong>two</strong> numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <strong>same</strong> element twice.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的    <strong>数组下标</strong>。</p>
<p>你可以假设每种输入只会对应 <strong>一个</strong> 答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历数组，使用 map 记录每个数出现的位置。</p>
<p>遍历过程中，判断对应的数是否已经出现过。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<p>注：map 的时间复杂度为 $O(logn)$；可替换为 hash_map，理论时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mp.count(t))	<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;mp[t],i&#125;);</span><br><span class="line">            mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            t = target-x </span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">list</span>((mp[t],i))</span><br><span class="line">            mp[x] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2. Add Two Numbers</title>
    <url>/2020/11/30/002.%20Add%20Two%20Numbers/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain <strong>a single</strong> digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟加法，使用了首节点为空的链表以减少代码量。</p>
<p>注意可能存在两链表长度不一致和最终进位的情况。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *now = ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2) </span><br><span class="line">            &#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum) now-&gt;next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a><strong>Python代码</strong></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        now = ans</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:  </span><br><span class="line">                <span class="built_in">sum</span> += l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l2:  </span><br><span class="line">                <span class="built_in">sum</span> += l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            now.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span>%<span class="number">10</span>)</span><br><span class="line">            <span class="built_in">sum</span> /= <span class="number">10</span></span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>:</span><br><span class="line">            now.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
    <url>/2020/11/30/003.%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3. </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>使用双指针。</p>
<p>右指针遍历字符串，使用 map 维护当前出现的字母和每个字母的出现个数。</p>
<p>遍历过程中，更新左指针的位置，使得两指针间无重复字母。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<p>注：map 的时间复杂度为 $O(logn)$；可替换为 hash_map，理论时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,</span><br><span class="line">        maxx = <span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>;r &lt; s.length();r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(++mp[s[r]] == <span class="number">1</span>)  num++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(--mp[s[l++]] == <span class="number">0</span>)	num--;</span><br><span class="line">                    <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">            maxx = max(maxx,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">                ans += c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = ans.split(c)[<span class="number">1</span>]+c</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,<span class="built_in">len</span>(ans))</span><br><span class="line">        <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 4. Median of Two Sorted Arrays</title>
    <url>/2020/11/30/004.%20Median%20of%20Two%20Sorted%20Arrays/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>There are two sorted arrays <code>nums1</code> and <code>nums2</code> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be $O(log (m+n))$.</p>
<p>You may assume <code>nums1</code> and <code>nums2</code> cannot be both empty.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个大小为 <code>m</code> 和 <code>n</code> 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：暴力法"><a href="#一：暴力法" class="headerlink" title="一：暴力法"></a>一：暴力法</h2><p>合并两数组后，再求得中位数。</p>
<p>合并时只需合并到 $\lfloor \frac{m+n}{2} \rfloor +1$ 个数即可。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h2 id="二：二分法"><a href="#二：二分法" class="headerlink" title="二：二分法"></a>二：二分法</h2><ul>
<li>符号表示</li>
</ul>
<p>为简化表示，将两数组表示为 $a = [a_0,a_1,\cdots,a_{m-1}]$ 和 $b = [b_0,b_1,\cdots,b_{n-1}]$。</p>
<p>不失一般性，假设 $m \leq n$，并定义 $half = \lceil \frac{m+n}{2} \rceil $。</p>
<p>将合并后的数组表示为 $c = [c_1,\cdots,c_{m+n}]$，注意此处 $c$ 的下标从 $1$ 开始。</p>
<ul>
<li>如何表示 $c$ 的中位数？</li>
</ul>
<p>① 当 $m+n$ 为奇数时，$c$ 的中位数为 $c[half] $。</p>
<p>② 当 $m+n$ 为偶数时，$c$ 的中位数为 $\frac{c[half]+c[half+1]}{2}$。</p>
<ul>
<li>整体思路</li>
</ul>
<p>找到一组 $p_a$ 和 $p_b$，使得 $[c_1,c_2,\cdots,c_{half}]$ 对应 $[a_0,a_1,\cdots,a_{p_a}]$ 和 $[b_0,b_1,\cdots,b_{p_b}]$。</p>
<p>由于 $c$ 由 $a$ 和 $b$ 合并而成，可得$c[half] = \max(a[p_a],b[p_b])$，$c[half+1] = \min(a[p_a+1],b[p_b+1]) $。</p>
<p>另外，从数组的长度关系中易得，$p_a+p_b+2 = half$，即确定了 $p_a$ 可得 $p_b $。</p>
<ul>
<li>如何确定 $p_a$ ？</li>
</ul>
<p>我们可以考虑当已经确定 $c$ 中前 $half-1$ 个元素时，下一个元素的情况。</p>
<p>① 当 $a_{next} \geq b_{next}$ 时，$c[half] = a_{next}$。</p>
<p>② 当 $a_{next} \lt b_{next}$ 时，$c[half] = b_{next}$。 </p>
<p>无论是哪种情况，一定使得 $a[p_a+1] \geq b[p_b]$，且此时的 $p_a$ 为 $a$ 中首个使得该式成立的下标。</p>
<ul>
<li>二分算法</li>
</ul>
<p>使用二分算法，求第一个使得 $a[i] \geq b\left[half-(i+1) \right] $ 的 $i$，记为 $t_a$ ，则 $t_a = p_a+1$。</p>
<p>同时，可得 $t_b = half-t_a$，$t_b = p_b+1$。</p>
<p>由于 $m \leq n$ 且 $0 \leq t_a \leq m$，这保证了 $0 \leq t_b \leq n$。</p>
<p>① 当 $t_a = 0$ 时，意味着 $a$ 中元素均不在 $c$ 中。</p>
<p>② 当 $t_a = m$ 时，意味着 $a$ 中元素均在 $c$ 中。</p>
<p>③ 当 $t_b = 0$ 时，意味着 $b $ 中元素均不在 $c$ 中。</p>
<p>④ 当 $t_b = n$ 时，意味着 $b$ 中元素均在 $c$ 中。</p>
<p>时间复杂度 $O(log(\min(m,n)))$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = nums1.size()+nums2.size();</span><br><span class="line">        <span class="keyword">int</span> mid = cnt/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now1 = <span class="number">0</span>,now2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(v.size() &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now1 &lt; nums1.size() &amp;&amp; now2 &lt; nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[now1] &lt;= nums2[now2])  v.push_back(nums1[now1++]);</span><br><span class="line">                <span class="keyword">else</span>    v.push_back(nums2[now2++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now1 &lt; nums1.size())    v.push_back(nums1[now1++]);</span><br><span class="line">            <span class="keyword">else</span>    v.push_back(nums2[now2++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>)   <span class="keyword">return</span> v.back();</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> (v.back()+v[v.size()<span class="number">-2</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.size() &gt; b.size()) swap(a,b);</span><br><span class="line">        <span class="keyword">int</span> m = a.size(),n = b.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = m,half = (m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; b[half-(i+<span class="number">1</span>)])    l = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ta = l,tb = half-l;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">if</span>(ta == <span class="number">0</span>) x = b[tb<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tb == <span class="number">0</span>)    x = a[ta<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>    x = max(a[ta<span class="number">-1</span>],b[tb<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(ta == m) y = b[tb];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tb == n)    y = a[ta];</span><br><span class="line">        <span class="keyword">else</span>    y = min(a[ta],b[tb]);</span><br><span class="line">        <span class="keyword">return</span> (x+y)/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;<span class="built_in">int</span>&gt;&amp; nums1, vector&lt;<span class="built_in">int</span>&gt;&amp; nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> cnt = nums1.size()+nums2.size();</span><br><span class="line">        <span class="built_in">int</span> mid = cnt/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> now1 = <span class="number">0</span>,now2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(v.size() &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now1 &lt; nums1.size() &amp;&amp; now2 &lt; nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[now1] &lt;= nums2[now2])  v.push_back(nums1[now1++]);</span><br><span class="line">                <span class="keyword">else</span>    v.push_back(nums2[now2++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now1 &lt; nums1.size())    v.push_back(nums1[now1++]);</span><br><span class="line">            <span class="keyword">else</span>    v.push_back(nums2[now2++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>)   <span class="keyword">return</span> v[mid-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> (v[mid-<span class="number">1</span>]+v[mid-<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, a: List[<span class="built_in">int</span>], b: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">            a,b = b,a</span><br><span class="line">        m,n = <span class="built_in">len</span>(a),<span class="built_in">len</span>(b)</span><br><span class="line">        l,r,half = <span class="number">0</span>,m,(m+n+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            i = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; b[half-(i+<span class="number">1</span>)]:</span><br><span class="line">                l = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = i</span><br><span class="line">        ta,tb = l,half-l</span><br><span class="line">        <span class="keyword">if</span> ta == <span class="number">0</span>:</span><br><span class="line">            x = b[tb-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> tb == <span class="number">0</span>:</span><br><span class="line">            x = a[ta-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = <span class="built_in">max</span>(a[ta-<span class="number">1</span>],b[tb-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> ta == m:</span><br><span class="line">            y = b[tb]</span><br><span class="line">        <span class="keyword">elif</span> tb == n:</span><br><span class="line">            y = a[ta]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = <span class="built_in">min</span>(a[ta],b[tb])</span><br><span class="line">        <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5. Longest Palindromic Substring</title>
    <url>/2020/11/30/005.%20Longest%20Palindromic%20Substring/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code>, find the longest palindromic substring in <code>s</code>. You may assume that the maximum length of <code>s</code> is 1000.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>马拉车(Manacher)算法。</p>
<p>用一种未出现过的字符(如 #)分隔字符串，以解决偶数回文串的情况。</p>
<p>用另两种未出现过的字符(如 $ 和 %)加在字符串首位，以解决边界问题。</p>
<p>遍历字符串，维护元素 $mid$、$r$ 和数组 $p$ 。</p>
<p>$r$ ：当前已被回文串覆盖的最右边界。</p>
<p>$mid$ ：$r$ 所对应的回文串中心。</p>
<p>$p[i ]$ ：以每个 $i$ 为中心的最长回文的半长(从中心到一段的长度)。</p>
<p>① 当前位置 $i \lt r $，则 $p[i] = \min(p[j],r-i)$，其中 $i$ 和 $j$ 关于 $mid$ 对称。</p>
<p>② 当前位置 $i \geq r$，则 $p[i] = 1$。</p>
<p>在 ①② 的基础上，再向两边扩充 $p[i]$ 。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//babad -&gt; $#b#a#b#a#d#%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ss = <span class="string">&quot;$#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)  </span><br><span class="line">        &#123;</span><br><span class="line">            ss.append(<span class="number">1</span>,s[i]);</span><br><span class="line">            ss.append(<span class="number">1</span>,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ss.append(<span class="number">1</span>,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> p[<span class="number">3005</span>] = &#123;<span class="number">0</span>&#125;,mid,r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>,pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; ss.length()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; r)	p[i] = min(p[<span class="number">2</span>*mid-i],r-i);</span><br><span class="line">            <span class="keyword">else</span>    p[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss[i-p[i]] == ss[i+p[i]]) p[i]++;</span><br><span class="line">            <span class="keyword">if</span>(p[i]+i &gt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                r = p[i]+i;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt; maxx)</span><br><span class="line">            &#123;</span><br><span class="line">            	maxx = p[i];</span><br><span class="line">            	pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        pos -= maxx<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(--maxx) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.append(<span class="number">1</span>,ss[pos]);</span><br><span class="line">            pos += <span class="number">2</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#babad -&gt; $#b#a#b#a#d#%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        ss =<span class="string">&#x27;@#&#x27;</span>+<span class="string">&#x27;#&#x27;</span>.join(<span class="built_in">list</span>(s))+<span class="string">&#x27;#$&#x27;</span> </span><br><span class="line">        p = [<span class="number">0</span>]*<span class="built_in">len</span>(ss)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(ss)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; r:</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[mid*<span class="number">2</span>-i],r-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ss[i-p[i]] == ss[i+p[i]]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[i]+i &gt; r:</span><br><span class="line">                mid,r = i,p[i]+i</span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; maxx:</span><br><span class="line">                pos,maxx = i,p[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ss[pos-maxx+<span class="number">2</span>:pos+maxx-<span class="number">1</span>].split(<span class="string">&#x27;#&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 6. ZigZag Conversion</title>
    <url>/2020/11/30/006.%20ZigZag%20Conversion/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>找规律，计算每行对应的位置。</p>
<p>计算每行出现的字符位置。</p>
<p>注意首尾两行在一个周期仅有一个字符。</p>
<p>注意其余行可能会出现最后一个周期仅有一个字符的情况。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>)    <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = i;</span><br><span class="line">            <span class="keyword">while</span>(now &lt; s.length())</span><br><span class="line">            &#123;</span><br><span class="line">                ans.append(<span class="number">1</span>,s[now]);</span><br><span class="line">                now += (numRows<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != numRows<span class="number">-1</span> &amp;&amp; now<span class="number">-2</span>*i &gt;= s.length())	<span class="keyword">continue</span>;</span><br><span class="line">                ans.append(<span class="number">1</span>,s[now<span class="number">-2</span>*i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            now = i</span><br><span class="line">            <span class="keyword">while</span> now &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                ans.append(s[now])</span><br><span class="line">                now += (numRows-<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> i != numRows-<span class="number">1</span> <span class="keyword">and</span> now-<span class="number">2</span>*i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    ans.append(s[now-<span class="number">2</span>*i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 7. Reverse Integer</title>
    <url>/2020/11/30/007.%20Reverse%20Integer/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31},  2^{31} − 1]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先去记录符号位，然后反转。</p>
<p>注意反转后可能会出现溢出的情况，所以使用 long long 存储结果。</p>
<p>当结果大于 2147483647($2^{31}-1$) 时，不论正负，肯定为溢出。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> xx = x,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(xx &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            xx = -xx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(xx)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans*<span class="number">10</span>+xx%<span class="number">10</span>;</span><br><span class="line">            xx /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">2147483647</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            flag,x = -<span class="number">1</span>,-x</span><br><span class="line">        ans = <span class="built_in">int</span>(<span class="built_in">str</span>(x)[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">2147483647</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> flag*ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 8. String to Integer (atoi)</title>
    <url>/2020/11/30/008.%20String%20to%20Integer%20(atoi)/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement <code>atoi</code> which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31},  2^{31} − 1]$. If the numerical value is out of the range of representable values, INT_MAX ($2^{31} − 1$) or INT_MIN ($−2^{31}$) is returned.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 $[−2^{31},  2^{31} − 1]$。如果数值超过这个范围，请返回  INT_MAX ($2^{31} − 1$) 或 INT_MIN ($−2^{31}$) 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical </span><br><span class="line">             digit or a +&#x2F;- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN is returned.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先删去串首的空格。</p>
<p>其次记录串首的符号位。</p>
<p>然后遍历串，直到遇到非数值或结尾。</p>
<p>转化成整形，注意超 int 和非法的情况。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now &lt; str.length() &amp;&amp; str[now] == <span class="string">&#x27; &#x27;</span>)	now++;</span><br><span class="line">        <span class="keyword">if</span>(now &lt; str.length() &amp;&amp; str[now] == <span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(now &lt; str.length() &amp;&amp; str[now] == <span class="string">&#x27;+&#x27;</span>)	now++;</span><br><span class="line">        <span class="keyword">for</span>(;now &lt; str.length();now++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; <span class="number">2147483648</span> || !<span class="built_in">isdigit</span>(str[now]))	<span class="keyword">break</span>;</span><br><span class="line">            ans = ans*<span class="number">10</span>+str[now]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; ans &gt; <span class="number">2147483647</span>)	ans = <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">-1</span> &amp;&amp; ans &gt; <span class="number">2147483648</span>)	ans = <span class="number">2147483648</span>;</span><br><span class="line">        <span class="keyword">return</span> flag*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        now,ans = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> now &lt; <span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">str</span>[now] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> now &lt; <span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">str</span>[now] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            flag = -<span class="number">1</span></span><br><span class="line">            now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> now &lt; <span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">str</span>[now] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> now &lt; <span class="built_in">len</span>(<span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">if</span> ans &gt; <span class="number">2147483648</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">str</span>[now].isdigit():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ans = ans*<span class="number">10</span>+<span class="built_in">int</span>(<span class="built_in">str</span>[now])</span><br><span class="line">            now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">and</span> ans &gt; <span class="number">2147483647</span>:</span><br><span class="line">            ans = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">if</span> flag == -<span class="number">1</span> <span class="keyword">and</span> ans &gt; <span class="number">2147483648</span>:</span><br><span class="line">            ans = <span class="number">2147483648</span></span><br><span class="line">        <span class="keyword">return</span> flag*ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 9. Palindrome Number</title>
    <url>/2020/11/30/009.%20Palindrome%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>若 $x &lt; 0$ ,则不回文。</p>
<p>否则反转 $x$，判断是否与 $x$ 相同。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = x,b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            b = b*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(x) == <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 10. Regular Expression Matching</title>
    <url>/2020/11/30/010.%20Regular%20Expression%20Matching/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;.&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;.&#39; 匹配任意单个字符</span><br><span class="line">&#39;*&#39; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p>
<p>说明:</p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：递归"><a href="#一：递归" class="headerlink" title="一：递归"></a>一：递归</h2><ul>
<li><p>$p$ 为空：</p>
<p>考虑 $s$ 是否为空。</p>
</li>
<li><p>$\mathbb{len}(p) &gt; 1$ 且 $p[1] = ‘*’ $：</p>
<p>共同考虑以下两种情况。</p>
<p>① 将 $p[0]*$ 匹配为空：即考虑 $isMatch(s,p[2:])$。</p>
<p>② 继续匹配 $p[0]$：即考虑 $isMatch(s[1:],p)$，前提 $s[0]$ 和 $p[0]$ 匹配。</p>
</li>
<li><p>其它情况：</p>
<p>考虑 $isMatch(s[1:],p)$，前提 $s[0]$ 和 $p[0]$ 匹配。</p>
</li>
</ul>
<p>时间复杂度 $O(n!)$。</p>
<h2 id="二：动态规划"><a href="#二：动态规划" class="headerlink" title="二：动态规划"></a>二：动态规划</h2><p>从后往前扫，$dp[i][j]$ 表示用掉当前位置字符后，是否可以匹配。</p>
<p>考虑以下三种转移方式。</p>
<p>① 直接匹配当前字符：$dp[i][j] \leftarrow dp[i+1][j+1]$。</p>
<p>② $*$ 代表 0 个字符：$dp[i][j] \leftarrow dp[i][j+2]$。</p>
<p>③ $*$ 代表多个字符：$dp[i][j] \leftarrow dp[i+1][j]$。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty())   <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span>(p.size() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isMatch(s,p.substr(<span class="number">2</span>)))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.empty())   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">0</span>] != p[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>),p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty())   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; s[<span class="number">0</span>] != p[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[s.length()][p.length()] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ok = i &lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(ok)  dp[i][j] |= dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j &lt; p.length()<span class="number">-1</span> &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)  </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] |= dp[i][j+<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span>(ok) dp[i][j] |= dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> self.isMatch(s,p[<span class="number">2</span>:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">0</span>] != p[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:],p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">0</span>] != p[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:],p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(p)+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s),-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                ok = i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> ok:</span><br><span class="line">                    dp[i][j] |= dp[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(p)-<span class="number">1</span> <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:  </span><br><span class="line">                    dp[i][j] |= dp[i][j+<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">if</span>(ok):</span><br><span class="line">                        dp[i][j] |= dp[i+<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11. Container With Most Water</title>
    <url>/2020/11/30/011.%20Container%20With%20Most%20Water/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>n</code> non-negative integers <code>a1, a2, ..., an</code> , where each represents a point at coordinate <code>(i, ai)</code>. <code>n</code> vertical lines are drawn such that the two endpoints of line <code>i</code> is at <code>(i, ai)</code> and <code>(i, 0)</code>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <code>n</code> is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p>
<p>The above vertical lines are represented by array <code>[1,8,6,2,5,4,8,3,7]</code>. In this case, the max area of water (blue section) the container can contain is 49.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定 <code>n</code> 个非负整数 <code>a1，a2，...，an</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 <code>n</code> 的值至少为 2。</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p>
<p>图中垂直线代表输入数组 <code>[1,8,6,2,5,4,8,3,7]</code>。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>双指针往里扫，每次移动矮的指针，保证当前最优。</p>
<p>因为间隔相等，故全局最优一定会被取到。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            maxx = max(maxx,min(height[l],height[r])*(r-l));</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r])   l++;</span><br><span class="line">            <span class="keyword">else</span>    r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,<span class="built_in">min</span>(height[l],height[r])*(r-l))</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 12. Integer to Roman</title>
    <url>/2020/11/30/012.%20Integer%20to%20Roman/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。<br><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。<br><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一共能表示 13 种面值，面值由大到小贪心即可。</p>
<p>时间复杂度小于 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">15</span>] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">15</span>] = &#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">13</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num -= a[i];</span><br><span class="line">                ans.append(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        a = [<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">        s = [<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;CM&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;CD&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;XC&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;XL&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;IX&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;IV&#x27;</span>,<span class="string">&#x27;I&#x27;</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">            <span class="keyword">while</span> num &gt;= a[i]:</span><br><span class="line">                num -= a[i]</span><br><span class="line">                ans.append(s[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 13. Roman to Integer</title>
    <url>/2020/11/30/013.%20Roman%20to%20Integer/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。<br><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。<br><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历字符串。</p>
<p>① 当 $s[i] &lt; s[i+1]$ 时，当前符号属于左值，减去对应数值。</p>
<p>② 当 $s[i] \geq s[i+1]$ 时，当前符号属于右值，加上对应数值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line">        mp[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        mp[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        mp[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        mp[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        mp[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        mp[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[s[i]] &lt; mp[s[i+<span class="number">1</span>]])	ans -= mp[s[i]];</span><br><span class="line">            <span class="keyword">else</span>	ans += mp[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mp[s.back()];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        mp = &#123;<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mp[s[i]]&lt; mp[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans -= mp[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += mp[s[i]]</span><br><span class="line">        ans += mp[s[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14. Longest Common Prefix</title>
    <url>/2020/11/30/014.%20Longest%20Common%20Prefix/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>多指针一起遍历每个字符串，取到字符不同为止。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty())    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,len = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)  len = min(len,(<span class="keyword">int</span>)strs[i].length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][j] != strs[<span class="number">0</span>][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    ok = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok)	ans++;</span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        len_max = <span class="built_in">min</span>([<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_max):</span><br><span class="line">            ok = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> s[i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    ok = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> ok:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:ans]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15. 3Sum</title>
    <url>/2020/11/30/015.%203Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array <code>nums</code> of <code>n</code> integers, are there elements <code>a, b, c</code> in <code>nums</code> such that <code>a + b + c = 0</code>? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a, b, c</code> ，使得 <code>a + b + c = 0</code> ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先排序。</p>
<p>遍历第一个数，后两个数双指针。</p>
<p>注意增加去重的细节。</p>
<p>另外增加了一些剪枝的细节。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>] &gt; <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>] &lt; <span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>,r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[i]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span>(t &lt; <span class="number">0</span>)	l++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; <span class="number">0</span>)	r--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(&#123;nums[i],nums[l++],nums[r--]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])    l++;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>])    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l,r = i+<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                t = nums[i]+nums[l]+nums[r]</span><br><span class="line">                <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> t &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i],nums[l],nums[r]])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l-<span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r+<span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 16. 3Sum Closest</title>
    <url>/2020/11/30/016.%203Sum%20Closest/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array <code>nums</code> of <code>n</code> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个包括 <code>n</code> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 2, 1, -4], and target &#x3D; 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先排序。</p>
<p>遍历第一个数，后两个数双指针。</p>
<p>通过 $sum$ 和 $target$ 的比较确定哪边指针移动。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans,minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size()<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>,r = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">int</span> diff = <span class="built_in">abs</span>(sum-target);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; minn)</span><br><span class="line">                &#123;</span><br><span class="line">                    minn = diff;</span><br><span class="line">                    ans = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)    l++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)   r--;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        minn = <span class="number">1e18</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            l,r = i+<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                t = nums[i]+nums[l]+nums[r]</span><br><span class="line">                diff = <span class="built_in">abs</span>(t-target)</span><br><span class="line">                <span class="keyword">if</span> diff &lt; minn:</span><br><span class="line">                    ans,minn = t,diff</span><br><span class="line">                <span class="keyword">if</span> t &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> t &gt; target:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 17. Letter Combinations of a Phone Number</title>
    <url>/2020/11/30/017.%20Letter%20Combinations%20of%20a%20Phone%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>循环，遍历每种组合。</p>
<p>时间复杂度 $O(4^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty())  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        mp[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : digits)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> each : mp[c])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> pre : ans)   t.push_back(pre+each);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = &#123;<span class="number">2</span>:<span class="string">&#x27;abc&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;def&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;ghi&#x27;</span>,<span class="number">5</span>:<span class="string">&#x27;jkl&#x27;</span>,<span class="number">6</span>:<span class="string">&#x27;mno&#x27;</span>,<span class="number">7</span>:<span class="string">&#x27;pqrs&#x27;</span>,<span class="number">8</span>:<span class="string">&#x27;tuv&#x27;</span>,<span class="number">9</span>:<span class="string">&#x27;wxyz&#x27;</span>&#125;</span><br><span class="line">        ans = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> digits:</span><br><span class="line">            t = []</span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> s[<span class="built_in">int</span>(c)]:</span><br><span class="line">                t.extend([pre+each <span class="keyword">for</span> pre <span class="keyword">in</span> ans])</span><br><span class="line">            ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
        <tag>Depth-first Search</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 18. 4Sum</title>
    <url>/2020/11/30/018.%204Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array <code>nums</code> of <code>n</code> integers and an integer <code>target</code>, are there elements <code>a, b, c, d</code> in <code>nums</code> such that <code>a + b+ c + d = target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <code>a, b, c, d</code> ，使得 <code>a + b + c + d</code> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 3Sum 的基础上加一层循环。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)   <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size()<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>] &gt; target)	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>] &lt; target)	<span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; nums.size()<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>] &gt; target)	<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>] &lt; target)	<span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">if</span>(j != i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l = j+<span class="number">1</span>,r = nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; target)  l++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; target) r--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.push_back(&#123;nums[i],nums[j],nums[l++],nums[r--]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])    l++;</span><br><span class="line">                        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>])    r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[n-<span class="number">3</span>]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> j != i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l,r = j+<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    t = nums[i]+nums[j]+nums[l]+nums[r]</span><br><span class="line">                    <span class="keyword">if</span> t &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> t &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans.append([nums[i],nums[j],nums[l],nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l-<span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r+<span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 19. Remove Nth Node From End of List</title>
    <url>/2020/11/30/019.%20Remove%20Nth%20Node%20From%20End%20of%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list, remove the <code>n</code>-th node from the end of list and return its head.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表，删除链表的倒数第 <code>n</code> 个节点，并且返回链表的头结点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Given <code>n</code> will always be valid.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do this in one pass?</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用两个相差 $n-1$ 个节点的指针一起跑。</p>
<p>后一个跑到最后，则前一个为倒数第 $n$ 个。</p>
<p>在链表前增加了一个新的节点以处理要删除的节点为首节点的情况。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*last = ans,*now = head,*t = head;</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(--n)  t = t-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(t-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            last = now;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next = now-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        last,now,t = ans,head,head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            t = t.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> t.<span class="built_in">next</span>:</span><br><span class="line">            t = t.<span class="built_in">next</span></span><br><span class="line">            last = now</span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        last.<span class="built_in">next</span> = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20. Valid Parentheses</title>
    <url>/2020/11/30/020.%20Valid%20Parentheses/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li><p>左括号必须用相同类型的右括号闭合。</p>
</li>
<li><p>左括号必须以正确的顺序闭合。</p>
</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>括号匹配，使用栈，遍历字符串。</p>
<p>① 为左括号，入栈。</p>
<p>② 为右括号，判断栈顶是否与之匹配。匹配则左括号出栈，否则不符合括号匹配规则。</p>
<p>最终判断栈是否为空。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">&#x27;)&#x27;</span>] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;]&#x27;</span>] = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;&#125;&#x27;</span>] = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>)   st.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!st.empty() &amp;&amp; mp[s[i]] == st.top())    st.pop();</span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        mp = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(st) != <span class="number">0</span> <span class="keyword">and</span> mp[c] == st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(st) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21. Merge Two Sorted Lists</title>
    <url>/2020/11/30/021.%20Merge%20Two%20Sorted%20Lists/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h1><p>同时扫一遍，每次将小的那个值加进结果链表中。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *now = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*ans = now;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!l2 || l1 &amp;&amp; l2 &amp;&amp; l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                now-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                now-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        now = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans = now</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l2 <span class="keyword">or</span> l1 <span class="keyword">and</span> l2 <span class="keyword">and</span> l1.val &lt; l2.val:</span><br><span class="line">                now.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 22. Generate Parentheses</title>
    <url>/2020/11/30/022.%20Generate%20Parentheses/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>n</code> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出 <code>n</code> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">given n &#x3D; 3, a solution set is:</span><br><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，遍历所有组合。</p>
<p>$dfs(ans,l,r,s)$ 表示在剩余左括号 $l$ 个，右括号 $r$ 个，当前字符串为 $s$ 的状态。</p>
<p>存在以下两种转移方式。</p>
<p>① 当 $l &gt; 0$ 时，$(l,r)\rightarrow (l-1,r)$。</p>
<p>② 当 $r &gt; l$ 时，$(l,r)\rightarrow (l,r-1)$。</p>
<p>注意每一步剩余的左括号不能比右括号多，否则将不符合括号匹配的规则。</p>
<p>时间复杂度 $O(2^{2n})$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        dfs(ans,n,n,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l)   dfs(ans,l<span class="number">-1</span>,r,s+<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; l)   dfs(ans,l,r<span class="number">-1</span>,s+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        self.dfs(ans,n,n,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,l,r,s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span>:</span><br><span class="line">            ans.append(s)</span><br><span class="line">        <span class="keyword">if</span> l &gt; <span class="number">0</span>:</span><br><span class="line">            self.dfs(ans,l-<span class="number">1</span>,r,s+<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> r &gt; l:</span><br><span class="line">            self.dfs(ans,l,r-<span class="number">1</span>,s+<span class="string">&#x27;)&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 23. Merge k Sorted Lists</title>
    <url>/2020/11/30/023.%20Merge%20k%20Sorted%20Lists/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Merge <code>k</code> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>合并 <code>k</code> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：优先队列"><a href="#一：优先队列" class="headerlink" title="一：优先队列"></a>一：优先队列</h2><p>维护一个长度为 $m$ 的优先队列。</p>
<p>将 $m$ 个链表的首节点放入优先队列。</p>
<p>每次取其中最小的，并将其下一个元素加入有限队列。</p>
<p>时间复杂度 $O(nmlog(m))$，其中 $n$ 为链表长度，$m$ 为链表数量。</p>
<h2 id="二：分治，自顶向下"><a href="#二：分治，自顶向下" class="headerlink" title="二：分治，自顶向下"></a>二：分治，自顶向下</h2><p>自顶向下两两合并链表。</p>
<p>时间复杂度 $O(nmlog(m))$。</p>
<h2 id="三：分治，自底向上"><a href="#三：分治，自底向上" class="headerlink" title="三：分治，自底向上"></a>三：分治，自底向上</h2><p>自顶向下两两合并链表。</p>
<p>时间复杂度 $O(nmlog(m))$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,ListNode*&gt; pa;</span><br><span class="line">	    <span class="built_in">priority_queue</span>&lt;pa,<span class="built_in">vector</span>&lt;pa&gt;,greater&lt;pa&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.size();i++)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i])    q.push(&#123;lists[i]-&gt;val,lists[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = p;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pa now = q.top();</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(now.first);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(now.second-&gt;next)	q.push(&#123;now.second-&gt;next-&gt;val,now.second-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty())   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt; lists,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> lists[l];</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = p;</span><br><span class="line">        ListNode *now1 = merge(lists,l,(l+r)/<span class="number">2</span>);</span><br><span class="line">        ListNode *now2 = merge(lists,(l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">while</span>(now1 || now2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now1 &amp;&amp; now2 &amp;&amp; now1-&gt;val &lt; now2-&gt;val || !now2)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(now1-&gt;val);</span><br><span class="line">                now1 = now1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(now2-&gt;val);</span><br><span class="line">                now2 = now2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty())   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>,len = lists.size();</span><br><span class="line">        <span class="keyword">while</span>(gap &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len-gap;i += gap*<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lists[i] = mergeTwoLists(lists[i],lists[i+gap]);</span><br><span class="line">            &#125;</span><br><span class="line">            gap *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = p;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)  p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2)  p-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">        q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">enumerate</span>(lists):</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put((l.val,i))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            val, i = q.get()</span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            lists[i] = lists[i].<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                q.put((lists[i].val,i))</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists</span>):</span></span><br><span class="line">        l = <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        gap = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> gap &lt; l:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l-gap,gap*<span class="number">2</span>):</span><br><span class="line">                lists[i] = self.merge2Lists(lists[i],lists[i+gap])</span><br><span class="line">            gap *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span>=l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.<span class="built_in">next</span>=l1</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(lists,<span class="number">0</span>,<span class="built_in">len</span>(lists)-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,lists,l,r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> lists[l]</span><br><span class="line">        head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">        l1,l2 = self.merge(lists,l,(l+r)//<span class="number">2</span>),self.merge(lists,(l+r)//<span class="number">2</span>+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span>=l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.<span class="built_in">next</span>=l1</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 24. Swap Nodes in Pairs</title>
    <url>/2020/11/30/024.%20Swap%20Nodes%20in%20Pairs/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：改变链表指针"><a href="#一：改变链表指针" class="headerlink" title="一：改变链表指针"></a>一：改变链表指针</h2><p>加上了一个空的首节点。</p>
<p>两两交换节点，注意奇数的时候尾节点不处理。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：交换数值"><a href="#二：交换数值" class="headerlink" title="二：交换数值"></a>二：交换数值</h2><p>加上了一个空的首节点。</p>
<p>直接两两交换节点的数值，注意奇数的时候尾节点不处理。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *p = ans;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *q = p-&gt;next;</span><br><span class="line">            ListNode *r = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!r)  <span class="keyword">break</span>;</span><br><span class="line">            p-&gt;next = r;</span><br><span class="line">            q-&gt;next = r-&gt;next;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *p = ans;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *q = p-&gt;next;</span><br><span class="line">            ListNode *r = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!r)  <span class="keyword">break</span>;</span><br><span class="line">            swap(q-&gt;val,r-&gt;val);</span><br><span class="line">            p = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        p = ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            q = p.<span class="built_in">next</span></span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p.<span class="built_in">next</span> = r</span><br><span class="line">            q.<span class="built_in">next</span> = r.<span class="built_in">next</span></span><br><span class="line">            r.<span class="built_in">next</span> = q</span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        p = ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            q = p.<span class="built_in">next</span></span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            q.val,r.val = r.val,q.val</span><br><span class="line">            p = r</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 25. Reverse Nodes in k-Group</title>
    <url>/2020/11/30/025.%20Reverse%20Nodes%20in%20k-Group/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list, reverse the nodes of a linked list <code>k</code> at a time and return its modified list.</p>
<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes in the end should remain as it is.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个链表，每 <code>k</code> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历链表，每满 $k$  个交换一轮，只交换节点的数值。</p>
<p>注意尾部不足 $k$ 个不处理。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *p = ans;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;ListNode*&gt; v;</span><br><span class="line">            <span class="keyword">int</span> n = k;</span><br><span class="line">            <span class="keyword">while</span>(n-- &amp;&amp; p-&gt;next) </span><br><span class="line">            &#123;</span><br><span class="line">                v.push_back(p-&gt;next);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.size() != k)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = v.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)    swap(v[l++]-&gt;val,v[r--]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        p = ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            nodes = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p.<span class="built_in">next</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">                nodes.append(p)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nodes) != k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l,r = <span class="number">0</span>,<span class="built_in">len</span>(nodes)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                nodes[l].val,nodes[r].val = nodes[r].val,nodes[l].val</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
    <url>/2020/11/30/026.%20Remove%20Duplicates%20from%20Sorted%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a sorted array <code>nums</code>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>双指针，直接在原数组上操作。</p>
<p>遍历一遍数组，同时维护当前无重复元素的位置。</p>
<p>因为数组是有序的，故只要判断 $nums[i] \neq nums[i-1]$ 是否成立即可知道该元素是否需要被保留。</p>
<p>也可直接使用 C++ 中的 $unique$ 实现。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>])    nums[now++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unique(nums.begin(),nums.end())-nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        now = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[now] = nums[i]</span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27. Remove Element</title>
    <url>/2020/11/30/027.%20Remove%20Element/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array <code>nums</code> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>双指针，直接在原数组上操作。</p>
<p>遍历一遍数组，同时维护当前未出现 $val$ 数组的位置。</p>
<p>只要判断 $nums[i] \neq val$ 是否成立即可知道该元素是否需要被保留。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)  nums[now++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[now] = nums[i]</span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28. Implement strStr()</title>
    <url>/2020/11/30/028.%20Implement%20strStr()/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>实现 <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a> 函数。</p>
<p>给定一个 <code>haystack</code> 字符串和一个 <code>needle</code> 字符串，在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>).</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>KMP算法。</p>
<p>参考 <a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a>。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ne;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getnext(needle);</span><br><span class="line">        <span class="keyword">return</span> kmp(haystack,needle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">string</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>,lenx = x.length();</span><br><span class="line">        ne.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; lenx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || x[i] == x[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x[++i] == x[++j])    ne.push_back(ne[j]);</span><br><span class="line">                <span class="keyword">else</span>    ne.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,lens = s.length(),lenx = x.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; lens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || x[j] == s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++,j++;</span><br><span class="line">                <span class="keyword">if</span>(j == lenx)   <span class="keyword">return</span> i-lenx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getnext</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        ne = [-<span class="number">1</span>]</span><br><span class="line">        i,j = <span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(x):</span><br><span class="line">            <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> x[i] == x[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(x) <span class="keyword">and</span> x[i] == x[j]:</span><br><span class="line">                    ne.append(ne[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ne.append(j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = ne[j]</span><br><span class="line">        <span class="keyword">return</span> ne</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp</span>(<span class="params">self,s,x,ne</span>):</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> s[i] == x[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="built_in">len</span>(x):</span><br><span class="line">                    <span class="keyword">return</span> i-<span class="built_in">len</span>(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = ne[j]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ne = self.getnext(needle)</span><br><span class="line">        <span class="keyword">return</span> self.kmp(haystack,needle,ne)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 29. Divide Two Integers</title>
    <url>/2020/11/30/029.%20Divide%20Two%20Integers/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 <code>mod</code> 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}$,  $2^{31 − 1}$]. For the purpose of this problem, assume that your function returns $2^{31 − 1}$ when the division result overflows.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为输入均在 $int$ 的范围内，故只有一种溢出的情况 $\frac{-2^{31}}{-1}$。</p>
<p>按照二进制的思路，从高位到低位确定每一位的取值。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">-2147483648</span> &amp;&amp; divisor == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = dividend,b = divisor,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = -a;</span><br><span class="line">            sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            sign = -sign;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a &gt;= b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t = b,now = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(a &gt;= t+t)</span><br><span class="line">            &#123;</span><br><span class="line">                t += t;</span><br><span class="line">                now += now;</span><br><span class="line">            &#125;</span><br><span class="line">            a -= t;</span><br><span class="line">            ans += now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">1</span>)   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> -ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> dividend == -<span class="number">2147483648</span> <span class="keyword">and</span> divisor == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>:</span><br><span class="line">            divisor = -divisor</span><br><span class="line">            sign = -sign</span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>:</span><br><span class="line">            dividend = -dividend</span><br><span class="line">            sign = -sign</span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            t = divisor</span><br><span class="line">            now = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= t+t:</span><br><span class="line">                t += t</span><br><span class="line">                now += now</span><br><span class="line">            dividend -= t</span><br><span class="line">            ans += now</span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -ans</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 30. Substring with Concatenation of All Words</title>
    <url>/2020/11/30/030.%20Substring%20with%20Concatenation%20of%20All%20Words/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given a string, <code>s</code>, and a list of words, <code>words</code>, that are all of the same length. Find all starting indices of <code>substring(s)</code> in <code>s</code> that is a concatenation of each word in <code>words</code> exactly once and without any intervening characters.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 <code>s</code> 和一些长度相同的单词 <code>words</code>。找出 <code>s</code> 中恰好可以由 <code>words</code> 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 <code>words</code> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <code>words</code> 中单词串联的顺序。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>令 $slen = \mathbb{len}(s)$，$wlen = \mathbb{len}(word)$ ，$num = \frac{\mathbb{len}(words)}{wlen}$。</p>
<p>首先使用 $map$ 存储 $words$ 中所有单词数量。</p>
<p>最暴力的方法为遍历 $s$ 中所有长度为 $wlen*num$ 的子串，判断每个子串是否符合要求。</p>
<p>判断每一子串是否符合要求时，只需其满足 $s$ 中出现得每个单词数量与 $map$ 中相同即可。</p>
<p>这里的判断数量，可以直接减去 $map$ 中对应单词的数量，减至0，表示该单词已全部出现。</p>
<p>在上述过程中，其实很多子串重复计算了很多信息，如以 $[0,wlen,2*wlen,\cdots]$ 起始的子串。</p>
<p>故将所有子串划分为 $wlen$ 组。</p>
<p>对于每一组子串，使用双指针 $l,r$。</p>
<p>维护当前区间内出现的单词情况。</p>
<p>① 当前单词在 $map$ 中，且其计数大于 0，则 $map$ 中对应单词的计数减一。</p>
<p>② 当前单词未出现在 $map$ ，则令 $l = r = r+wlen$，重置 $map$ 中地计数。</p>
<p>③ 当前单词在 $map$ 中数量耗尽，则将 $l$ 移动到区间中第一次出现该单词的位置的下一个单词，更新 $map$。</p>
<p>时间复杂度 $O(slen<em>wlen</em>log(num))$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(words.empty())   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> num = words.size(),wlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> group = <span class="number">0</span>;group &lt; wlen;group++)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)  mp[words[i]]++;</span><br><span class="line">            <span class="keyword">int</span> l = group,r = group;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; s.length()-num*wlen+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> ss = s.substr(r,wlen);</span><br><span class="line">                <span class="keyword">while</span>(mp.count(ss) &amp;&amp; mp[ss])</span><br><span class="line">                &#123;</span><br><span class="line">                    mp[ss]--;</span><br><span class="line">                    r += wlen;</span><br><span class="line">                    <span class="keyword">if</span>(r-l == wlen*num)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.push_back(l);</span><br><span class="line">                        mp[s.substr(l,wlen)]++;</span><br><span class="line">                        l += wlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ss = s.substr(r,wlen);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="keyword">if</span>(!mp.count(ss))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mp[s.substr(l,wlen)]++;</span><br><span class="line">                        l += wlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(s.substr(l,wlen) != ss)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mp[s.substr(l,wlen)]++;</span><br><span class="line">                        l += wlen;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                l += wlen;</span><br><span class="line">                r += wlen;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: List[<span class="built_in">str</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        num,wlen = <span class="built_in">len</span>(words),<span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> <span class="built_in">range</span>(wlen):</span><br><span class="line">            mp = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                mp[word] = mp.get(word,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            l,r = group,group</span><br><span class="line">            <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(s)-num*wlen+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> mp.get(s[r:r+wlen],<span class="number">0</span>):</span><br><span class="line">                    mp[s[r:r+wlen]] -= <span class="number">1</span></span><br><span class="line">                    r += wlen</span><br><span class="line">                    print(r)</span><br><span class="line">                    <span class="keyword">if</span> r-l == num*wlen:</span><br><span class="line">                        ans.append(l)</span><br><span class="line">                        mp[s[l:l+wlen]] += <span class="number">1</span></span><br><span class="line">                        l += wlen</span><br><span class="line">                <span class="keyword">if</span> s[r:r+wlen] <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                        mp[s[l:l+wlen]] += <span class="number">1</span></span><br><span class="line">                        l += wlen</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> s[l:l+wlen] != s[r:r+wlen]:</span><br><span class="line">                        mp[s[l:l+wlen]] += <span class="number">1</span></span><br><span class="line">                        l += wlen</span><br><span class="line">                l += wlen</span><br><span class="line">                r += wlen</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 31. Next Permutation</title>
    <url>/2020/11/30/031.%20Next%20Permutation/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be <strong>in-place</strong> and use only constant extra memory.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，从后往前找到第一个满足 $nums[i] &lt; nums[i+1]$ 的位置 $i$。</p>
<p>从 $i$ 位置之后取比 $nums[i]$ 大的最小的数，与 $nums[i]$ 交换。</p>
<p>最后将 $i$ 之后得序列排序，因为该序列已经满足非递增，故只需要反转即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(),nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> now = nums.size()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(now &gt;= <span class="number">0</span> &amp;&amp; nums[now] &gt;= nums[now+<span class="number">1</span>]) now--;</span><br><span class="line">        <span class="keyword">if</span>(now &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now2 = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[now] &gt;= nums[now2])  now2--;</span><br><span class="line">            swap(nums[now],nums[now2]);    </span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+now+<span class="number">1</span>,nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        now = <span class="built_in">len</span>(nums)-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> now &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[now] &gt;= nums[now+<span class="number">1</span>]:</span><br><span class="line">            now -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> now &gt;= <span class="number">0</span>:</span><br><span class="line">            now2 = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[now] &gt;= nums[now2]:</span><br><span class="line">                now2 -=<span class="number">1</span></span><br><span class="line">            nums[now],nums[now2] = nums[now2],nums[now]</span><br><span class="line">        nums[now+<span class="number">1</span>:] = <span class="built_in">reversed</span>(nums[now+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 32. Longest Valid Parentheses</title>
    <url>/2020/11/30/032.%20Longest%20Valid%20Parentheses/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：栈"><a href="#一：栈" class="headerlink" title="一：栈"></a>一：栈</h2><p>遍历字符串，使用栈中存放每个左括号的位置。</p>
<p>当遇到右括号时，$pop$ 掉上一个左括号，此时以该右括号为结尾的最长串的起始元素为当前栈顶的下个元素。</p>
<p>此外，需要处理边界问题，遍历之前需要加入 -1 边界。</p>
<p>每次右括号将栈消耗空时，意味着当前右括号无法匹配，也加入该位置作为边界。</p>
<p>可以消掉的括号直接出栈</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：动态规划"><a href="#二：动态规划" class="headerlink" title="二：动态规划"></a>二：动态规划</h2><p>$dp[i]$ 表示以 $i$ 位置为结尾的最长串长度。</p>
<p>考虑以下三种转移情况情况：</p>
<p>① $s[i] == ‘(‘$，则 $dp[i] = 0$。</p>
<p>② $s[i] == ‘)’$ 且 $s[i-1] == ‘(‘$，则 $dp[i] = dp[i-2]+2$。</p>
<p>注：考虑了 $s[i]s[i-1]$ 组合成为一对括号，加上这对括号之前相连的 $dp[i-2]$。</p>
<p>③ $s[i] == ‘)’$ 且 $s[i-1] == ‘)’$ 且 $dp[i-1] &lt; i$ 且 $s[i-dp[i-1]-1] == ‘(‘$，</p>
<p>则 $dp[i] = 2+dp[i-1]+dp[i-dp[i-1]-2]$。</p>
<p>注：考虑了 $dp[i-1]$ 的串和该串两端的一对括号，再加与左括号之前相连的 $dp[i-dp[i-1]-2]$。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) st.push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(st.empty())  st.push(i);</span><br><span class="line">                <span class="keyword">else</span>    ans = max(ans,i-st.top());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.length(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>)   dp[i] += dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>] &lt; i &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>] &gt; <span class="number">1</span>)   dp[i] += dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length();i++)   ans = max(ans,dp[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        st = [-<span class="number">1</span>]</span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                st.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st) == <span class="number">0</span>:</span><br><span class="line">                    st.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    maxx = <span class="built_in">max</span>(maxx,i-st[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxx</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">elif</span> dp[i-<span class="number">1</span>] &lt; i <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i-dp[i-<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">                    dp[i] += dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 33. Search in Rotated Sorted Array</title>
    <url>/2020/11/30/033.%20Search%20in%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(log n)$.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 $O(log n)$ 级别。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先二分找扭转的位置，即第一个使得 $nums[i] &lt; nums.back()$ 成立的 $i$。</p>
<p>注：该位置为扭转位置的前提为，数组中无重复元素。</p>
<p>再根据 $target$ 与扭转数值的大小决定从哪一段种二分找 $target$。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums.back()) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; target &lt;= nums.back())  r = nums.size();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = l;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(nums.begin()+l,nums.begin()+r,target)-nums.begin();</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; r &amp;&amp; nums[pos] == target)  <span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[-<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[l] &lt;= target &lt;= nums[-<span class="number">1</span>]:</span><br><span class="line">            l,r = l,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l,r = <span class="number">0</span>,l</span><br><span class="line">        rr = r</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> l &lt; rr <span class="keyword">and</span> nums[l] == target:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2020/11/30/034.%20Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>Your algorithm’s runtime complexity must be in the order $O(log n)$.</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 $O(log n)$ 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分找第一个左右边界。</p>
<p>左边界：第一个使得 $nums[i] \geq target$ 成立的 $i$。</p>
<p>右边界：第一个使得 $nums[i] &gt; target$ 成立的 $i$，再加1。</p>
<p>C++ 中可直接使用 $lower_bound$ 和 $upper_bound$ 函数。</p>
<p>注意判断 $target$ 是否在数组中。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(nums.begin(),nums.end(),target)-nums.begin();</span><br><span class="line">        <span class="keyword">if</span>(l == nums.size() || nums[l] != target)   <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(nums.begin(),nums.end(),target)-nums.begin();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;l,r<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)  l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(l == nums.size() || nums[l] != target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(l);</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)	l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>	r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">     	ans.push_back(l<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[l] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        ans = [l]</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        ans.append(l-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35. Search Insert Position</title>
    <url>/2020/11/30/035.%20Search%20Insert%20Position/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分找第一个使得 $nums[i] \geq target$ 成立的 $i$。</p>
<p>C++ 中可直接使用 $lower_bound$ 和 $upper_bound$ 函数。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(),nums.end(),target)-nums.begin();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)  l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 36. Valid Sudoku</title>
    <url>/2020/11/30/036.%20Valid%20Sudoku/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Determine if a <code>9x9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p>
<ol>
<li>Each row must contain the digits <code>1-9</code> without repetition.</li>
<li>Each column must contain the digits <code>1-9</code> without repetition.</li>
<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>A partially filled sudoku which is valid.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>判断一个 <code>9x9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li><p>数字 <code>1-9</code> 在每一列只能出现一次。</p>
</li>
<li><p>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</p>
</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being </span><br><span class="line">    modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>分别统计每行、每列、每个九宫格的数字出现个数。</p>
<p>只要某个数字出现超过 2 次，则不合法。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp1[<span class="number">9</span>],mp2[<span class="number">9</span>],mp3[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(++mp1[i][c] == <span class="number">2</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(++mp2[j][c] == <span class="number">2</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(++mp3[k][c] == <span class="number">2</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        mp1,mp2,mp3 = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                k = i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span></span><br><span class="line">                c = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                mp1[i][c] = mp1[i].get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                mp2[j][c] = mp2[j].get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                mp3[k][c] = mp3[k].get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> mp1[i][c] == <span class="number">2</span> <span class="keyword">or</span> mp2[j][c] == <span class="number">2</span> <span class="keyword">or</span> mp3[k][c] == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 37. Sudoku Solver</title>
    <url>/2020/11/30/037.%20Sudoku%20Solver/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>
<ol>
<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
<li>Each of the the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>
</ol>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li><p>数字 <code>1-9</code> 在每一行只能出现一次。</p>
</li>
<li><p>数字 <code>1-9</code> 在每一列只能出现一次。</p>
</li>
<li><p>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</p>
</li>
</ol>
<p>空白格用 <code>&#39;.&#39;</code> 表示。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"><br>A sudoku puzzle…</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"><br>…and its solution numbers marked in red.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，暴力枚举每一种可能。</p>
<p>过程中判断当前位置加入某个值时，三类框中是否冲突，已达到剪枝效果。</p>
<p>回溯时，需要将当前位置清空。</p>
<p>优于剪枝的存在，时间复杂度几乎 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> mp1[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,mp2[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,mp3[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">set</span>(board,i,j,board[i][j]-<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        board[i][j] = x+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		mp1[i][x] = <span class="number">1</span>;</span><br><span class="line">		mp2[j][x] = <span class="number">1</span>;</span><br><span class="line">		mp3[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		mp1[i][x] = <span class="number">0</span>;</span><br><span class="line">		mp2[j][x] = <span class="number">0</span>;</span><br><span class="line">		mp3[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; <span class="number">9</span>;i++,j = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; <span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; <span class="number">9</span>;x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp1[i][x])   <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mp2[j][x])   <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mp3[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][x])   <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="built_in">set</span>(board,i,j,x);</span><br><span class="line">                    <span class="keyword">if</span>(dfs(board,i,j))   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    unset(board,i,j,x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        need = [(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) <span class="keyword">if</span> <span class="keyword">not</span> board[i][j].isdigit()]</span><br><span class="line">        self.dfs(board,<span class="number">0</span>,need)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,board,now,need</span>):</span></span><br><span class="line">        <span class="keyword">if</span> now == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        i,j = need[now]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> board[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> [board[_][j] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ii,jj = i//<span class="number">3</span>*<span class="number">3</span>,j//<span class="number">3</span>*<span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> [board[_][__] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(ii,ii+<span class="number">3</span>) <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(jj,jj+<span class="number">3</span>)]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            board[i][j] = x</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board,now+<span class="number">1</span>,need):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 38. Count and Say</title>
    <url>/2020/11/30/038.%20Count%20and%20Say/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <code>n</code> where 1 ≤ <code>n</code> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  <code>&quot;one 1&quot;</code> （<code>&quot;一个二&quot;</code> , <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <code>n</code>（1 ≤ <code>n</code> ≤ 30），输出报数序列的第 <code>n</code> 项。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每一轮计算字符串中所有连续串，以此构成下一轮的字符串。</p>
<p>在字符串尾部加个字符以处理边界问题。</p>
<p>时间复杂度 $O(\sum_1^{n}{\mathbb{len}(s_n)})$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">2</span>;cnt &lt;= n;cnt++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            s.append(<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="built_in">string</span> ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[last])</span><br><span class="line">                &#123;</span><br><span class="line">                    ss.append(to_string(i-last));</span><br><span class="line">                    ss.append(<span class="number">1</span>,s[last]);</span><br><span class="line">                    last = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s = ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        s = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            s = s+<span class="string">&#x27;.&#x27;</span></span><br><span class="line">            ss = []</span><br><span class="line">            last = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] != s[last]:</span><br><span class="line">                    ss.append(<span class="built_in">str</span>(i-last)+s[last])</span><br><span class="line">                    last = i</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span>.join(ss)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 39. Combination Sum</title>
    <url>/2020/11/30/039.%20Combination%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <strong>无重复元素</strong> 的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对 $candidates$ 排序，dfs 遍历所有可能的组合。</p>
<p>$dfs(and,candidates,now,left,p)$ 表示已到 $candidates$ 中的位置 $p$，当前剩余值 $left$，此时已加入的元素为数组 $now$。</p>
<p>过程中若 $left &lt; candidates[p]$，则直接剪枝。</p>
<p>否则，考虑以下两种转移方式：</p>
<p>① 使用一次 $p$ 位置的数，$dfs(and,candidates,now,left,p)\rightarrow dfs(and,candidates,now,left-x,p)$。</p>
<p>② 不使用 $p$ 位置的数，$dfs(and,candidates,now,left,p)\rightarrow dfs(and,candidates,now,left,p+1)$。</p>
<p>回溯过程中，注意同时抛掉数组 $now$ 中刚加进去的元素。</p>
<p>时间复杂度视情况而定。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        dfs(ans,candidates,now,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="keyword">int</span> left,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == candidates.size())  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> x = candidates[p];</span><br><span class="line">        <span class="keyword">if</span>(left &lt; x)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(ans,candidates,now,left,p+<span class="number">1</span>);</span><br><span class="line">        now.push_back(x);</span><br><span class="line">        dfs(ans,candidates,now,left-x,p);</span><br><span class="line">        now.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        now = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(ans,candidates,now,target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,candidates,now,left,p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">            ans.append(now[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="built_in">len</span>(candidates):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = candidates[p]</span><br><span class="line">        <span class="keyword">if</span> left &lt; x:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(ans,candidates,now,left,p+<span class="number">1</span>)</span><br><span class="line">        now.append(x)</span><br><span class="line">        self.dfs(ans,candidates,now,left-x,p)</span><br><span class="line">        now.pop()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 40. Combination Sum II</title>
    <url>/2020/11/30/040.%20Combination%20Sum%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对 $candidates$ 排序，dfs 遍历所有可能的组合。</p>
<p>$dfs(and,candidates,now,left,p,ok)$ 表示已到 $candidates$ 中的位置 $p$，当前剩余值 $left$，此时已加入的元素为数组 $now$，$ok$ 表示前一个位置的元素是否取到，若未取到，则后面与之相同的元素均略过，以实现去重。</p>
<p>过程中若 $left &lt; candidates[p]$，则直接剪枝。</p>
<p>否则，考虑以下两种转移方式：</p>
<p>① 使用 $p$ 位置的数，$dfs(and,candidates,now,left,ok)\rightarrow dfs(and,candidates,now,left-x,p+1,1)$。</p>
<p>② 不使用 $p$ 位置的数，$dfs(and,candidates,now,left,p)\rightarrow dfs(and,candidates,now,left,p+1,0)$。</p>
<p>回溯过程中，注意同时抛掉数组 $now$ 中刚加进去的元素。</p>
<p>时间复杂度小于 $O(2^{\mathbb{len}(candidates)})$，视情况而定。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        dfs(ans,candidates,now,target,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="keyword">int</span> left,<span class="keyword">int</span> p,<span class="keyword">bool</span> ok)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; candidates.size() &amp;&amp; candidates[p] == candidates[p<span class="number">-1</span>])    p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == candidates.size())  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> x = candidates[p];</span><br><span class="line">        <span class="keyword">if</span>(left &lt; x)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(ans,candidates,now,left,p+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        now.push_back(x);</span><br><span class="line">        dfs(ans,candidates,now,left-x,p+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        now.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        now = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(ans,candidates,now,target,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,candidates,now,left,p,ok</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">            ans.append(now[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">            <span class="keyword">while</span> p &lt; <span class="built_in">len</span>(candidates) <span class="keyword">and</span> candidates[p] == candidates[p-<span class="number">1</span>]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="built_in">len</span>(candidates):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = candidates[p]</span><br><span class="line">        <span class="keyword">if</span> left &lt; x:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(ans,candidates,now,left,p+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">        now.append(x)</span><br><span class="line">        self.dfs(ans,candidates,now,left-x,p+<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        now.pop()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 41. First Missing Positive</title>
    <url>/2020/11/30/041.%20First%20Missing%20Positive/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Your algorithm should run in $O(n)$ time and uses constant extra space.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在数组中添加一个无效值，使得原数组长度和下标对齐。</p>
<p>遍历数组，把数字放到对应坐标上，即 $nums[i]$ 放到 $nums[i]$ 位置上，继续将 $nums[nums[i]]$ 也放到对应位置…… </p>
<p>超出范围的值不作处理。</p>
<p>再次遍历数组，找出不在位置上的最小值，即为答案。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">0</span> &lt; nums[i] &amp;&amp; nums[i] &lt; nums.size())</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])    <span class="keyword">break</span>;</span><br><span class="line">                swap(nums[i],nums[nums[i]]);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt; nums[i] &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] != nums[nums[i]]:</span><br><span class="line">                j = nums[i]</span><br><span class="line">                nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 42. Trapping Rain Water</title>
    <url>/2020/11/30/042.%20Trapping%20Rain%20Water/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>The above elevation map is represented by array <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定 <code>n</code> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<strong>感谢 Marcos</strong> 贡献此图。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：单调栈"><a href="#一：单调栈" class="headerlink" title="一：单调栈"></a>一：单调栈</h2><p>遍历数组，维护一个高度递减的栈。</p>
<p>每在栈中加入一个块时，将比其小的块全部取出，同时加上以当前块为右边界增加得水量。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：双指针"><a href="#二：双指针" class="headerlink" title="二：双指针"></a>二：双指针</h2><p>左右双指针，每次选择矮的指针往里移动。</p>
<p>过程中维护两边最小值中的最大值，作为当前蓄水的最大高度。</p>
<p>每次移动时，加上当前位置地水量。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; height.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; height[s.top()] &lt;= height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (height[s.top()]-h)*(i-s.top()<span class="number">-1</span>);</span><br><span class="line">                h = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())  ans += (height[i]-h)*(i-s.top()<span class="number">-1</span>);</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> minn;</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r])   minn = height[l++];</span><br><span class="line">            <span class="keyword">else</span>    minn = height[r--];</span><br><span class="line">            maxx = max(maxx,minn);</span><br><span class="line">            ans += maxx-minn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            <span class="keyword">if</span> height[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            h = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> <span class="keyword">and</span> height[s[-<span class="number">1</span>]] &lt;= height[i]:</span><br><span class="line">                ans += (height[s[-<span class="number">1</span>]]-h)*(i-s[-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">                h = height[s[-<span class="number">1</span>]]</span><br><span class="line">                s.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                ans += (height[i]-h)*(i-s[-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                minn = height[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                minn = height[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,minn)</span><br><span class="line">            ans += maxx-minn</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 43. Multiply Strings</title>
    <url>/2020/11/30/043.%20Multiply%20Strings/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟大数乘法。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(num1.size()+num2.size(),<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.size()<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = (ans[i+j+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)+(num1[i]-<span class="string">&#x27;0&#x27;</span>)*(num2[j]-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">                ans[i+j+<span class="number">1</span>] = tmp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                carry = tmp/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = ans[i]+carry;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">int</span> startpos = ans.find_first_not_of(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(startpos != <span class="built_in">string</span>::npos)    <span class="keyword">return</span> ans.substr(startpos);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(num1)*<span class="built_in">int</span>(num2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 44. Wildcard Matching</title>
    <url>/2020/11/30/044.%20Wildcard%20Matching/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;?&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>?</code> or <code>*</code>.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;?&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure>
<p>两个字符串 <strong>完全匹配</strong> 才算匹配成功。</p>
<p><strong>说明</strong>:</p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二维动态规划，从后往前扫，$dp[i][j]$ 表示 $s$ 到 $i$ 、$p$ 到 $j$ 位置后，是否可以匹配。 </p>
<p>考虑以下三种转移方式：</p>
<p>① 直接匹配当前字符，$dp[i+1][j+1] \rightarrow dp[i][j]$。</p>
<p>② $*$ 代表0个字符，在当前位置失效，$dp[i][j+1]\rightarrow dp[i][j]$。 </p>
<p>③ $*$ 代表多个字符，在当前位置不失效，$dp[i+1][j]\rightarrow dp[i][j]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.length()+<span class="number">2</span>][p.length()+<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[s.length()][p.length()] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] |= dp[i][j+<span class="number">1</span>];</span><br><span class="line">                    dp[i][j] |= dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>))    dp[i][j] |= dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s),-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    dp[i][j] |= dp[i][j+<span class="number">1</span>]</span><br><span class="line">                    dp[i][j] |= dp[i+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">elif</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> (p[j] == <span class="string">&#x27;?&#x27;</span> <span class="keyword">or</span> s[i] == p[j]):   </span><br><span class="line">                    dp[i][j] |= dp[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 45. Jump Game II</title>
    <url>/2020/11/30/045.%20Jump%20Game%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2.</span><br><span class="line">    Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>You can assume that you can always reach the last index.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>贪心，遍历数组，维护当前可达的最大位置 $maxx2$。</p>
<p>同时记录一个在当前步数可达的最大位置 $maxx1$。</p>
<p>当到达当 $maxx1$ 时，更新步数，并将 $maxx1$ 同步为 $maxx2$。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx1 = <span class="number">0</span>,maxx2 = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxx2 = max(maxx2,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == maxx1)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                maxx1 = maxx2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        maxx1,maxx2,cnt = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            maxx2 = <span class="built_in">max</span>(maxx2,i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == maxx1:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                maxx1 = maxx2</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 46. Permutations</title>
    <url>/2020/11/30/046.%20Permutations/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，遍历每一种组合。</p>
<p>时间复杂度 $O(n^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now,ok(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dfs(ans,now,ok,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ok,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ok.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[i])   <span class="keyword">continue</span>;</span><br><span class="line">            ok[i] = <span class="number">1</span>;</span><br><span class="line">            now.push_back(nums[i]);</span><br><span class="line">            dfs(ans,now,ok,nums);</span><br><span class="line">            ok[i] = <span class="number">0</span>;</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            ans.append(now)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.dfs(ans,now+[nums[i]],nums[:i]+nums[i+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 47. Permutations II</title>
    <url>/2020/11/30/047.%20Permutations%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，在上一题的基础上，实现去重。</p>
<p>首先排序，然后在 dfs 每层中不取重复的数。</p>
<p>时间复杂度 $O(n^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now,ok(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dfs(ans,now,ok,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ok,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now.size() == nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ok.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[i])   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; !ok[i<span class="number">-1</span>] &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            ok[i] = <span class="number">1</span>;</span><br><span class="line">            now.push_back(nums[i]);</span><br><span class="line">            dfs(ans,now,ok,nums);</span><br><span class="line">            ok[i] = <span class="number">0</span>;</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        self.dfs(ans,[],nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            ans.append(now)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(ans,now+[nums[i]],nums[:i]+nums[i+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 48. Rotate Image</title>
    <url>/2020/11/30/048.%20Rotate%20Image/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an <code>n</code> x <code>n</code> 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p><strong>Note:</strong></p>
<p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <code>n</code> × <code>n</code> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明</strong>：</p>
<p>你必须在 <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>原地</strong></a> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对称的四个点为一组，旋转交换。</p>
<p>注意考虑行列数的奇偶性。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (n+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][i];</span><br><span class="line">                matrix[n-j<span class="number">-1</span>][i] = matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>];</span><br><span class="line">                matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>] = matrix[j][n-i<span class="number">-1</span>];</span><br><span class="line">                matrix[j][n-i<span class="number">-1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                t = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n-j-<span class="number">1</span>][i];</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>];</span><br><span class="line">                matrix[j][n-i-<span class="number">1</span>] = t;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 49. Group Anagrams</title>
    <url>/2020/11/30/049.%20Group%20Anagrams/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of strings, group anagrams together.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对每个字符串排序，将排序后的字符串作为其 $key$。</p>
<p>通过 $key$ 即可实现分组。</p>
<p>时间复杂度 $O(mnlog(n))$，$m$ 为字符串数量，$n$ 为字符串长度。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = strs[i];</span><br><span class="line">            sort(s.begin(),s.end());</span><br><span class="line">            mp[s].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.begin();it != mp.end();it++)   ans.push_back(it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        mp = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            mp[<span class="built_in">tuple</span>(<span class="built_in">sorted</span>(s))].append(s)</span><br><span class="line">        <span class="keyword">return</span> mp.values()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <url>/2020/11/30/050.%20Pow(x,%20n)/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> ($x^n$).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(x, n)</a> ，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; <code>x</code> &lt; 100.0</li>
<li><code>n</code> is a 32-bit signed integer, within the range [$−2^{31}$, $2^{31} − 1$]</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>快速幂。</p>
<p>首先，若 $n &lt; 0$，则将 $x$ 转化为 $\frac{1}{x}$ ，将 $n$ 转化为 $-n$。</p>
<p>然后从低位到高位考虑 $n$ 的二进制形式的每一位。</p>
<p>注意 $n$ 为 INT_MIN 转化为 -INT_MIN 可能会溢出。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> nn = n;</span><br><span class="line">        <span class="keyword">if</span>(nn &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nn = -nn;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nn%<span class="number">2</span>) ans *= x;</span><br><span class="line">            x = x*x;</span><br><span class="line">            nn /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span>/x</span><br><span class="line">            n = -n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">                ans *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans     </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 51. N-Queens</title>
    <url>/2020/11/30/051.%20N-Queens/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The <code>n</code>-queens puzzle is the problem of placing <code>n</code> queens on an <code>n</code>×<code>n</code> chessboard such that no two queens attack each other.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="img"></p>
<p>Given an integer <code>n</code>, return all distinct solutions to the <code>n</code>-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the <code>n</code>-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space respectively.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p><code>n</code> 皇后问题研究的是如何将 <code>n</code> 个皇后放置在 <code>n</code>×<code>n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 <code>n</code>，返回所有不同的 <code>n</code> 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 <code>n</code> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs。</p>
<p>$dfs(ans,now,ys,n)$ 表示当前状态为 $now$，每一行的皇后所在的列号储存在 $ys$ 中。</p>
<p>每一层 dfs 只需加入一个皇后，即每一行仅一个皇后。</p>
<p>判断每行的位置是否有效时，需要判断与之前行的皇后是否会在列或斜线冲突。</p>
<p>时间复杂度 $O(n!)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">now</span><span class="params">(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ys;</span><br><span class="line">        dfs(ans,now,ys,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ys,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ys.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>;y &lt; n;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> xx = <span class="number">0</span>;xx &lt; ys.size();xx++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> yy = ys[xx];</span><br><span class="line">                <span class="keyword">if</span>(!ok(ys.size(),y,xx,yy))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)	<span class="keyword">continue</span>;</span><br><span class="line">            now[ys.size()][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            ys.push_back(y);</span><br><span class="line">            dfs(ans,now,ys,n);</span><br><span class="line">            ys.pop_back();</span><br><span class="line">            now[ys.size()][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> xx,<span class="keyword">int</span> yy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == yy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x-xx == <span class="built_in">abs</span>(y-yy))   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,ys,n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ys) == n:</span><br><span class="line">            ans.append([<span class="string">&#x27;.&#x27;</span>*y+<span class="string">&#x27;Q&#x27;</span>+<span class="string">&#x27;.&#x27;</span>*(n-y-<span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> ys])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> xx,yy <span class="keyword">in</span> <span class="built_in">enumerate</span>(ys):</span><br><span class="line">                <span class="keyword">if</span>(self.ok(<span class="built_in">len</span>(ys),y,xx,yy) == <span class="number">0</span>):</span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(ans,ys+[y],n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self,x,y,xx,yy</span>):</span></span><br><span class="line">        <span class="keyword">if</span> y == yy:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x-xx == <span class="built_in">abs</span>(y-yy):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 52. N-Queens II</title>
    <url>/2020/11/30/052.%20N-Queens%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The <code>n</code>-queens puzzle is the problem of placing <code>n</code> queens on an <code>n</code>×<code>n</code> chessboard such that no two queens attack each other.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="img"></p>
<p>Given an integer <code>n</code>, return the number of distinct solutions to the <code>n</code>-queens puzzle.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p><code>n</code> 皇后问题研究的是如何将 <code>n</code> 个皇后放置在 <code>n</code>×<code>n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 <code>n</code>，返回 <code>n</code> 皇后不同的解决方案的数量。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>与上一题相同。</p>
<p>时间复杂度 $O(n!)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ys;</span><br><span class="line">        dfs(ans,ys,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ys,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ys.size() == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>;y &lt; n;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> xx = <span class="number">0</span>;xx &lt; ys.size();xx++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> yy = ys[xx];</span><br><span class="line">                <span class="keyword">if</span>(!ok(ys.size(),y,xx,yy))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)	<span class="keyword">continue</span>;</span><br><span class="line">            ys.push_back(y);</span><br><span class="line">            dfs(ans,ys,n);</span><br><span class="line">            ys.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> xx,<span class="keyword">int</span> yy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == yy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x-xx == <span class="built_in">abs</span>(y-yy))   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(ans)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,ys,n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ys) == n:</span><br><span class="line">            ans.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> xx,yy <span class="keyword">in</span> <span class="built_in">enumerate</span>(ys):</span><br><span class="line">                <span class="keyword">if</span>(self.ok(<span class="built_in">len</span>(ys),y,xx,yy) == <span class="number">0</span>):</span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(ans,ys+[y],n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self,x,y,xx,yy</span>):</span></span><br><span class="line">        <span class="keyword">if</span> y == yy:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x-xx == <span class="built_in">abs</span>(y-yy):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 53. Maximum Subarray</title>
    <url>/2020/11/30/053.%20Maximum%20Subarray/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the $O(n)$ solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最大子串和。</p>
<p>遍历数组，维护一个当前连续串和 $now$。</p>
<p>① 当 $now &lt; 0$ 时，抛弃当前的串，重新开始一个新的串。</p>
<p>② 当 $now \geq 0$ 时，继续使用当前地串，并加入下一个数。</p>
<p>在这个过程中，取 $now$ 的最大值为最终答案。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN,now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            now += nums[i];</span><br><span class="line">            ans = max(ans,now);</span><br><span class="line">            now = max(now,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = -<span class="number">1e20</span></span><br><span class="line">        now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            now += num</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,now)</span><br><span class="line">            now = <span class="built_in">max</span>(now,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Divide and Conquer</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 54. Spiral Matrix</title>
    <url>/2020/11/30/054.%20Spiral%20Matrix/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a matrix of <code>m</code> x <code>n</code> elements (<code>m</code> rows, <code>n</code> columns), return all elements of the matrix in spiral order.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>Given a matrix of <code>m</code> x <code>n</code> elements (<code>m</code> rows, <code>n</code> columns), return all elements of the matrix in spiral order.</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>环形遍历，遍历到边缘转换方向即可。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(),n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> ok[m][n];</span><br><span class="line">        <span class="built_in">memset</span>(ok,<span class="number">0</span>,<span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">0</span>;_ &lt; m*n;_++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(matrix[i][j]);</span><br><span class="line">            ok[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ii = i+dx[now],jj = j+dy[now];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= ii &amp;&amp; ii &lt; m &amp;&amp; <span class="number">0</span> &lt;= jj &amp;&amp; jj &lt; n &amp;&amp; !ok[ii][jj])</span><br><span class="line">            &#123;</span><br><span class="line">                i = ii;</span><br><span class="line">                j = jj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                now = (now+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                i += dx[now];</span><br><span class="line">                j += dy[now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        dx = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">        dy = [<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        m,n = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        ok = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        ans = []</span><br><span class="line">        now,i,j = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n*m):</span><br><span class="line">            ans.append(matrix[i][j])</span><br><span class="line">            ok[i][j] = <span class="number">1</span></span><br><span class="line">            ii,jj = i+dx[now],j+dy[now]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= ii &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= jj &lt; n <span class="keyword">and</span> ok[ii][jj] == <span class="number">0</span>:</span><br><span class="line">                i,j = ii,jj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = (now+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                i = i+dx[now]</span><br><span class="line">                j = j+dy[now]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">                </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 55. Jump Game</title>
    <url>/2020/11/30/055.%20Jump%20Game/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>贪心，遍历数组，维护当前可达的最大位置 $maxx$。</p>
<p>若在过程中出现 $maxx &lt; i$，则肯定不可达最后的元素。</p>
<p>否则判断最后的 $maxx$ 是否大于数组长度。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxx &lt; i)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            maxx = max(maxx,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx &gt;= nums.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">bool</span> canJump(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; nums.size()-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxx &lt; i)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx &gt;= nums.size()-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 56. Merge Intervals</title>
    <url>/2020/11/30/056.%20Merge%20Intervals/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a collection of intervals, merge all overlapping intervals.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>按照左边界排序。</p>
<p>遍历数组，若相邻两个元素间无间隙，则合并。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(intervals.begin(),intervals.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> now:intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.empty() || ans.back()[<span class="number">1</span>] &lt; now[<span class="number">0</span>])   ans.push_back(now);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans.back()[<span class="number">1</span>] &lt; now[<span class="number">1</span>])    ans.back()[<span class="number">1</span>] = now[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> now <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span> <span class="keyword">or</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; now[<span class="number">0</span>]:</span><br><span class="line">                ans.append(now)</span><br><span class="line">            <span class="keyword">elif</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; now[<span class="number">1</span>]:</span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = now[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 57. Insert Interval</title>
    <url>/2020/11/30/057.%20Insert%20Interval/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a set of <strong>non-overlapping</strong> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出一个 <strong>无重叠的</strong>，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历数组，找到与新插入段之有重叠的所有段，合并即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>]) ans.push_back(intervals[i++]);</span><br><span class="line">        ans.push_back(newInterval);       </span><br><span class="line">        <span class="keyword">if</span>(i &lt; intervals.size() &amp;&amp; ans.back()[<span class="number">0</span>] &gt; intervals[i][<span class="number">0</span>]) ans.back()[<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size() &amp;&amp; ans.back()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; ans.back()[<span class="number">1</span>] &lt; intervals[i<span class="number">-1</span>][<span class="number">1</span>])  ans.back()[<span class="number">1</span>] = intervals[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.size()) ans.push_back(intervals[i++]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]], newInterval: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>]:</span><br><span class="line">            ans.append(intervals[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans.append(newInterval)</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> ans[-<span class="number">1</span>][<span class="number">0</span>] &gt; intervals[i][<span class="number">0</span>]:</span><br><span class="line">            ans[-<span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            ans[-<span class="number">1</span>][<span class="number">1</span>] = intervals[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        ans.extend(intervals[i:])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58. Length of Last Word</title>
    <url>/2020/11/30/058.%20Length%20of%20Last%20Word/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明</strong>：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>统计最后一个单词的长度，注意多余的空格。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>)    i++;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)    i++,ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.strip().split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 59. Spiral Matrix II</title>
    <url>/2020/11/30/059.%20Spiral%20Matrix%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a positive integer <code>n</code>, generate a square matrix filled with elements from 1 to $n^2$ in spiral order.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个正整数 <code>n</code>，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>环形遍历赋值，遍历到边缘转换方向即可。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>,now = <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">0</span>;_ &lt; n*n;_++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][j] = ++cnt;</span><br><span class="line">            <span class="keyword">int</span> ii = i+dx[now],jj = j+dy[now];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= ii &amp;&amp; ii &lt; n &amp;&amp; <span class="number">0</span> &lt;= jj &amp;&amp; jj &lt; n &amp;&amp; !ans[ii][jj])</span><br><span class="line">            &#123;</span><br><span class="line">                i = ii;</span><br><span class="line">                j = jj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                now = (now+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                i += dx[now];</span><br><span class="line">                j += dy[now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        dx = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">        dy = [<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        ans = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        cnt,now,i,j = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n*n):</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            ans[i][j] = cnt</span><br><span class="line">            ii,jj = i+dx[now],j+dy[now]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= ii &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= jj &lt; n <span class="keyword">and</span> ans[ii][jj] == <span class="number">0</span>:</span><br><span class="line">                i,j = ii,jj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = (now+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">                i = i+dx[now]</span><br><span class="line">                j = j+dy[now]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">                </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 60. Permutation Sequence</title>
    <url>/2020/11/30/060.%20Permutation%20Sequence/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The set <code>[1,2,3,...,n]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <code>n</code> and <code>k</code>, return the <code>k</code>th permutation sequence.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Given <code>n</code> will be between 1 and 9 inclusive.</li>
<li>Given <code>k</code> will be between 1 and <code>n!</code> inclusive.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 <code>n!</code>种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>
<ol>
<li><p><code>&quot;123&quot;</code></p>
</li>
<li><p><code>&quot;132&quot;</code></p>
</li>
<li><p><code>&quot;213&quot;</code></p>
</li>
<li><p><code>&quot;231&quot;</code></p>
</li>
<li><p><code>&quot;312&quot;</code></p>
</li>
<li><p><code>&quot;321&quot;</code></p>
</li>
</ol>
<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>
<p>说明：</p>
<ul>
<li>给定 <code>n</code> 的范围是 <code>[1, 9]</code>。</li>
<li>给定 <code>k</code> 的范围是 <code>[1, n!]</code>。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>计算每个位置所对应的权重。</p>
<p>从高位到低位确定每个位置取第几个数字。</p>
<p>时间复杂度小于 $O(n!)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x[n] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)	x[i] = x[i<span class="number">-1</span>]*i;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; choose;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)   choose.push_back(i+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k/x[i];</span><br><span class="line">            ans.append(<span class="number">1</span>,choose[t]);</span><br><span class="line">            choose.erase(choose.begin()+t);</span><br><span class="line">            k %= x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        x = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            x.append(x[-<span class="number">1</span>]*i)</span><br><span class="line">        choose = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            t = k//x[i]</span><br><span class="line">            ans.append(<span class="built_in">str</span>(choose[t]))</span><br><span class="line">            choose.remove(choose[t])</span><br><span class="line">            k %= x[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 61. Rotate List</title>
    <url>/2020/11/30/061.%20Rotate%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list, rotate the list to the right by <code>k</code> places, where <code>k</code> is non-negative.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先遍历一遍链表，确定链表长度和尾节点。</p>
<p>令 $k = k\%n$，处理冗余的操作。</p>
<p>将尾节点连到首节点。</p>
<p>找到翻转的节点，将该节点后续置为空。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode *back = head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(back-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)  <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p = head,*lastp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lastp = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastp-&gt;next = <span class="number">0</span>;</span><br><span class="line">        back-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        back = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> back.<span class="built_in">next</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            back = back.<span class="built_in">next</span></span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-k):</span><br><span class="line">            lastp = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        lastp.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        back.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 62. Unique Paths</title>
    <url>/2020/11/30/062.%20Unique%20Paths/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>Above is a 7 x 3 grid. How many possible unique paths are there?</p>
<p><strong>Note:</strong> <code>m</code> and <code>n</code> will be at most 100.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：<code>m</code> 和 <code>n</code> 的值均不超过 100。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：动态规划"><a href="#一：动态规划" class="headerlink" title="一：动态规划"></a>一：动态规划</h2><p>$dp[i][j]$ 表示达到 $i,j$ 位置的方案数。</p>
<p>考虑转移情况 $dp[i][j] = dp[i-1][j]+dp[i][j-1]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h2 id="二：组合数"><a href="#二：组合数" class="headerlink" title="二：组合数"></a>二：组合数</h2><p>一种走 $n+m-2$ 步，确定其中往下走的 $n-1$ 步所在位置。</p>
<p>一共有 $C(n+m-2,n-1)$ 种方案。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)   dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans *= <span class="number">1.0</span>*(n+m<span class="number">-1</span>-i);</span><br><span class="line">            ans /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(ans+<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m,n+m-<span class="number">1</span>):</span><br><span class="line">            ans *= i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            ans //= i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 63. Unique Paths II</title>
    <url>/2020/11/30/063.%20Unique%20Paths%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p><strong>Note:</strong> <code>m</code> and <code>n</code> will be at most 100.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p>说明：<code>m</code> 和 <code>n</code> 的值均不超过 100。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i][j]$ 表示达到 $i,j$ 位置的方案数。</p>
<p>考虑以下两种转移情况：</p>
<p>① $Grid[i][j] = 1$，$dp[i][j] = 0$。</p>
<p>② $Grid[i][j] = 0$，$dp[i][j] = dp[i-1][j]+dp[i][j-1]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.size(),m = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(obstacleGrid),<span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 64. Minimum Path Sum</title>
    <url>/2020/11/30/064.%20Minimum%20Path%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <code>m x n</code> grid filled with non-negative numbers, find a path from top left to bottom right which <strong>minimizes</strong> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个包含非负整数的 <code>m x n</code> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i][j]$ 表示达到 $i,j$ 位置所的最小和。</p>
<p>考虑转移情况 $dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(),m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)   dp[i][<span class="number">0</span>] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++)   dp[<span class="number">0</span>][i] = INT_MAX;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)   dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1e18</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1e18</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+grid[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 65. Valid Number</title>
    <url>/2020/11/30/065.%20Valid%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Validate if a given string can be interpreted as a decimal number.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>验证给定的字符串是否可以解释为十进制数字。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;0&quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot; 0.1 &quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot;abc&quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;1 a&quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;2e10&quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot; -90e3   &quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot; 1e&quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;e3&quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot; 6e-1&quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot; 99e2.5 &quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;53.5e93&quot;&#96; &#x3D;&gt; &#96;true&#96;</span><br><span class="line">&#96;&quot; --6 &quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;-+3&quot;&#96; &#x3D;&gt; &#96;false&#96;</span><br><span class="line">&#96;&quot;95a54e53&quot;&#96; &#x3D;&gt; &#96;false</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</p>
<ul>
<li>Numbers <code>0-9</code></li>
<li>Exponent <code>&quot;e&quot;</code></li>
<li>Positive/negative sign <code>&quot;+&quot;</code>/<code>&quot;-&quot;</code></li>
<li>Decimal point <code>&quot;.&quot;</code></li>
</ul>
<p>Of course, the context of these characters also matters in the input.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，忽略首尾得多余空格。</p>
<p>若第一个字符为符号位，也忽略。</p>
<p>遍历字符串，维护以下三种状态：</p>
<p>$okdigit$：是否有数字。</p>
<p>$okdot$：是否有小数点。</p>
<p>$oke$：是否有e。</p>
<p>考虑以下几种转移情况：</p>
<p>① $s[i] = digit$，</p>
<p>$okdigit \rightarrow okdigit = 1$。</p>
<p>② $s[i] = ‘e’$，</p>
<p>$oke = 1 \rightarrow$ 非法；</p>
<p>$okdigit = 0 \rightarrow$ 非法；</p>
<p>$oke,okdigit \rightarrow oke = 1,okdigit = 0$。</p>
<p>③ $s[i] = ‘.’$，</p>
<p>$oke = 1 \rightarrow$ 非法；</p>
<p>$okdot = 1\rightarrow$ 非法；</p>
<p>$okdot \rightarrow okdot = 1$。</p>
<p>④ $s[i] = ‘-‘$ 或 $s[i] = ‘+’$ ，</p>
<p>$s[i-1] \neq e\rightarrow$  非法。</p>
<p>最终仅有以下三种情况合法：</p>
<p>① $okdigit = 1,okdot = 0,oke = 0$。</p>
<p>② $okdigit = 1,okdot = 1,oke = 0$。</p>
<p>③ $okdigit = 1,okdot = 0,oke = 0$。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; s.length() &amp;&amp; s[l] == <span class="string">&#x27; &#x27;</span>)	l++;</span><br><span class="line">        <span class="keyword">if</span>(s[l] == <span class="string">&#x27;-&#x27;</span> || s[l] == <span class="string">&#x27;+&#x27;</span>)	l++;</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">0</span> &amp;&amp; s[r] == <span class="string">&#x27; &#x27;</span>)	r--;</span><br><span class="line">       	<span class="keyword">int</span> okdigit = <span class="number">0</span>,okdot = <span class="number">0</span>,oke = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))	okdigit = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(oke || !okdigit)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    oke = <span class="number">1</span>;</span><br><span class="line">                    okdigit = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(oke || okdot)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>	okdot = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>] != <span class="string">&#x27;e&#x27;</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> okdigit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			s = <span class="built_in">float</span>(s)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 66. Plus One</title>
    <url>/2020/11/30/066.%20Plus%20One/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储 <strong>单个</strong> 数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>末尾加1，考虑进位。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>,i = digits.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] == <span class="number">9</span>)    digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t)   digits.insert(digits.begin(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        t = <span class="number">1</span></span><br><span class="line">        i = <span class="built_in">len</span>(digits)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> t <span class="keyword">and</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> digits[i] == <span class="number">9</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                t = <span class="number">0</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> t:</span><br><span class="line">            digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 67. Add Binary</title>
    <url>/2020/11/30/067.%20Add%20Binary/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟二进制加法。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> now1 = a.length()<span class="number">-1</span>,now2 = b.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now1 &gt;= <span class="number">0</span> || now2 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="keyword">if</span>(now1 &gt;= <span class="number">0</span> &amp;&amp; now2 &gt;= <span class="number">0</span>)  t = a[now1--]-<span class="string">&#x27;0&#x27;</span>+b[now2--]-<span class="string">&#x27;0&#x27;</span>+cf;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now1 &gt;= <span class="number">0</span>)  t = a[now1--]-<span class="string">&#x27;0&#x27;</span>+cf;</span><br><span class="line">            <span class="keyword">else</span>    t = b[now2--]-<span class="string">&#x27;0&#x27;</span>+cf;</span><br><span class="line">            cf = t/<span class="number">2</span>;</span><br><span class="line">            ans.append(<span class="number">1</span>,t%<span class="number">2</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cf)  ans.append(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        reverse(ans.begin(),ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(<span class="built_in">int</span>(a,<span class="number">2</span>)+<span class="built_in">int</span>(b,<span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 68. Text Justification</title>
    <url>/2020/11/30/068.%20Text%20Justification/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of words and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no <strong>extra</strong> space is inserted between words.</p>
<p><strong>Note:</strong></p>
<ul>
<li>A word is defined as a character sequence consisting of non-space characters only.</li>
<li>Each word’s length is guaranteed to be greater than 0 and not exceed <code>maxWidth</code>.</li>
<li>The input array <code>words</code> contains at least one word.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个单词数组和一个长度 <code>maxWidth</code>，重新排版单词，使其成为每行恰好有 <code>maxWidth</code> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <code>maxWidth</code> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入 <strong>额外的</strong> 空格。</p>
<p>说明:</p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <code>maxWidth</code>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth &#x3D; 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth &#x3D; 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;,</span><br><span class="line">             because the last line must be left-justified instead of fully-justified.</span><br><span class="line">             Note that the second line is also left-justified becase it contains only one word.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth &#x3D; 20</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先确定每行的单词，再确定单词间的空格数。</p>
<p>注意只有一个单词的情况。</p>
<p>最后处理最后一行。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fullJustify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans,now;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len+words[i].size()+now.size() &gt; maxWidth)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> s = now[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(now.size() == <span class="number">1</span>) s.append(maxWidth-len,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = (maxWidth-len)/(now.size()<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> left = (maxWidth-len)%(now.size()<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; now.size();i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s.append(cnt,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(i &lt;= left)   s.append(<span class="number">1</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                        s.append(now[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(s);</span><br><span class="line">                now.clear();</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now.push_back(words[i]);</span><br><span class="line">            len += words[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = now[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; now.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.append(<span class="number">1</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            s.append(now[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(maxWidth-s.length(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        ans.push_back(s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words: List[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        ans,now = [],[]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> l+<span class="built_in">len</span>(now)+<span class="built_in">len</span>(word) &gt; maxWidth:</span><br><span class="line">                s = [now[<span class="number">0</span>]]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(now) == <span class="number">1</span>:</span><br><span class="line">                    s.append(<span class="string">&#x27; &#x27;</span>*(maxWidth-l))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt = (maxWidth-l)//(<span class="built_in">len</span>(now)-<span class="number">1</span>)</span><br><span class="line">                    left = (maxWidth-l)%(<span class="built_in">len</span>(now)-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(now)):</span><br><span class="line">                        s.append(<span class="string">&#x27; &#x27;</span>*cnt)</span><br><span class="line">                        <span class="keyword">if</span> i &lt;= left:</span><br><span class="line">                            s.append(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                        s.append(now[i])</span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(s))</span><br><span class="line">                now.clear()</span><br><span class="line">                l = <span class="number">0</span></span><br><span class="line">            now.append(word)</span><br><span class="line">            l += <span class="built_in">len</span>(word)</span><br><span class="line">        s = [now[<span class="number">0</span>]]+[<span class="string">&#x27; &#x27;</span>+w <span class="keyword">for</span> w <span class="keyword">in</span> now[<span class="number">1</span>:]]+[<span class="string">&#x27; &#x27;</span>*(maxWidth-(l+<span class="built_in">len</span>(now)-<span class="number">1</span>))]</span><br><span class="line">        ans.append(<span class="string">&#x27;&#x27;</span>.join(s))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 69. Sqrt(x)</title>
    <url>/2020/11/30/069.%20Sqrt(x)/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <code>x</code>, where <code>x</code> is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分，找到使得 $i^2 \leq x$ 成立的最大的 $i$。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)x)    l = mid;</span><br><span class="line">            <span class="keyword">else</span>    r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,x</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &lt;= x:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70. Climbing Stairs</title>
    <url>/2020/11/30/070.%20Climbing%20Stairs/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are climbing a stair case. It takes <code>n</code> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <code>n</code> will be a positive integer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <code>n</code> 是一个正整数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i]$ 表示到达 $i$ 阶梯的方案数。</p>
<p>$dp[i] = dp[i-2]+dp[i-1]$。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)   dp[i] = dp[i<span class="number">-2</span>]+dp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>,<span class="number">1</span>]+[<span class="number">0</span>]*(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">2</span>]+dp[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 71. Simplify Path</title>
    <url>/2020/11/30/071.%20Simplify%20Path/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p>
<p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level. For more information, see: <a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/">Absolute path vs relative path in Linux/Unix</a></p>
<p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>以 Unix 风格给出一个文件的 <strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/">Linux / Unix中的绝对路径 vs 相对路径</a></p>
<p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong> 以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的 <strong>最短</strong> 字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">Output: &quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将原字符串以反斜杠划分。</p>
<p>从根目录起，按照划分后的每个子串更新目录。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.append(<span class="number">1</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">1</span>,now;</span><br><span class="line">        <span class="keyword">while</span>((now = path.find(<span class="string">&#x27;/&#x27;</span>,last)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = path.substr(last,now-last);</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;..&quot;</span> &amp;&amp; !ans.empty())   ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s != <span class="string">&quot;..&quot;</span> &amp;&amp; s != <span class="string">&quot;.&quot;</span> &amp;&amp; s != <span class="string">&quot;&quot;</span>)   ans.push_back(s);</span><br><span class="line">            last = now+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> each:ans)</span><br><span class="line">        &#123;</span><br><span class="line">            s.append(<span class="number">1</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            s.append(each);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())   s.append(<span class="number">1</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> path.split(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&#x27;..&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.pop()</span><br><span class="line">            <span class="keyword">elif</span> s != <span class="string">&#x27;..&#x27;</span> <span class="keyword">and</span> s != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                ans.append(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span>+<span class="string">&#x27;/&#x27;</span>.join(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72. Edit Distance</title>
    <url>/2020/11/30/072.%20Edit%20Distance/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two words <code>word1</code> and <code>word2</code>, find the minimum number of operations required to convert <code>word1</code> to <code>word2</code>.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个单词 <code>word1</code> 和 <code>word2</code>，计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i][j]$ 表示达到当前位置最少的操作次数。</p>
<p>考虑以下四种转移方式：</p>
<p>① $word1[i-1] = word2[j-1]$，则 $dp[i-1][j-1] \rightarrow dp[i][j]$。</p>
<p>② $word1[i-1] \neq word2[j-1]$，则 $dp[i-1][j-1]+1 \rightarrow dp[i][j]$。</p>
<p>③ $dp[i][j-1]+1 \rightarrow dp[i][j]$。</p>
<p>④ $dp[i-1][j]+1 \rightarrow dp[i][j]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(),m = word2.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)   dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++)   dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] != word2[j<span class="number">-1</span>])    dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span>    dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(word1),<span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 73. Set Matrix Zeroes</title>
    <url>/2020/11/30/073.%20Set%20Matrix%20Zeroes/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <code>m x n</code> matrix, if an element is 0, set its entire row and column to 0. Do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>算法<strong>。</strong></p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>A straight forward solution using O(<code>m * n</code>) space is probably a bad idea.</li>
<li>A simple improvement uses O(<code>m + n</code>) space, but still not the best solution.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不使用额外空间。</p>
<p>首先记录第一行和第一列是否有 0。</p>
<p>然后对于其它位置，将其有 0 的位置投影到第一行和第一列。</p>
<p>随后清除需要清除的行和列。</p>
<p>最后处理第一行和第一列的情况。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(),m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> hasn = <span class="number">0</span>,hasm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!matrix[i][<span class="number">0</span>])    </span><br><span class="line">            &#123;</span><br><span class="line">                hasn = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!matrix[<span class="number">0</span>][j])</span><br><span class="line">            &#123;</span><br><span class="line">                hasm = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>])    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j])    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasm)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        hasn = <span class="number">0</span> <span class="keyword">in</span> matrix[<span class="number">0</span>]</span><br><span class="line">        hasm = <span class="number">0</span> <span class="keyword">in</span> [each[<span class="number">0</span>] <span class="keyword">for</span> each <span class="keyword">in</span> matrix]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> hasn:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> hasm:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 74. Search a 2D Matrix</title>
    <url>/2020/11/30/074.%20Search%20a%202D%20Matrix/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，二分找所在行，即使得 $matrix[i][0] \leq target$ 成立的最大的 $i$。</p>
<p>然后，二分找所在列，即使得 $matrix[i][j] &lt; target$ 成立的最小的 $j$。 </p>
<p>时间复杂度 $O(lognlogm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(),m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &lt;= target)    l = mid;</span><br><span class="line">            <span class="keyword">else</span>    r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[l][<span class="number">0</span>] &gt; target)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = l;</span><br><span class="line">        l = <span class="number">0</span>,r = m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[t][mid] &lt; target)    l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l != m &amp;&amp; matrix[t][l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        l,r = <span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt;= target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">        t,l,r = l,<span class="number">0</span>,m</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[t][mid] &lt; target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l &lt; m <span class="keyword">and</span> matrix[t][l] == target</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 75. Sort Colors</title>
    <url>/2020/11/30/075.%20Sort%20Colors/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array with <code>n</code> objects colored red, white or blue, sort them <strong>in-place</strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个包含红色、白色和蓝色，一共 ·n· 个元素的数组，<strong>原地</strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意</strong>：不能使用代码库中的排序函数来解决这道题。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先遍历数组，将 0 交换到前面。</p>
<p>然后，从上次 0 之后开始，遍历数组将 1 交换到前面。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = now;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)    swap(nums[i],nums[now++]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = now;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)    swap(nums[i],nums[now++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[now],nums[i] = nums[i],nums[now]</span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(now,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[now],nums[i] = nums[i],nums[now]</span><br><span class="line">                now += <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76. Minimum Window Substring</title>
    <url>/2020/11/30/076.%20Minimum%20Window%20Substring/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>S</code> and a string <code>T</code>, find the minimum window in <code>S</code> which will contain all the characters in <code>T</code> in complexity $O(n)$.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串 <code>S</code>、一个字符串 <code>T</code>，请在字符串 <code>S</code> 里面找出：包含 <code>T</code> 所有字母的最小子串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>If there is no such window in <code>S</code> that covers all characters in <code>T</code>, return the empty string <code>&quot;&quot;</code>.</li>
<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in <code>S</code>.</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>双指针，右指针遍历数组。</p>
<p>当区间内的字母符合要求时，更新左指针位置，使区间长度最小。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,cnt = t.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t)   mp[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>;r &lt; s.length();r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--mp[s[r]] &gt;= <span class="number">0</span>)    cnt--;</span><br><span class="line">            <span class="keyword">if</span>(!cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(mp[s[l]] &lt; <span class="number">0</span>) mp[s[l++]]++;</span><br><span class="line">                <span class="keyword">if</span>(ans.empty() || r+<span class="number">1</span>-l &lt; ans.size())   ans = s.substr(l,r+<span class="number">1</span>-l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        l,cnt = <span class="number">0</span>,<span class="built_in">len</span>(t)</span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            mp[c] = mp.get(c,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            mp[s[r]] = mp.get(s[r],<span class="number">0</span>)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mp[s[r]] &gt;= <span class="number">0</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> mp[s[l]] &lt; <span class="number">0</span>:</span><br><span class="line">                    mp[s[l]] += <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span> <span class="keyword">or</span> r+<span class="number">1</span>-l &lt; <span class="built_in">len</span>(ans):</span><br><span class="line">                    ans = s[l:r+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 77. Combinations</title>
    <url>/2020/11/30/077.%20Combinations/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k</code> numbers out of <code>1 ... n</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs。</p>
<p>$dfs(ans,now,n,pos,left)$ 表示当前数组为 $now$，已经到 $pos$ 位置，剩余数字 $left$ 个的状态。</p>
<p>时间复杂度 $O(C_n^k)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">        dfs(ans,now,n,<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="keyword">int</span> n,<span class="keyword">int</span> pos,<span class="keyword">int</span> left)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            now.push_back(i);</span><br><span class="line">            dfs(ans,now,n,i+<span class="number">1</span>,left<span class="number">-1</span>);</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],n,<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,n,pos,left</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">            ans.append(now)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos,n+<span class="number">1</span>):</span><br><span class="line">            self.dfs(ans,now+[i],n,i+<span class="number">1</span>,left-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 78. Subsets</title>
    <url>/2020/11/30/078.%20Subsets/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a set of <strong>distinct</strong> integers, <code>nums</code>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一组 <strong>不含重复元素</strong> 的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，求全组合。</p>
<p>$dfs(ans,now,n,pos)$ 表示当前数组为 $now$，已经到 $pos$ 位置的状态。</p>
<p>过程中存储每一状态的结果。</p>
<p>时间复杂度 $O(n!)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">        dfs(ans,now,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            now.push_back(nums[i]);</span><br><span class="line">            dfs(ans,now,nums,i+<span class="number">1</span>);</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,nums</span>):</span></span><br><span class="line">        ans.append(now)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.dfs(ans,now+[nums[i]],nums[i+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 79. Word Search</title>
    <url>/2020/11/30/079.%20Word%20Search/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word &#x3D; &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;SEE&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从每个符合的起点开始dfs。</p>
<p>$dfs(board,vis,n,m,i,j,word,now)$ 表示当前位置为 $i,j$ 且在单词的 $now$ 位置的状态。</p>
<p>注意回溯的时候清除标记。</p>
<p>时间复杂度 $O(nm\mathbb{len}(word))$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(),m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != word[<span class="number">0</span>])  <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,vis,n,m,i,j,word,<span class="number">1</span>))   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">string</span> word,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == word.length())    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vis[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; <span class="number">4</span>;t++)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> ii = i+dx[t],jj = j+dy[t];</span><br><span class="line">            <span class="keyword">if</span>(ii &lt; <span class="number">0</span> || ii &gt;= n || jj &lt; <span class="number">0</span> || jj &gt;= m)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[ii][jj] || board[ii][jj] != word[now])   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,vis,n,m,ii,jj,word,now+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(board),<span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        vis = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> self.dfs(board,vis,n,m,i,j,word[<span class="number">1</span>:]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,board,vis,n,m,i,j,word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dx = [<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        dy = [-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        vis[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            ii,jj = i+dx[_],j+dy[_]</span><br><span class="line">            <span class="keyword">if</span> ii &lt; <span class="number">0</span> <span class="keyword">or</span> ii == n <span class="keyword">or</span> jj &lt; <span class="number">0</span> <span class="keyword">or</span> jj == m:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> vis[ii][jj] <span class="keyword">or</span> board[ii][jj] != word[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs(board,vis,n,m,ii,jj,word[<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        vis[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 80. Remove Duplicates from Sorted Array II</title>
    <url>/2020/11/30/080.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a sorted array <code>nums</code>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <strong>twice</strong> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with $O(1)$ extra memory.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个排序数组，你需要在<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地</a>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 $O(1)$ 额外空间的条件下完成。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历数组，记录当前位置的前两个数。</p>
<p>将与前两个数均相同的数忽略，其余数字重新覆盖数组。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>,prepre = <span class="number">-1e9</span>,pre = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prepre != pre || pre != nums[i])   nums[now++] = nums[i];</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        now = <span class="number">0</span></span><br><span class="line">        prepre,pre = <span class="number">0.1</span>,<span class="number">0.1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> prepre != pre <span class="keyword">or</span> pre != num:</span><br><span class="line">                nums[now] = num</span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">            prepre,pre = pre,num</span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 81. Search in Rotated Sorted Array II</title>
    <url>/2020/11/30/081.%20Search%20in%20Rotated%20Sorted%20Array%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>
<li>Would this affect the run-time complexity? How and why?</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>与 33 题相似，但此题元素可重复。</p>
<p>由于起始段元素与尾元素可能相同，这使得二分找扭转位置难以实现。</p>
<p>首先，判断起始元素是否为 $target$，将起始位置移到下一个不同数字的位置。</p>
<p>之后的做法，与 33 题相同。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == target)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.size() &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])    i++;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.size())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = i,r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums.back()) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; target &lt;= nums.back())  r = nums.size();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = l;</span><br><span class="line">            l = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(nums.begin()+l,nums.begin()+r,target)-nums.begin();</span><br><span class="line">        <span class="keyword">return</span> pos &lt; r &amp;&amp; nums[pos] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l,r = i,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[-<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[l] &lt;= target &lt;= nums[-<span class="number">1</span>]:</span><br><span class="line">            l,r = l,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l,r = i,l</span><br><span class="line">        rr = r</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l &lt; rr <span class="keyword">and</span> nums[l] == target</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 82. Remove Duplicates from Sorted List II</title>
    <url>/2020/11/30/082.%20Remove%20Duplicates%20from%20Sorted%20List%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <strong>distinct</strong> numbers from the original list.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>删去连续重复元素的节点。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *now = ans;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next &amp;&amp; now-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = now-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;val == p-&gt;next-&gt;val)	p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;next == p)	now = p;</span><br><span class="line">            <span class="keyword">else</span>	now-&gt;next = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        now = ans</span><br><span class="line">        <span class="keyword">while</span> now.<span class="built_in">next</span> <span class="keyword">and</span> now.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            p = now.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.val == p.<span class="built_in">next</span>.val:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> now.<span class="built_in">next</span> == p:</span><br><span class="line">                now = p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 83. Remove Duplicates from Sorted List</title>
    <url>/2020/11/30/083.%20Remove%20Duplicates%20from%20Sorted%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a sorted linked list, delete all duplicates such that each element appear only <strong>once</strong>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将与上一个节点元素相同的节点删去。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *now = head;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;val == now-&gt;next-&gt;val)  now-&gt;next = now-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>    now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        now = head</span><br><span class="line">        <span class="keyword">while</span> now.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> now.val == now.<span class="built_in">next</span>.val:</span><br><span class="line">                now.<span class="built_in">next</span> = now.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 84. Largest Rectangle in Histogram</title>
    <url>/2020/11/30/084.%20Largest%20Rectangle%20in%20Histogram/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>n</code> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" alt="img"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历数组，维护一个高度递增的单调栈。</p>
<p>每当有元素 pop 时，计算其高度对应的最大宽度，并更新答案。</p>
<p>注意在数组最后加个 0，使得最后清空栈。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(&#123;<span class="number">-1</span>&#125;)</span></span>;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heights.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.size() &gt; <span class="number">1</span> &amp;&amp; heights[s.top()] &gt; heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                ans = max(ans,h*(i-s.top()<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        s = [-<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">len</span>(s) &gt; <span class="number">0</span> <span class="keyword">and</span> heights[s[-<span class="number">1</span>]] &gt; heights[i]):</span><br><span class="line">                h = heights[s[-<span class="number">1</span>]]</span><br><span class="line">                s.pop()</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,h*(i-s[-<span class="number">1</span>]-<span class="number">1</span>))</span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 85. Maximal Rectangle</title>
    <url>/2020/11/30/085.%20Maximal%20Rectangle/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>统计每行的列连续累计值，分别在每行用单调栈求最大矩阵面积。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(),m = matrix[<span class="number">0</span>].size();    </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(&#123;<span class="number">-1</span>&#125;)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m)   heights[j] = matrix[i][j]-<span class="string">&#x27;0&#x27;</span>?heights[j]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(s.size() &gt; <span class="number">1</span> &amp;&amp; heights[s.top()] &gt; heights[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">                    s.pop();</span><br><span class="line">                    ans = max(ans,h*(j-s.top()<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span>(<span class="params">self, matrix: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n,m = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    heights[j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j] = <span class="number">0</span></span><br><span class="line">            s = [-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">len</span>(s) &gt; <span class="number">0</span> <span class="keyword">and</span> heights[s[-<span class="number">1</span>]] &gt; heights[j]):</span><br><span class="line">                    h = heights[s[-<span class="number">1</span>]]</span><br><span class="line">                    s.pop()</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,h*(j-s[-<span class="number">1</span>]-<span class="number">1</span>))</span><br><span class="line">                s.append(j)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Dynamic Programming</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 86. Partition List</title>
    <url>/2020/11/30/086.%20Partition%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list and a value <code>x</code>, partition it such that all nodes less than <code>x</code> come before nodes greater than or equal to <code>x</code>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表和一个特定值 <code>x</code>，对链表进行分隔，使得所有小于 <code>x</code> 的节点都在大于或等于 <code>x</code> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将原链表分成两条链表，最后串在一起</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*ans2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = ans1,*q = ans2,*now = head;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(now-&gt;val);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                q-&gt;next = <span class="keyword">new</span> ListNode(now-&gt;val);</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = ans2-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> ans1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        ans1,ans2 = ListNode(<span class="number">0</span>),ListNode(<span class="number">0</span>)</span><br><span class="line">        now,p,q = head,ans1,ans2</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            <span class="keyword">if</span> now.val &lt; x:</span><br><span class="line">                p.<span class="built_in">next</span> = ListNode(now.val)</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.<span class="built_in">next</span> = ListNode(now.val)</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = ans2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 87. Scramble String</title>
    <url>/2020/11/30/087.%20Scramble%20String/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s1</code>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of <code>s1 = &quot;great&quot;</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    great</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  gr    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure>
<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    tae</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       &#x2F; \</span><br><span class="line">      t   a</span><br></pre></td></tr></table></figure>
<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Given two strings <code>s1</code> and <code>s2</code> of the same length, determine if <code>s2</code> is a scrambled string of <code>s1</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 <code>s1</code>，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p>
<p>下图是字符串 <code>s1 = &quot;great&quot;</code> 的一种可能的表示形式。</p>
<pre><code>    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</code></pre><p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p>
<p>例如，如果我们挑选非叶节点 <code>&quot;gr&quot;</code>，交换它的两个子节点，将会产生扰乱字符串 <code>&quot;rgeat&quot;</code>。</p>
<pre><code>    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</code></pre><p>我们将 <code>&quot;rgeat”</code> 称作 <code>&quot;great&quot;</code> 的一个扰乱字符串。</p>
<p>同样地，如果我们继续交换节点 <code>&quot;eat&quot;</code> 和 <code>&quot;at&quot;</code> 的子节点，将会产生另一个新的扰乱字符串 <code>&quot;rgtae&quot;</code>。</p>
<pre><code>    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</code></pre><p>我们将 <code>&quot;rgtae”</code> 称作 <code>&quot;great&quot;</code> 的一个扰乱字符串。</p>
<p>给出两个长度相等的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;great&quot;, s2 &#x3D; &quot;rgeat&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abcde&quot;, s2 &#x3D; &quot;caebd&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归判断，每次判断两种情况。</p>
<p>过程中增加字母数量统计以剪枝。</p>
<p>时间复杂度 $O(n^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == s2)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            cnt[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>,i),s2.substr(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substr(i),s2.substr(i)))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>,i),s2.substr(len-i)) &amp;&amp; isScramble(s1.substr(i),s2.substr(<span class="number">0</span>,len-i)))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cnt = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">            cnt[<span class="built_in">ord</span>(s1[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            cnt[<span class="built_in">ord</span>(s2[i])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> cnt[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s1)):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i],s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:],s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i],s2[<span class="built_in">len</span>(s1)-i:]) <span class="keyword">and</span> self.isScramble(s1[i:],s2[:<span class="built_in">len</span>(s1)-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88. Merge Sorted Array</title>
    <url>/2020/11/30/088.%20Merge%20Sorted%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two sorted integer arrays <code>nums1</code> and <code>nums2</code>, merge <code>nums2</code> into <code>nums1</code> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <code>nums1</code> and <code>nums2</code> are <code>m</code> and <code>n</code> respectively.</li>
<li>You may assume that <code>nums1</code> has enough space (size that is greater or equal to <code>m + n</code>) to hold additional elements from <code>nums2</code>.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，将 <code>nums2</code> 合并到 <code>nums1</code> 中，使得 <code>num1</code> 成为一个有序数组。</p>
<p>说明:</p>
<ul>
<li>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code>。</li>
<li>你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 <code>m + n</code>）来保存 <code>nums2</code> 中的元素。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>合并两有序序列，从后往前放。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = n+m<span class="number">-1</span>,now1 = m<span class="number">-1</span>,now2 = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(now1 &gt;= <span class="number">0</span> &amp;&amp; now2 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[now1] &lt; nums2[now2])   nums1[now--] = nums2[now2--];</span><br><span class="line">            <span class="keyword">else</span>    nums1[now--] = nums1[now1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now2 &gt;= <span class="number">0</span>)    nums1[now--] = nums2[now2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        now,now1,now2 = m+n-<span class="number">1</span>,m-<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> now1 &gt;= <span class="number">0</span> <span class="keyword">and</span> now2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[now1] &gt; nums2[now2]:</span><br><span class="line">                nums1[now] = nums1[now1]</span><br><span class="line">                now1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[now] = nums2[now2]</span><br><span class="line">                now2 -= <span class="number">1</span></span><br><span class="line">            now -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> now2 &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[now] = nums2[now2]</span><br><span class="line">            now2 -= <span class="number">1</span></span><br><span class="line">            now -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 89. Gray Code</title>
    <url>/2020/11/30/089.%20Gray%20Code/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer <code>n</code> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 <code>n</code>，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">For a given n, a gray code sequence may not be uniquely defined.</span><br><span class="line">For example, [0,2,3,1] is also a valid gray code sequence.</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: [0]</span><br><span class="line">Explanation: We define the gray code sequence to begin with 0.</span><br><span class="line">             Therefore, for n &#x3D; 0 the gray code sequence is [0].</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>格雷码生成规则。</p>
<p>二进制的形式下，每增加一位编码，则新增一倍的编码最高位填1，后面为之前编码逆序的序列。</p>
<p>时间复杂度  $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = ans.size()<span class="number">-1</span>;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(now+ans[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            now *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        now = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> ans[::-<span class="number">1</span>]:</span><br><span class="line">                ans.append(now+each)</span><br><span class="line">            now *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 90. Subsets II</title>
    <url>/2020/11/30/090.%20Subsets%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a collection of integers that might contain duplicates, <code>nums</code>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，与 78 题类似。</p>
<p>增加了排序和去重的过程。</p>
<p>时间复杂度 $O(n!)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        dfs(ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; pos &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br><span class="line">            now.push_back(nums[i]);</span><br><span class="line">            dfs(ans,now,nums,i+<span class="number">1</span>);</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,[],nums)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,nums</span>):</span></span><br><span class="line">        ans.append(now)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(ans,now+[nums[i]],nums[i+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 91. Decode Ways</title>
    <url>/2020/11/30/091.%20Decode%20Ways/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>给定一个只包含数字的 <strong>非空</strong> 字符串，请计算解码方法的总数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i]$ 表示到 $i$ 位置为止的编码数量。</p>
<p>考虑以下四种情况：</p>
<p>① 若 $s[i-1]s[i]$ 符合编码且 $s[i] \neq0$，则 $dp[i] = dp[i-2]+dp[i-1]$。</p>
<p>② 若 $s[i-1]s[i]$ 符合编码且 $s[i] =0$，则 $dp[i] = dp[i-2]$。</p>
<p>③ 若 $s[i-1]s[i]$ 不符编码且 $s[i] \neq0$，则 $dp[i] = dp[i-1]$。</p>
<p>④ 若 $s[i-1]s[i]$ 不符编码且 $s[i] =0$，则无法编码。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[s.length()] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;6&#x27;</span>)	</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>)	dp[i] += dp[i<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span>	dp[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span>)	dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!dp[i])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>]+[<span class="number">0</span>]*(<span class="built_in">len</span>(s)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> dp[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 92. Reverse Linked List II</title>
    <url>/2020/11/30/092.%20Reverse%20Linked%20List%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Reverse a linked list from position <code>m</code> to <code>n</code>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <code>m</code> ≤ <code>n</code> ≤ length of list.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>反转从位置 <code>m</code> 到 <code>n</code> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <code>m</code> ≤ <code>n</code> ≤ 链表长度。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先遍历链表至需要反转的起始位置。</p>
<p>然后反转链表至需要反转的终止位置。</p>
<p>最终将三段连接即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *now = ans;</span><br><span class="line">        <span class="keyword">int</span> len = n-m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(--m)  now = now-&gt;next;</span><br><span class="line">        ListNode *p = now,*pre = now,*ne;</span><br><span class="line">        now = now-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">        &#123;</span><br><span class="line">            ne = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = ne;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next-&gt;next = now;</span><br><span class="line">        p-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        ans = ListNode(<span class="number">0</span>)</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        now = ans</span><br><span class="line">        l = n-m+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>):</span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        p,pre = now,now</span><br><span class="line">        now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            ne = now.<span class="built_in">next</span></span><br><span class="line">            now.<span class="built_in">next</span> = pre</span><br><span class="line">            pre,now = now,ne</span><br><span class="line">        p.<span class="built_in">next</span>.<span class="built_in">next</span> = now</span><br><span class="line">        p.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 93. Restore IP Addresses</title>
    <url>/2020/11/30/093.%20Restore%20IP%20Addresses/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，储存符合条件的IP。</p>
<p>$dfs(ans,s,now,cnt)$ 表示当前串为 $now$，剩余字符为 $s$，已加入数的个数为 $cnt$ 的状态。</p>
<p>时间复杂度 $O(C_n^4)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        dfs(ans,<span class="string">&quot;&quot;</span>,s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans,<span class="built_in">string</span> now,<span class="built_in">string</span> s,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span> &amp;&amp; s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span> || s.empty())	<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; sum == <span class="number">0</span> || i &gt; <span class="number">2</span>)	<span class="keyword">break</span>;</span><br><span class="line">            sum = sum*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">255</span>)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt) now.append(<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            dfs(ans,now+s.substr(<span class="number">0</span>,i+<span class="number">1</span>),s.substr(i+<span class="number">1</span>),cnt+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cnt) now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,<span class="string">&#x27;&#x27;</span>,s,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now,s,cnt</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">and</span> cnt == <span class="number">4</span>:</span><br><span class="line">            ans.append(now)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> cnt == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            d = <span class="built_in">int</span>(s[:i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> i &gt; <span class="number">2</span> <span class="keyword">or</span> d &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cnt:</span><br><span class="line">                self.dfs(ans,now+<span class="string">&#x27;.&#x27;</span>+s[:i+<span class="number">1</span>],s[i+<span class="number">1</span>:],cnt+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.dfs(ans,now+s[:i+<span class="number">1</span>],s[i+<span class="number">1</span>:],cnt+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 94. Binary Tree Inorder Traversal</title>
    <url>/2020/11/30/094.%20Binary%20Tree%20Inorder%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, return the <strong>inorder</strong> traversal of its nodes’ values.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回它的 <strong>中序</strong> 遍历。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二叉树的中序遍历。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        dfs(ans,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans,TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(ans,now-&gt;left);</span><br><span class="line">        ans.push_back(now-&gt;val);</span><br><span class="line">        dfs(ans,now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(ans,root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,ans,now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(ans,now.left)</span><br><span class="line">        ans.append(now.val)</span><br><span class="line">        self.dfs(ans,now.right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 95. Unique Binary Search Trees II</title>
    <url>/2020/11/30/095.%20Unique%20Binary%20Search%20Trees%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>n</code>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values <code>1 ... n</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数 <code>n</code>，生成所有由 <code>1 ... n</code> 为节点所组成的 <strong>二叉搜索树</strong>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，每次选一个中节点，保存左右节点所有的可能。</p>
<p>时间复杂度 $O(n^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)   <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;(&#123;<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ls:dfs(l,i<span class="number">-1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rs:dfs(i+<span class="number">1</span>,r))</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *now = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    now-&gt;left = ls;</span><br><span class="line">                    now-&gt;right = rs;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    ans.push_back(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">1</span>,n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,l,r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l,r+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> lson <span class="keyword">in</span> self.dfs(l,i-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> rson <span class="keyword">in</span> self.dfs(i+<span class="number">1</span>,r):</span><br><span class="line">                    now = TreeNode(i)</span><br><span class="line">                    now.left = lson</span><br><span class="line">                    now.right = rson</span><br><span class="line">                    ans.append(now)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 96. Unique Binary Search Trees</title>
    <url>/2020/11/30/096.%20Unique%20Binary%20Search%20Trees/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>n</code>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values <code>1 ... n</code>?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数 <code>n</code>，求以 <code>1 ... n</code> 为节点组成的二叉搜索树有多少种？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i]$ 表示连续 $i$ 个数字所对应的子树的数量。</p>
<p>$dp[i] = \sum_{j = 1}^{i}dp[j-1]*dp[i-j]$。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)   dp[i] += dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>,<span class="number">1</span>]+[<span class="number">0</span>]*(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 97. Interleaving String</title>
    <url>/2020/11/30/097.%20Interleaving%20String/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>s1</code>, <code>s2</code>, <code>s3</code>, find whether <code>s3</code> is formed by the interleaving of <code>s1</code> and <code>s2</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定三个字符串 <code>s1</code>, <code>s2</code>, <code>s3</code>, 验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> 交错组成的。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，$dp[i][j]$ 表示 $s1$ 到 $i-1$ 位置，$s2$ 到 $j-1$ 位置，$s3$ 到 $i+j-1$ 位置时，是否匹配。</p>
<p>考虑以下两种转移情况：</p>
<p>① $s1[i-1] == s3[i+j-1]$ 时，$dp[i-1][j] \rightarrow dp[i][j]$。</p>
<p>② $s2[j-1] == s3[i+j-1]$ 时，$dp[i][j-1] \rightarrow dp[i][j]$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length()+s2.length() != s3.length())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> dp[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s1.length();i++)	dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s2.length();j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s2.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] |= dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j] |= dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1)+<span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s1)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]&amp;(s1[i-<span class="number">1</span>] == s3[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s2)+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>]&amp;(s2[j-<span class="number">1</span>] == s3[j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s2)+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] |= dp[i-<span class="number">1</span>][j]&amp;(s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>])</span><br><span class="line">                dp[i][j] |= dp[i][j-<span class="number">1</span>]&amp;(s2[j-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s1)][<span class="built_in">len</span>(s2)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 98. Validate Binary Search Tree</title>
    <url>/2020/11/30/098.%20Validate%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，给定左右区间，递归判断子树是否符合。</p>
<p>$dfs(now,l,r)$ 表示当前节点为 $now$，左右边界为 $l,r$ 的情况。 </p>
<p>时间复杂度  $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">-1e10</span>,<span class="number">1e10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *now,<span class="keyword">long</span> <span class="keyword">long</span> l,<span class="keyword">long</span> <span class="keyword">long</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= now-&gt;val || now-&gt;val &gt;= r)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(now-&gt;left,l,now-&gt;val) &amp;&amp; dfs(now-&gt;right,now-&gt;val,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root,-<span class="number">1e10</span>,<span class="number">1e10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,now,l,r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l &lt; now.val &lt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(now.left,l,now.val) <span class="keyword">and</span> self.dfs(now.right,now.val,r)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Recursion</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 99. Recover Binary Search Tree</title>
    <url>/2020/11/30/099.%20Recover%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>A solution using $O(n)$ space is pretty straight forward.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs 中序遍历，找出两个出错的节点。</p>
<p>将两个节点的值交换。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="keyword">new</span> TreeNode(INT_MIN),*p,*q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        swap(p-&gt;val,q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val &gt; now-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p) </span><br><span class="line">            &#123;</span><br><span class="line">                p = pre;</span><br><span class="line">                q = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    q = now;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = now;</span><br><span class="line">        dfs(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">global</span> pre,p,q</span><br><span class="line">        pre,p,q = TreeNode(-<span class="number">1e10</span>),<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">now</span>):</span></span><br><span class="line">            <span class="keyword">global</span> pre,p,q</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            print(pre)</span><br><span class="line">            dfs(now.left)</span><br><span class="line">            <span class="keyword">if</span> pre.val &gt; now.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                    p,q = pre,now</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    q = now</span><br><span class="line">            pre = now</span><br><span class="line">            dfs(now.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        p.val,q.val = q.val,p.val</span><br><span class="line">            </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100. Same Tree</title>
    <url>/2020/11/30/100.%20Same%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归判断两颗树是否相同。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q || p-&gt;val != q-&gt;val)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q <span class="keyword">or</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101. Symmetric Tree</title>
    <url>/2020/11/30/101.%20Symmetric%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归判断树是否镜像对称对称。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *l,TreeNode *r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l || !r || l-&gt;val != r-&gt;val)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(l-&gt;left,r-&gt;right) || !dfs(l-&gt;right,r-&gt;left))    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root.left,root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,l,r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r <span class="keyword">or</span> l.val != r.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(l.left,r.right) <span class="keyword">or</span> <span class="keyword">not</span> self.dfs(l.right,r.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102. Binary Tree Level Order Traversal</title>
    <url>/2020/11/30/102.%20Binary%20Tree%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, return the <strong>level order</strong> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回其按层次遍历的节点值。（即逐层地，从左到右访问所有节点）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>bfs，记录每层的数量以分层。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                now.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)    q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">                t = q.get()</span><br><span class="line">                now.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left:</span><br><span class="line">                    q.put(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right:</span><br><span class="line">                    q.put(t.right)</span><br><span class="line">            ans.append(now)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 103. Binary Tree Zigzag Level Order Traversal</title>
    <url>/2021/04/26/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>bfs，记录每层的数量以分层，并在偶数层反转一下数组。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                now.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)    q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d++%<span class="number">2</span> == <span class="number">0</span>)  reverse(now.begin(), now.end());  </span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(root)</span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">                t = q.get()</span><br><span class="line">                now.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left:</span><br><span class="line">                    q.put(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right:</span><br><span class="line">                    q.put(t.right)</span><br><span class="line">            <span class="keyword">if</span> d%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                now = now[::-<span class="number">1</span>]</span><br><span class="line">            d += <span class="number">1</span></span><br><span class="line">            ans.append(now)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104. Maximum Depth of Binary Tree</title>
    <url>/2021/04/26/104.%20Maximum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归，每层深度加1。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Recursion</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/04/26/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归建树，在中序遍历中找前序遍历的第一个元素，即为当前子树的根。</p>
<p>中序遍历根的左边为左子树所有元素，右边为右子树所有元素。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *now = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">        <span class="keyword">int</span> mid = l2;</span><br><span class="line">        <span class="keyword">while</span>(preorder[l1] != inorder[mid]) mid++;</span><br><span class="line">        now-&gt;left = build(preorder, l1+<span class="number">1</span>, l1+mid-l2, inorder, l2, mid<span class="number">-1</span>);</span><br><span class="line">        now-&gt;right = build(preorder, l1+mid-l2+<span class="number">1</span>, r1, inorder, mid+<span class="number">1</span>, r2);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, preorder, l1, r1, inorder, l2, r2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l1 &gt; r1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        now = TreeNode(preorder[l1])</span><br><span class="line">        mid = l2</span><br><span class="line">        <span class="keyword">while</span> preorder[l1] != inorder[mid]:</span><br><span class="line">            mid += <span class="number">1</span></span><br><span class="line">        now.left = self.build(preorder, l1+<span class="number">1</span>, l1+mid-l2, inorder, l2, mid-<span class="number">1</span>)</span><br><span class="line">        now.right = self.build(preorder, l1+mid-l2+<span class="number">1</span>, r1, inorder, mid+<span class="number">1</span>, r2)</span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder)-<span class="number">1</span>, inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/2021/04/26/106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: inorder &#x3D; [-1], postorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归建树，在中序遍历中找后序遍历的最后一个元素，即为当前子树的根。</p>
<p>中序遍历根的左边为左子树所有元素，右边为右子树所有元素。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *now = <span class="keyword">new</span> TreeNode(postorder[r2]);</span><br><span class="line">        <span class="keyword">int</span> mid = l1;</span><br><span class="line">        <span class="keyword">while</span>(inorder[mid] != postorder[r2])    mid++;</span><br><span class="line">        now-&gt;left = build(inorder, l1, mid<span class="number">-1</span>, postorder, l2, r2-(r1-mid)<span class="number">-1</span>);</span><br><span class="line">        now-&gt;right = build(inorder, mid+<span class="number">1</span>, r1, postorder, r2-(r1-mid), r2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, postorder, <span class="number">0</span>, postorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, inorder, l1, r1, postorder, l2, r2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l1 &gt; r1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        now = TreeNode(postorder[r2])</span><br><span class="line">        mid = l1</span><br><span class="line">        <span class="keyword">while</span> inorder[mid] != postorder[r2]:</span><br><span class="line">            mid += <span class="number">1</span></span><br><span class="line">        now.left = self.build(inorder, l1, mid-<span class="number">1</span>, postorder, l2, r2-(r1-mid)-<span class="number">1</span>)</span><br><span class="line">        now.right = self.build(inorder, mid+<span class="number">1</span>, r1, postorder, r2-(r1-mid), r2-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.build(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder)-<span class="number">1</span>, postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 107. Binary Tree Level Order Traversal IIInorder and Postorder Traversal</title>
    <url>/2021/04/26/107.%20Binary%20Tree%20Level%20Order%20Traversal%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level from leaf to root).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 102. Binary Tree Level Order Traversal 的基础上，将层反转。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                now.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)    q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">                t = q.get()</span><br><span class="line">                now.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left:</span><br><span class="line">                    q.put(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right:</span><br><span class="line">                    q.put(t.right)</span><br><span class="line">            ans.append(now)</span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2021/04/26/108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,3] and [3,1] are both a height-balanced BSTs.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归建树，每次取中点作为当前子树的根。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *now =  <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        now-&gt;left = build(nums, l, mid<span class="number">-1</span>);</span><br><span class="line">        now-&gt;right = build(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (l+r)//<span class="number">2</span></span><br><span class="line">        now = TreeNode(nums[mid])</span><br><span class="line">        now.left = self.build(nums, l, mid-<span class="number">1</span>)</span><br><span class="line">        now.right = self.build(nums, mid+<span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.build(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 109. Convert Sorted List to Binary Search Tree</title>
    <url>/2021/04/26/109.%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a singly linked list where elements are <strong>sorted in ascending order</strong>, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：转化成数组"><a href="#一：转化成数组" class="headerlink" title="一：转化成数组"></a>一：转化成数组</h2><p>将链表转化成数组。</p>
<p>然后参照 LeetCode 108. Convert Sorted Array to Binary。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：直接链表构造"><a href="#二：直接链表构造" class="headerlink" title="二：直接链表构造"></a>二：直接链表构造</h2><p>每次使用快慢指针找链表的中点，递归建树。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *now =  <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        now-&gt;left = build(nums, l, mid<span class="number">-1</span>);</span><br><span class="line">        now-&gt;right = build(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        ListNode *pre = <span class="number">0</span>, *l1 = head, *l2 = head;</span><br><span class="line">        <span class="keyword">while</span>(l2 &amp;&amp; l2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="number">0</span>;</span><br><span class="line">        TreeNode *now = <span class="keyword">new</span> TreeNode(l1-&gt;val);</span><br><span class="line">        now-&gt;left = sortedListToBST(head);</span><br><span class="line">        now-&gt;right = sortedListToBST(l1-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (l+r)//<span class="number">2</span></span><br><span class="line">        now = TreeNode(nums[mid])</span><br><span class="line">        now.left = self.build(nums, l, mid-<span class="number">1</span>)</span><br><span class="line">        now.right = self.build(nums, mid+<span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.build(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(head.val)</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = head</span><br><span class="line">        <span class="keyword">while</span> l2 <span class="keyword">and</span> l2.<span class="built_in">next</span>:</span><br><span class="line">            pre = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        now = TreeNode(l1.val)</span><br><span class="line">        now.left = self.sortedListToBST(head)</span><br><span class="line">        now.right = self.sortedListToBST(l1.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 110. Balanced Binary TreeSearch Tree</title>
    <url>/2021/04/26/110.%20Balanced%20Binary%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归返回子树的高度，并在过程中同时判断子树是否满足平衡二叉树，若不满足，则直接返回-1。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = height(now-&gt;left), r = height(now-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span> || r == <span class="number">-1</span> || <span class="built_in">abs</span>(l-r) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(l, r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.depth(now.left)</span><br><span class="line">        r = self.depth(now.right)</span><br><span class="line">        <span class="keyword">if</span> l == -<span class="number">1</span> <span class="keyword">or</span> r == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(l-r) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.depth(root) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Recursion</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111. Minimum Depth of Binary Tree</title>
    <url>/2021/04/26/111.%20Minimum%20Depth%20of%20Binary%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>为了处理根为空的情况，故将空的子树高度返回0，因此在递归计算最小高度的时候，需要考虑左右节点是否为空。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; r)  <span class="keyword">return</span> min(l, r)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l+r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.minDepth(root.left)</span><br><span class="line">        r = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(l, r)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l+r+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 112. Path Sum</title>
    <url>/2021/04/26/112.%20Path%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>计算根到每个叶子节点的和即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(TreeNode* now, <span class="keyword">int</span> sum, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum += now-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!now-&gt;left &amp;&amp; !now-&gt;right)   <span class="keyword">return</span> sum == targetSum;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left &amp;&amp; ok(now-&gt;left, sum, targetSum))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right &amp;&amp; ok(now-&gt;right, sum, targetSum))    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ok(root, <span class="number">0</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self, now, <span class="built_in">sum</span>, targetSum</span>):</span></span><br><span class="line">        <span class="built_in">sum</span> += now.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now.left <span class="keyword">and</span> <span class="keyword">not</span> now.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span> == targetSum</span><br><span class="line">        <span class="keyword">if</span> now.left <span class="keyword">and</span> self.ok(now.left, <span class="built_in">sum</span>, targetSum):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> now.right <span class="keyword">and</span> self.ok(now.right, <span class="built_in">sum</span>, targetSum):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.ok(root, <span class="number">0</span>, targetSum)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 113. Path Sum II</title>
    <url>/2021/04/26/113.%20Path%20Sum%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return all <strong>root-to-leaf</strong> paths where each path’s sum equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>计算根到每个叶子节点的和，保存所有可能的路径。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* now, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> sum, <span class="keyword">int</span> targetSum, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.push_back(now-&gt;val);</span><br><span class="line">        sum += now-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!now-&gt;left &amp;&amp; !now-&gt;right &amp;&amp; sum == targetSum)   ans.push_back(nums);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left)   dfs(now-&gt;left, nums, sum, targetSum, ans);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right)  dfs(now-&gt;right, nums, sum, targetSum, ans);</span><br><span class="line">        nums.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> targetSum) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">        dfs(root, now, <span class="number">0</span>, targetSum, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, nums, <span class="built_in">sum</span>, targetSum, ans</span>):</span></span><br><span class="line">        nums.append(now.val)</span><br><span class="line">        <span class="built_in">sum</span> += now.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now.left <span class="keyword">and</span> <span class="keyword">not</span> now.right <span class="keyword">and</span> <span class="built_in">sum</span> == targetSum:</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">        <span class="keyword">if</span> now.left:</span><br><span class="line">            self.dfs(now.left, nums, <span class="built_in">sum</span>, targetSum, ans)</span><br><span class="line">        <span class="keyword">if</span> now.right:</span><br><span class="line">            self.dfs(now.right, nums, <span class="built_in">sum</span>, targetSum, ans)</span><br><span class="line">        nums.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, [], <span class="number">0</span>, targetSum, ans)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 114. Flatten Binary Tree to Linked List</title>
    <url>/2021/04/26/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, flatten the tree into a “linked list”:</p>
<ul>
<li>The “linked list” should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>
<li>The “linked list” should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"><strong>pre-order</strong> <strong>traversal</strong></a> of the binary tree.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：子树展开"><a href="#一：子树展开" class="headerlink" title="一：子树展开"></a>一：子树展开</h2><p>从叶子向根展开每一颗子树，在每个子树，将左右子节依次挂在右边。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h2 id="二：找前驱节点"><a href="#二：找前驱节点" class="headerlink" title="二：找前驱节点"></a>二：找前驱节点</h2><p>从根往下，不断将当前节点的右子树挂到左子树的最右端，将左子树挂到当前节点的右端，并不断向右子树移动。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        TreeNode *l = root-&gt;left, *r = root-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="number">0</span>;</span><br><span class="line">        root-&gt;right = l;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;right)  root = root-&gt;right;</span><br><span class="line">        root-&gt;right = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *l = root-&gt;left;</span><br><span class="line">                TreeNode *t = l;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;right) t = t-&gt;right;</span><br><span class="line">                t-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;left = <span class="number">0</span>;</span><br><span class="line">                root-&gt;right = l;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        l = root.left</span><br><span class="line">        r = root.right</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = l</span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        root.right = r</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                l = root.left</span><br><span class="line">                t = l</span><br><span class="line">                <span class="keyword">while</span> t.right:</span><br><span class="line">                    t = t.right</span><br><span class="line">                t.right = root.right</span><br><span class="line">                root.left = <span class="literal">None</span></span><br><span class="line">                root.right = l</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 115. Distinct Subsequences</title>
    <url>/2021/04/26/115.%20Distinct%20Subsequences/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code> which equals <code>t</code></em>.</p>
<p>A string’s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>It is guaranteed the answer fits on a 32-bit signed integer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dp[i] 表示到字符串 $t$ 的第 i 个位置的方案总数。</p>
<p>将初始可行方案置位1，扫一遍字符串 $s$，更新 dp 数组。</p>
<p>若 $s$ 的当前字符与 $t$ 的 i 位置字符相等，则 dp[i] += dp[i-1]。</p>
<p>由于节省空间使用了一维数组，故更新 dp 数组需要从后往前扫。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dp[<span class="number">1005</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(t.length()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t.length(); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == t[i])	dp[i+<span class="number">1</span>] += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(<span class="built_in">len</span>(t)+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> c == t[i]:</span><br><span class="line">                    dp[i+<span class="number">1</span>] += dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(t)]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 116. Populating Next Right Pointers in Each Node</title>
    <url>/2021/04/26/116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<p><strong>进阶</strong>：</p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：层次遍历"><a href="#一：层次遍历" class="headerlink" title="一：层次遍历"></a>一：层次遍历</h2><p>在 LeetCode 102. Binary Tree Level Order Traversal 的基础上，加上 next 指针的指向。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：递归赋值"><a href="#二：递归赋值" class="headerlink" title="二：递归赋值"></a>二：递归赋值</h2><p>自顶向下，不断改变左右两节点的 next 指向。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(len) t-&gt;next = q.front();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)    q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root &amp;&amp; root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next)  root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">            connect(root-&gt;left);</span><br><span class="line">            connect(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q):</span><br><span class="line">            qq = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(q)-<span class="number">1</span>:</span><br><span class="line">                    q[i].<span class="built_in">next</span> = q[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> q[i].left:</span><br><span class="line">                    qq.append(q[i].left)</span><br><span class="line">                <span class="keyword">if</span> q[i].right:</span><br><span class="line">                    qq.append(q[i].right)</span><br><span class="line">            q = qq</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left:</span><br><span class="line">            root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">            <span class="keyword">if</span> root.<span class="built_in">next</span>:</span><br><span class="line">                root.right.<span class="built_in">next</span> = root.<span class="built_in">next</span>.left</span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 117. Populating Next Right Pointers in Each Node II</title>
    <url>/2021/04/26/117.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<p><strong>进阶</strong>：</p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：层次遍历"><a href="#一：层次遍历" class="headerlink" title="一：层次遍历"></a>一：层次遍历</h2><p>在 LeetCode 102. Binary Tree Level Order Traversal 的基础上，加上 next 指针的指向。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：递归赋值"><a href="#二：递归赋值" class="headerlink" title="二：递归赋值"></a>二：递归赋值</h2><p>自顶向下，不断改变左右两节点的 next 指向。</p>
<p>在每一层记录下层的起始节点，并记录相邻两个节点，改变 next 指向。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(len) t-&gt;next = q.front();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)    q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node *now_root = root;</span><br><span class="line">        <span class="keyword">while</span>(now_root)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *now = now_root, *next_root = <span class="number">0</span>;</span><br><span class="line">            Node *last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!next_root)  next_root = now-&gt;left;</span><br><span class="line">                    <span class="keyword">if</span>(last)    last-&gt;next = now-&gt;left;</span><br><span class="line">                    last = now-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!next_root)  next_root = now-&gt;right;</span><br><span class="line">                    <span class="keyword">if</span>(last)    last-&gt;next = now-&gt;right;</span><br><span class="line">                    last = now-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                now = now-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now_root = next_root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q):</span><br><span class="line">            qq = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(q)-<span class="number">1</span>:</span><br><span class="line">                    q[i].<span class="built_in">next</span> = q[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> q[i].left:</span><br><span class="line">                    qq.append(q[i].left)</span><br><span class="line">                <span class="keyword">if</span> q[i].right:</span><br><span class="line">                    qq.append(q[i].right)</span><br><span class="line">            q = qq</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        now_root = root</span><br><span class="line">        <span class="keyword">while</span> now_root:</span><br><span class="line">            now = now_root</span><br><span class="line">            next_root = <span class="literal">None</span></span><br><span class="line">            last = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> now:</span><br><span class="line">                <span class="keyword">if</span> now.left:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> next_root:</span><br><span class="line">                        next_root = now.left</span><br><span class="line">                    <span class="keyword">if</span> last:</span><br><span class="line">                        last.<span class="built_in">next</span> = now.left</span><br><span class="line">                    last = now.left</span><br><span class="line">                <span class="keyword">if</span> now.right:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> next_root:</span><br><span class="line">                        next_root = now.right</span><br><span class="line">                    <span class="keyword">if</span> last:</span><br><span class="line">                        last.<span class="built_in">next</span> = now.right</span><br><span class="line">                    last = now.right</span><br><span class="line">                now = now.<span class="built_in">next</span></span><br><span class="line">            now_root = next_root</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118. Pascal&#39;s Triangle</title>
    <url>/2021/04/26/118.%20Pascal&#39;s%20Triangle/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numRows &#x3D; 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numRows &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>杨辉三角，一层一层加。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now&#123;<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ans.back().size(); j++)  now.push_back(ans.back()[j<span class="number">-1</span>]+ans.back()[j]);</span><br><span class="line">            now.push_back(<span class="number">1</span>);</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, numRows+<span class="number">1</span>):</span><br><span class="line">            now = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ans[-<span class="number">1</span>])):</span><br><span class="line">                now.append(ans[-<span class="number">1</span>][j-<span class="number">1</span>]+ans[-<span class="number">1</span>][j])</span><br><span class="line">            now.append(<span class="number">1</span>)</span><br><span class="line">            ans.append(now)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 119. Pascal&#39;s Triangle II</title>
    <url>/2021/04/26/119.%20Pascal&#39;s%20Triangle%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>rowIndex</code>, return the <code>rowIndexth</code> (<strong>0-indexed</strong>) row of the <strong>Pascal’s triangle</strong>.</p>
<p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: rowIndex &#x3D; 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: rowIndex &#x3D; 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: rowIndex &#x3D; 1</span><br><span class="line">Output: [1,1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 118. Pascal’s Triangle 基础上，优化空间。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">now</span><span class="params">(rowIndex+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt; <span class="number">0</span>; j--)    now[j] = now[j]+now[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        now = [<span class="number">1</span>]*(rowIndex+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rowIndex+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                now[j] = now[j-<span class="number">1</span>]+now[j]</span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 120. Triangle</title>
    <url>/2021/04/26/120.%20Triangle/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p>
<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The triangle looks like:</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">The minimum path sum from top to bottom is 2 + 3 + 5 + 1 &#x3D; 11 (underlined above).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: triangle &#x3D; [[-10]]</span><br><span class="line">Output: -10</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从上到下 dp，计算跟到每个点的最小开销。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            triangle[i].front() += triangle[i<span class="number">-1</span>].front();</span><br><span class="line">            triangle[i].back() += triangle[i<span class="number">-1</span>].back();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[i].size()<span class="number">-1</span>; j++)   triangle[i][j] += min(triangle[i<span class="number">-1</span>][j<span class="number">-1</span>], triangle[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle.back().size(); i++) ans = min(ans, triangle.back()[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(triangle)):</span><br><span class="line">            triangle[i][<span class="number">0</span>] += triangle[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">            triangle[i][-<span class="number">1</span>] += triangle[i-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(triangle[i])-<span class="number">1</span>):</span><br><span class="line">                triangle[i][j] += <span class="built_in">min</span>(triangle[i-<span class="number">1</span>][j-<span class="number">1</span>], triangle[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(triangle[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 121. Best Time to Buy and Sell Stock</title>
    <url>/2021/04/28/121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>扫一遍，更新最小值，并不断计算当前值与最小值的差。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minn = <span class="number">1e9</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:prices)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, x-minn);</span><br><span class="line">            minn = min(minn, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        minn = <span class="number">1e9</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prices:</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, x)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, x-minn)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
    <url>/2021/04/28/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e., max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>需要考虑不断低买高卖，在买和卖之间的两两差值的和等于卖和买的差值。</p>
<p>故可推得若相邻两股票，后者比前者贵，则肯定能赚到这部分的差价，仅需要将这部分相加即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) ans += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i-<span class="number">1</span>]:</span><br><span class="line">                ans += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 123. Best Time to Buy and Sell Stock III</title>
    <url>/2021/04/28/123.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>动态规划，buy1[i] 表示在前 i 天，第一次买股票的最大收益，sell1[i] 表示在前 i 天，第一次卖股票的最大收益，buy2[i] 表示在前 i 天，第二次买股票的最大收益，sell2[i] 表示在前 i 天，第二次卖股票的最大收益，则有：</p>
<ol>
<li>buy1[i] = max(buy1[i-1], prices[i])</li>
<li>sell1[i] = max(sell1[i-1], buy1[i-1]+prices[i])</li>
<li>buy2[i] = max(buy2[i-1], sell1[i-1]-prices[i])</li>
<li>sell2[i] = max(sell2[i-1], buy2[i-1]+prices[i])</li>
</ol>
<p>最终的答案为 max(sell1, sell2)。</p>
<p>上述过程可将 dp 的空间压缩。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:prices)</span><br><span class="line">        &#123;</span><br><span class="line">            sell2 = max(sell2, buy2+x);</span><br><span class="line">            buy2 = max(buy2, sell1-x);</span><br><span class="line">            sell1 = max(sell1, buy1+x);</span><br><span class="line">            buy1 = max(buy1, -x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(sell1, sell2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        buy1 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = <span class="number">0</span></span><br><span class="line">        buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prices:</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2+x)</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1-x)</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1+x)</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sell1, sell2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 124. Binary Tree Maximum Path Sum</title>
    <url>/2021/04/28/124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>
<p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p>
<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any path</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs，从叶子向上遍历每颗子树，每次考虑当前子树中的最长路径，并返回从叶子到当前子树的根节点的最长距离。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* now, <span class="keyword">int</span> &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = max(dfs(now-&gt;left, ans), <span class="number">0</span>), r = max(dfs(now-&gt;right, ans), <span class="number">0</span>);</span><br><span class="line">        ans = max(ans, l+r+now-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> max(l, r)+now-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = <span class="built_in">max</span>(self.dfs(now.left), <span class="number">0</span>)</span><br><span class="line">        r = <span class="built_in">max</span>(self.dfs(now.right), <span class="number">0</span>)</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, l+r+now.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)+now.val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = -<span class="number">1e9</span></span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Depth-first Search</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 125. Valid Palindrome</title>
    <url>/2021/04/28/125.%20Valid%20Palindrome/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code>, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从两边往中间扫，跳过不合理的字符，同时判断是否相等。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = s.length()<span class="number">-1</span>; l &lt; r; l++, r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l]))  l++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r]))  r--;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r &amp;&amp; <span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> <span class="keyword">not</span> s[l].isalnum():</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> <span class="keyword">not</span> s[r].isalnum():</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; r <span class="keyword">and</span> s[l].lower() != s[r].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 126. Word Ladder II</title>
    <url>/2021/04/28/126.%20Word%20Ladder%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p>
<ul>
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sk == endWord</code></li>
</ul>
<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words</em> <code>[beginWord, s1, s2, ..., sk]</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> 这样的单词序列，并满足：</p>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li><p>转换过程中的每个单词 <code>si</code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</p>
</li>
<li><p><code>sk == endWord</code></p>
</li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 <code>[beginWord, s1, s2, ..., sk]</code> 的形式返回。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</span><br><span class="line">Explanation: There are 2 shortest transformation sequences:</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 127. Word Ladder 的基础上，输出所有可行路径。</p>
<p>先按单词建边，然后 bfs 搜答案，保存有效节点的前驱节点。</p>
<p>对前驱节点去重后，dfs 搜所有路径。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[i])  nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums == s1.length()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *from, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordList, <span class="keyword">int</span> &amp;b, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == b)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(&#123;path.rbegin(), path.rend()&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:from[now])</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(wordList[i]);</span><br><span class="line">            dfs(i, path, from, wordList, b, ans);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = wordList.size(), b = n, e = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wordList[i] == endWord)  e = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(e == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        wordList.push_back(beginWord);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(connect(wordList[i], wordList[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    v[i].push_back(j);</span><br><span class="line">                    v[j].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(&#123;b&#125;)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vis[b] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inq;</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> now = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:v[now])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[i])  <span class="keyword">continue</span>;</span><br><span class="line">                    inq.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span>(i == e)  ok = <span class="number">1</span>;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                    from[i].push_back(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:inq) vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sort(from[i].begin(), from[i].end());</span><br><span class="line">            <span class="keyword">auto</span> new_end = unique(from[i].begin(), from[i].end());</span><br><span class="line">            from[i].erase(new_end, from[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path&#123;endWord&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        dfs(e, path, from, wordList, b, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        nums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">            <span class="keyword">if</span> s1[i] == s2[i]:</span><br><span class="line">                nums += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums == <span class="built_in">len</span>(s1)-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> now == self.b:</span><br><span class="line">            self.ans.append(path[::-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.froms[now]:</span><br><span class="line">            path.append(self.wordList[i])</span><br><span class="line">            self.dfs(i, path)</span><br><span class="line">            path.pop()</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(wordList)</span><br><span class="line">        self.b = n</span><br><span class="line">        self.e = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> wordList[i] == endWord:</span><br><span class="line">                self.e = i</span><br><span class="line">        <span class="keyword">if</span> self.e == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        wordList.append(beginWord)</span><br><span class="line">        v = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> self.connect(wordList[i], wordList[j]):</span><br><span class="line">                    v[i].append(j)</span><br><span class="line">                    v[j].append(i)</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(self.b)</span><br><span class="line">        vis = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        vis[self.b] = <span class="number">1</span></span><br><span class="line">        self.froms = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            ok = <span class="number">0</span></span><br><span class="line">            inq = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">                now = q.get()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> v[now]:</span><br><span class="line">                    <span class="keyword">if</span> vis[i]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    inq.append(i)</span><br><span class="line">                    <span class="keyword">if</span> i == e:</span><br><span class="line">                        ok = <span class="number">1</span></span><br><span class="line">                    q.put(i)</span><br><span class="line">                    self.froms[i].append(now)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> inq:</span><br><span class="line">                vis[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ok:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            self.froms[i] = <span class="built_in">list</span>(<span class="built_in">set</span>(self.froms[i]))</span><br><span class="line">        path = [endWord]</span><br><span class="line">        self.wordList = wordList</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(self.e, path)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 127. Word Ladder</title>
    <url>/2021/04/28/127.%20Word%20Ladder/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p>
<ul>
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sk == endWord</code></li>
</ul>
<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 <code>beginWord</code> 。</li>
<li>序列中最后一个单词是 <code>endWord</code> 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词。</li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 wordList ，找到从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>bfs，按单词是否可达建边，然后转变成求解最小步数。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; <span class="title">q</span><span class="params">(&#123;beginWord&#125;)</span></span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> now = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(vis.count(now))  <span class="keyword">continue</span>;</span><br><span class="line">                vis.insert(now);</span><br><span class="line">                <span class="keyword">if</span>(now == endWord)  <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; now.length(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> t = now;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)  </span><br><span class="line">                    &#123;</span><br><span class="line">                        t[i] = c;</span><br><span class="line">                        <span class="keyword">if</span>(wordSet.count(t))    q.push(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(beginWord)</span><br><span class="line">        vis = <span class="built_in">set</span>()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">                now = q.get()</span><br><span class="line">                <span class="keyword">if</span> now <span class="keyword">in</span> vis:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                vis.add(now)</span><br><span class="line">                <span class="keyword">if</span> now == endWord:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(now)):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                        t = now[:i]+<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+j)+now[i+<span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> t <span class="keyword">in</span> wordSet:</span><br><span class="line">                            q.put(t[:])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 128. Longest Consecutive Sequence</title>
    <url>/2021/04/28/128.%20Longest%20Consecutive%20Sequence/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>进阶</strong>：你可以设计并实现时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：排序贪心"><a href="#一：排序贪心" class="headerlink" title="一：排序贪心"></a>一：排序贪心</h2><p>排序去重后，扫一遍，找最长连续的数列。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h2 id="二：哈希表"><a href="#二：哈希表" class="headerlink" title="二：哈希表"></a>二：哈希表</h2><p>用哈希表记录每个元素是否存在。</p>
<p>遍历每个元素，当且仅当不存在比当前元素小 1 的元素，才不断向上找连续数量。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> size = unique(nums.begin(), nums.end())-nums.begin();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]+<span class="number">1</span> == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                now++;</span><br><span class="line">                ans = max(ans, now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    now = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(x<span class="number">-1</span>))    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.count(x++)) now++;</span><br><span class="line">            ans = max(ans, now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        now = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i-<span class="number">1</span>]+<span class="number">1</span> == nums[i]:</span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        s = <span class="built_in">set</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x-<span class="number">1</span> <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            now = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x <span class="keyword">in</span> s:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                now += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, now)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 129. Sum Root to Leaf Numbers</title>
    <url>/2021/04/28/129.%20Sum%20Root%20to%20Leaf%20Numbers/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>
<p>Each root-to-leaf path in the tree represents a number.</p>
<ul>
<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>
</ul>
<p>Return <em>the total sum of all root-to-leaf numbers</em>.</p>
<p>A <strong>leaf</strong> node is a node with no children.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [4,9,0,5,1]</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从根向下，极端当前节点的值，若当前节点无左右子节点，则累计当前值，否则继续向下传递值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *now, <span class="keyword">int</span> sum, <span class="keyword">int</span> &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum = sum*<span class="number">10</span>+now-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!now-&gt;left &amp;&amp; !now-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += sum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left)   dfs(now-&gt;left, sum, ans);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right)  dfs(now-&gt;right, sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, <span class="built_in">sum</span></span>):</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span>*<span class="number">10</span>+now.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now.left <span class="keyword">and</span> <span class="keyword">not</span> now.right:</span><br><span class="line">            self.ans += <span class="built_in">sum</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> now.left:</span><br><span class="line">            self.dfs(now.left, <span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">if</span> now.right:</span><br><span class="line">            self.dfs(now.right, <span class="built_in">sum</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 130. Surrounded Regions</title>
    <url>/2021/04/28/130.%20Surrounded%20Regions/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions surrounded by</em> <code>&#39;X&#39;</code>.</p>
<p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Surrounded regions should not be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;]]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从边缘一圈的 O 开始搜，保留所有与边缘 O 连通的 O，将其余位置全部置为 X。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>)    <span class="keyword">return</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x<span class="number">-1</span>, y);</span><br><span class="line">        dfs(board, x+<span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y<span class="number">-1</span>);</span><br><span class="line">        dfs(board, x, y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = board.size();</span><br><span class="line">        m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n<span class="number">-1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>)  board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= self.n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= self.m <span class="keyword">or</span> self.board[x][y] != <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.board[x][y] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        self.dfs(x-<span class="number">1</span>, y)</span><br><span class="line">        self.dfs(x+<span class="number">1</span>, y)</span><br><span class="line">        self.dfs(x, y-<span class="number">1</span>)</span><br><span class="line">        self.dfs(x, y+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.board = board</span><br><span class="line">        self.n = <span class="built_in">len</span>(board)</span><br><span class="line">        self.m = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            self.dfs(<span class="number">0</span>, i)</span><br><span class="line">            self.dfs(self.n-<span class="number">1</span>, i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.dfs(i, <span class="number">0</span>)</span><br><span class="line">            self.dfs(i, self.m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 131. Palindrome Partitioning</title>
    <url>/2021/05/03/131.%20Palindrome%20Partitioning/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p>
<p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs+回溯。</p>
<p>每一层 dfs 中，枚举下一个起始位置所有可能的右端点。</p>
<p>由于出现回文串的判断，故加上记忆化搜索，或者可以预处理所有子串是否为回文串。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l][r] != <span class="number">-1</span>)  <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)  dp[l][r] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[l] == s[r])   dp[l][r] = ok(s, l+<span class="number">1</span>, r<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span>    dp[l][r] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;now, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok(s, l, r))</span><br><span class="line">            &#123;</span><br><span class="line">                now.push_back(s.substr(l, r-l+<span class="number">1</span>));</span><br><span class="line">                dfs(s, r+<span class="number">1</span>, now, ans);</span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) </span><br><span class="line">    &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        dp.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; now;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        dfs(s, <span class="number">0</span>, now, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self, l, r</span>):</span></span><br><span class="line">        print(l,r)</span><br><span class="line">        <span class="keyword">if</span> self.dp[l][r] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dp[l][r]</span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            self.dp[l][r] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.s[l] == self.s[r]:</span><br><span class="line">            self.dp[l][r] = self.ok(l+<span class="number">1</span>, r-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dp[l][r] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[l][r]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, l, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == self.n:</span><br><span class="line">            self.ans.append(now[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, self.n):</span><br><span class="line">            <span class="keyword">if</span> self.ok(l, r):</span><br><span class="line">                now.append(self.s[l:r+<span class="number">1</span>])</span><br><span class="line">                self.dfs(r+<span class="number">1</span>, now)</span><br><span class="line">                now.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        self.s = s</span><br><span class="line">        self.n = <span class="built_in">len</span>(s)</span><br><span class="line">        self.dp = [[-<span class="number">1</span>]*self.n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n)]</span><br><span class="line">        print(self.dp)</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 132. Palindrome Partitioning II</title>
    <url>/2021/05/03/132.%20Palindrome%20Partitioning%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome.</p>
<p>Return <em>the minimum cuts needed</em> for a palindrome partitioning of <code>s</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先预处理所有子串是否为回文串，然后dp。</p>
<p>dp[r] 表示到 r 位置时切割的的最小次数，枚举每一个 0~r 的点 l，以找到到 r 位置的最小切割 dp[r] = min(dp[r], dp[l]+1)。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;    ok(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = r<span class="number">-1</span>; l &gt;= <span class="number">0</span>; l--)   ok[l][r] = s[l] == s[r] &amp;&amp; ok[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1e9</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[<span class="number">0</span>][r])    dp[r] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ok[l+<span class="number">1</span>][r])  dp[r] = min(dp[r], dp[l]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ok = [[<span class="number">1</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(r-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                ok[l][r] = s[l] == s[r] <span class="keyword">and</span> ok[l+<span class="number">1</span>][r-<span class="number">1</span>]</span><br><span class="line">        dp = [<span class="number">1e9</span>]*n</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> ok[<span class="number">0</span>][r]:</span><br><span class="line">                dp[r] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">                    <span class="keyword">if</span> ok[l+<span class="number">1</span>][r]:</span><br><span class="line">                        dp[r] = <span class="built_in">min</span>(dp[r], dp[l]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>/2021/04/05/AI1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="机器学习常规流程"><a href="#机器学习常规流程" class="headerlink" title="机器学习常规流程"></a>机器学习常规流程</h1><p><img src="https://i.postimg.cc/zGBy6vv1/screenshot-9.png"  /></p>
<a id="more"></a>
<ol>
<li>数学抽象。明确问题是进行机器学习的第一步。</li>
<li>数据获取。数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。</li>
<li>预处理与特征选择。良好的数据要能够提取出良好的特征才能真正发挥效力。</li>
<li>模型训练与调优。直到这一步才用到我们上面说的算法进行训练。</li>
<li>模型诊断。如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。</li>
<li>模型集成。一般来说，模型融合后都能使得效果有一定提升。</li>
<li>上线运行。这一部分内容主要跟工程实现的相关性更大。</li>
</ol>
<h1 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h1><ul>
<li>留出法</li>
</ul>
<p>直接将数据集 $D$ 划分为训练集 $S$ 和测试集 $T$。</p>
<ul>
<li>交叉验证法</li>
</ul>
<p>$k$ 折交叉验证，如图为 10 折交叉验证。</p>
<p>若 $k = m$，也称为留一法。</p>
<p><img src="https://i.postimg.cc/9Xy9x2H5/53cc8845639f9bd1.png" alt="Markdown"></p>
<ul>
<li>自助法</li>
</ul>
<p>从数据集 $D$ 中随机选择 $m$ 次，组成数据集 $D’$。</p>
<p>每个样本在 $m$ 次采样中始终不被采到的概率为</p>
<script type="math/tex; mode=display">
\lim _{m \mapsto \infty}\left(1-\frac{1}{m}\right)^{m} \mapsto \frac{1}{e} \approx 0.368</script><ul>
<li>增加验证集</li>
</ul>
<p><img src="https://i.postimg.cc/L6SCtKXP/screenshot-9.png" alt=""></p>
<h1 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h1><ul>
<li>缺失值较多</li>
</ul>
<p>直接舍弃该列特征，否则可能会带来较大的噪声，从而对结果造成不良影响。</p>
<ul>
<li>缺失值较少</li>
</ul>
<p>当缺失值较少（&lt;10%）时，可以考虑对缺失值进行填充，以下是几种常用的填充策略。</p>
<ol>
<li>用一个异常值填充（比如 0），将缺失值作为一个特征处理。</li>
<li>用均值或条件均值（缺失值所属标签相同的所有数据的均值）填充。</li>
<li>用相邻数据填充。</li>
<li>插值。</li>
<li>拟合。</li>
</ol>
<h1 id="二分类度量"><a href="#二分类度量" class="headerlink" title="二分类度量"></a>二分类度量</h1><ul>
<li>二分类结果混淆矩阵</li>
</ul>
<p><img src="https://i.postimg.cc/prkXgqB8/aacd90df25a0147f.png" alt="Markdown"></p>
<ul>
<li>精度 $Accuracy$</li>
</ul>
<script type="math/tex; mode=display">
Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script><ul>
<li>查准率 $Precision$</li>
</ul>
<script type="math/tex; mode=display">
Precision = \frac{TP}{TP+FP}</script><ul>
<li>查全率 $Recall$</li>
</ul>
<script type="math/tex; mode=display">
Recall = \frac{TP}{TP+FN}</script><ul>
<li>$F1$ 分数</li>
</ul>
<script type="math/tex; mode=display">
F 1=\frac{2 \times P \times R}{P+R}</script><ul>
<li>$P$-$R$ 曲线</li>
</ul>
<p>按预测结果对样例进行排序，正例概率越大的排越前，依次取每种分类结果作为阈值。</p>
<p>平衡点（$BEP$）表示 $P = R$。</p>
<p><img src="https://i.postimg.cc/sxf395R2/2ee7e12f1e0ebf53.png" alt=""></p>
<h1 id="多分类度量"><a href="#多分类度量" class="headerlink" title="多分类度量"></a>多分类度量</h1><ul>
<li>$Macro$ 方法</li>
</ul>
<p>先求各类别的 $Precision$、$Recall$ 和 $F1$，然后平均。</p>
<ul>
<li>$Micro$ 方法</li>
</ul>
<p>先将各类别的 $Precision$、$Recall$ 累加，然后求 $F_1$。</p>
<script type="math/tex; mode=display">
Accuracy = Micro\text{-}Precision = Micro\text{-}Recall =Micro\text{-}F1</script><h1 id="ROC-曲线和-AUC​"><a href="#ROC-曲线和-AUC​" class="headerlink" title="ROC 曲线和 AUC​"></a>ROC 曲线和 AUC​</h1><ul>
<li>真正例率 $TRP$ 和假正例率 $FPR$ </li>
</ul>
<script type="math/tex; mode=display">
{TPR}=\frac{T P}{T P+F N}\\
{FPR}=\frac{F P}{F P+T N}</script><ul>
<li>${ROC}$ 曲线和 ${AUC}$</li>
</ul>
<p>按预测结果对样例进行排序，正例概率越小的排越前，依次取每种分类结果作为阈值。</p>
<p><img src="https://i.postimg.cc/gJmpm3jK/21bf1db03e28eaff.png" alt="Markdown"></p>
<script type="math/tex; mode=display">
{AUC}=\frac{1}{2} \sum_{i=1}^{m-1}\left(x_{i+1}-x_{i}\right) \cdot\left(y_{i}+y_{i+1}\right)</script><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><p>偏差与方差分别是用于衡量一个模型泛化误差的两个方面。</p>
<ul>
<li>偏差 $Bias^2$</li>
</ul>
<p>期望输出与真实标记的误差，即模型的准确性。</p>
<p>通常是由于我们对学习算法做了错误的假设，或者模型的复杂度不够。</p>
<p>比如真实模型是一个二次函数，而我们假设模型为一次函数，这就会导致偏差的增大（欠拟合）。</p>
<p>由偏差引起的误差通常在训练误差上就能体现，或者说训练误差主要是由偏差造成的。</p>
<script type="math/tex; mode=display">
\operatorname{bias}^{2}(\boldsymbol{x})=(\overline{f}(\boldsymbol{x})-y)^{2}</script><ul>
<li>方差 $Variance$</li>
</ul>
<p>模型每次输出与期望输出的误差，即模型的稳定性，可理解为针对不同训练集产生的模型区别大小。</p>
<p>通常是由于模型的复杂度相对于训练集过高导致的。</p>
<p>比如真实模型是一个简单的二次函数，而我们假设模型是一个高次函数，这就会导致方差的增大（过拟合）；</p>
<p>由方差引起的误差通常体现在测试误差相对训练误差的增量上。</p>
<script type="math/tex; mode=display">
\operatorname{var}(\boldsymbol{x})=\mathbb{E}_{D}\left[(f(\boldsymbol{x} ; D)-\overline{f}(\boldsymbol{x}))^{2}\right]</script><ul>
<li>噪声 $\varepsilon^{2}$</li>
</ul>
<p>标记与真实标记的误差，表示期望泛化误差的下界，即刻画了学习问题本身的难度。</p>
<script type="math/tex; mode=display">
\varepsilon^{2}=\mathbb{E}_{D}\left[\left(y_{D}-y\right)^{2}\right]</script><p><img src="https://i.postimg.cc/FsfykTbS/screenshot-9.png" alt=""></p>
<ul>
<li>泛化误差</li>
</ul>
<p>当训练不足时，模型的拟合能力不够（数据的扰动不足以使模型产生显著的变化），此时偏差主导模型的泛化误差。</p>
<p>随着训练的进行，模型的拟合能力增强（模型能够学习数据发生的扰动），此时方差逐渐主导模型的泛化误差。</p>
<p>当训练充足后，模型的拟合能力过强（数据的轻微扰动都会导致模型产生显著的变化），此时即发生过拟合（训练数据自身的、非全局的特征也被模型学习了）。</p>
<script type="math/tex; mode=display">
E(f ; D)=\operatorname{bias}^{2}(\boldsymbol{x})+\operatorname{var}(\boldsymbol{x})+\varepsilon^{2}</script><p><img src="https://i.postimg.cc/MHLgMB6N/65be06ed25d2bcef.png" alt="Markdown"></p>
<h1 id="条件概率与后验概率"><a href="#条件概率与后验概率" class="headerlink" title="条件概率与后验概率"></a>条件概率与后验概率</h1><ul>
<li>条件概率</li>
</ul>
<p>一个事情发横后另一个事情发生的概率，$P(X\mid Y)$ 表示 $Y$ 发生的条件下 $X$ 发生的概率。</p>
<ul>
<li>先验概率</li>
</ul>
<p>事件发生前的预判概率，可以使历史数据统计，也可以又背景常识或人的主观观点给出。</p>
<p>一般都是单独事件发生的概率，如 $P(A)$、$P(B)$。</p>
<ul>
<li>后验概率</li>
</ul>
<p>基于先验概率求得的反向条件概率，若 $P(X\mid Y)$ 为正向，则 $P(Y\mid X)$ 为反向。</p>
<ul>
<li>贝叶斯公式</li>
</ul>
<script type="math/tex; mode=display">
P(Y \mid X)=\frac{P(X \mid Y) * P(Y)}{P(X)}</script><h1 id="生成模型和判别模型"><a href="#生成模型和判别模型" class="headerlink" title="生成模型和判别模型"></a>生成模型和判别模型</h1><ul>
<li>决策函数和条件概率分布。</li>
</ul>
<p>监督学习的任务是学习一个模型，对给定的输入预测相应的输出。这个模型的一般形式为一个决策函数或一个条件概率分布：</p>
<script type="math/tex; mode=display">
Y=f(X) \ or\  P(Y \mid X)</script><p>条件概率分布：输入 X 返回 X 属于每个类别的概率，将其中概率最大的作为 X 所属的类别。</p>
<ul>
<li>生成模型</li>
</ul>
<p>生成模型学习的是联合概率分布 $P(X,Y)$，然后根据条件概率公式计算 $P(Y\mid X)$。</p>
<script type="math/tex; mode=display">
P(Y \mid X)=\frac{P(X, Y)}{P(X)}</script><p>优点：可以还原出联合概率分布 $P(X,Y)$，而判别方法不能；收敛速度更快；使用与存在”隐变量“的情况。</p>
<p>缺点：学习和计算过程比较复杂。</p>
<p>常见模型：K 近邻、神经网络、决策树、逻辑斯蒂回归、最大熵模型、SVM、提升方法、条件随机场。</p>
<ul>
<li>判别模型</li>
</ul>
<p>判别模型直接学习决策函数或者条件概率分布，判别模型学习的是类别之间的最优分隔面，反映的是不同类数据之间的差异。</p>
<p>优点：直接面对预测，往往准确率高。</p>
<p>缺点：不能反映训练数据本身的特征。</p>
<p>常见模型：朴素贝叶斯、隐马尔可夫模型、混合高斯模型、贝叶斯网络、马尔可夫随机场。</p>
<h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p><img src="https://i.postimg.cc/13B20CdX/screenshot-9.png" alt=""></p>
<blockquote>
<p>参考：</p>
<p>《机器学习》周志华</p>
<p>《统计学习方法》李航</p>
<p><a href="https://github.com/PKUAI26/IntroductionToDataScience2019Fall">https://github.com/PKUAI26/IntroductionToDataScience2019Fall</a></p>
<p><a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html">https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习与深度学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>apt conda pip命令</title>
    <url>/2021/03/31/apt%20conda%20pip%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Apt-get"><a href="#Apt-get" class="headerlink" title="Apt-get"></a>Apt-get</h1><ul>
<li>更新</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>apt-get update</td>
<td>更新源</td>
</tr>
<tr>
<td>apt-get upgrade</td>
<td>更新已安装的包</td>
</tr>
<tr>
<td>apt-get dist-upgrade</td>
<td>升级系统</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<ul>
<li>搜索包</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>apt-cache search <package_name></td>
<td>搜索包</td>
</tr>
<tr>
<td>apt-cache show <package_name></td>
<td>获取包的相关信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>管理包</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>apt-get install <package_name></td>
<td>安装包</td>
</tr>
<tr>
<td>sudo apt-get install <package_name>=<version_number></td>
<td>安装特定版本的包</td>
</tr>
<tr>
<td>apt-get -f install <package_name></td>
<td>修复安装包</td>
</tr>
<tr>
<td>apt-get remove <package_name></td>
<td>删除包</td>
</tr>
<tr>
<td>apt-get remove <package_name> - - purge</td>
<td>删除与包相关的所有内容</td>
</tr>
<tr>
<td>apt-get clean</td>
<td>清理无用的包</td>
</tr>
<tr>
<td>apt-get autoclean</td>
<td>清理无用的包</td>
</tr>
<tr>
<td>apt-get autoremove</td>
<td>删除自动安装的lib和包</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h1><ul>
<li>添加源</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></td>
<td>添加清华源</td>
</tr>
<tr>
<td>conda config —set show_channel_urls yes</td>
<td>添加源生效</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>版本管理</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>conda —version</td>
<td>查看当前版本</td>
</tr>
<tr>
<td>conda update conda</td>
<td>升级当前版本</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>管理虚拟环境</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>conda env list</td>
<td>查看所有虚拟环境</td>
</tr>
<tr>
<td>conda create -n name python=3.6</td>
<td>创建虚拟环境</td>
</tr>
<tr>
<td>conda create -n name1 —clone name2</td>
<td>克隆服你环境</td>
</tr>
<tr>
<td>conda remove -n name —all</td>
<td>删除虚拟环境</td>
</tr>
<tr>
<td>conda activate name</td>
<td>激活虚拟环境</td>
</tr>
<tr>
<td>conda deactivate</td>
<td>关闭虚拟环境</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>管理包</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>conda list</td>
<td>查看已安装的文件包</td>
</tr>
<tr>
<td>conda install xxx=x.x</td>
<td>安装文件包</td>
</tr>
<tr>
<td>conda update xxx</td>
<td>更新文件包</td>
</tr>
<tr>
<td>conda uninstall xxx</td>
<td>删除文件包</td>
</tr>
<tr>
<td>conda list -e &gt; requirements.txt</td>
<td>批量导出包</td>
</tr>
<tr>
<td>conda install —yes —file requirements.txt</td>
<td>批量安装包</td>
</tr>
<tr>
<td>conda clean -p</td>
<td>清除无效缓存</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h1><ul>
<li>添加源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>
<ul>
<li>管理包</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pip list</td>
<td>查看已安装的文件包</td>
</tr>
<tr>
<td>pip install xxx==x.x</td>
<td>安装文件包</td>
</tr>
<tr>
<td>pip install -U xxx</td>
<td>更新文件包</td>
</tr>
<tr>
<td>pip uninstall xxx</td>
<td>删除文件包</td>
</tr>
<tr>
<td>pip freeze &gt; requirements.txt</td>
<td>批量导出包</td>
</tr>
<tr>
<td>pip install -r requirements.txt</td>
<td>批量安装包</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>配置与命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令</title>
    <url>/2021/04/01/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h1><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker images</td>
<td>显示本地镜像</td>
</tr>
<tr>
<td>docker search xxx:xxx</td>
<td>查找镜像</td>
</tr>
<tr>
<td>docker pull xxx:xxx</td>
<td>获取镜像</td>
</tr>
<tr>
<td>docker rmi xxx:xxx</td>
<td>删除镜像</td>
</tr>
<tr>
<td>docker commit -a ‘author’ -m ‘description’ ID xxx:xxx</td>
<td>更新镜像</td>
</tr>
<tr>
<td>docker tag xxx:xxx yyy:yyy</td>
<td>添加镜像新标签</td>
</tr>
<tr>
<td>docker save &gt; filename.tar xxx:xxx</td>
<td>导出镜像</td>
</tr>
<tr>
<td>docker load &lt; filename.tar</td>
<td>导入镜像</td>
</tr>
<tr>
<td>docker login</td>
<td>登录DockerHub</td>
</tr>
<tr>
<td>docker logout</td>
<td>退出登录</td>
</tr>
<tr>
<td>docker push username/xxx:xxx</td>
<td>推送镜像</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h1 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h1><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker exec -itd xxx:xxx</td>
<td>新建容器</td>
</tr>
<tr>
<td>docker ps</td>
<td>查看运行容器</td>
</tr>
<tr>
<td>docker ps -a</td>
<td>查看所有容器</td>
</tr>
<tr>
<td>docker attach ID</td>
<td>进入容器</td>
</tr>
<tr>
<td>docker inspect ID</td>
<td>查看容器信息</td>
</tr>
<tr>
<td>docker stop ID</td>
<td>停止容器</td>
</tr>
<tr>
<td>docker start ID</td>
<td>启动容器</td>
</tr>
<tr>
<td>docker restart ID</td>
<td>重启容器</td>
</tr>
<tr>
<td>docker rm ID</td>
<td>删除容器</td>
</tr>
<tr>
<td>docker export ID &gt; filename.tar</td>
<td>导出持久化容器</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><ul>
<li>docker-compose.yml 示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">    vm:</span><br><span class="line">        image: ubuntu20.04-cuda11.0-cudnn8.0-pytorch1.7-tensorflow2.4</span><br><span class="line">        restart: always</span><br><span class="line">        stdin_open: true</span><br><span class="line">        tty: true</span><br><span class="line">        shm_size: &#39;16gb&#39;</span><br><span class="line">        runtime: nvidia</span><br><span class="line">        hostname: &#39;zhu&#39;</span><br><span class="line">        ports:</span><br><span class="line">            - &#39;22022:22&#39;</span><br><span class="line">            - &#39;22080-22100:8080-8100&#39;</span><br><span class="line">        volumes:</span><br><span class="line">            - &#x2F;work&#x2F;hdd.data&#x2F;zrb:&#x2F;root&#x2F;hdd</span><br><span class="line">            - &#x2F;work&#x2F;ssd.data&#x2F;zrb:&#x2F;root&#x2F;ssd</span><br><span class="line">        environment:</span><br><span class="line">            - NVIDIA_VISIBLE_DEVICES&#x3D;all</span><br><span class="line">        command: &#x2F;bin&#x2F;bash -c &#39;service ssh start &amp; &#x2F;bin&#x2F;bash&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置与命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具</title>
    <url>/2021/03/23/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>在线 Latex</td>
<td><a href="https://www.overleaf.com/">https://www.overleaf.com/</a></td>
</tr>
<tr>
<td>在线 Markdown</td>
<td><a href="https://www.zybuluo.com/">https://www.zybuluo.com/</a></td>
</tr>
<tr>
<td>在线 Latex 数学公式</td>
<td><a href="https://www.latexlive.com/">https://www.latexlive.com/</a></td>
</tr>
<tr>
<td>手写转 Latex</td>
<td><a href="https://webdemo.myscript.com/">https://webdemo.myscript.com/</a></td>
</tr>
<tr>
<td>Latex 转 Word</td>
<td><a href="http://engenharialivre.com/latex-para-word/">http://engenharialivre.com/latex-para-word/</a></td>
</tr>
<tr>
<td>Latex 转 Word</td>
<td><a href="http://web.xiaoyv.top/web/LatexToMathML/">http://web.xiaoyv.top/web/LatexToMathML/</a></td>
</tr>
<tr>
<td>语法使用</td>
<td><a href="https://linggle.com/">https://linggle.com/</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>在线绘图</td>
<td><a href="https://www.processon.com/">https://www.processon.com/</a></td>
</tr>
<tr>
<td>图论绘图</td>
<td><a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></td>
</tr>
<tr>
<td>在线表格</td>
<td><a href="http://www.tablesgenerator.com/">http://www.tablesgenerator.com/</a></td>
</tr>
<tr>
<td>图片转图标</td>
<td><a href="https://favicon.io/">https://favicon.io/</a></td>
</tr>
<tr>
<td>免费图床</td>
<td><a href="https://imgurl.org/">https://imgurl.org/</a></td>
</tr>
<tr>
<td>在线图床</td>
<td><a href="https://imgtu.com/">https://imgtu.com/</a></td>
</tr>
<tr>
<td>图片放大</td>
<td><a href="https://bigjpg.com/">https://bigjpg.com/</a></td>
</tr>
<tr>
<td>图片压缩</td>
<td><a href="https://tinypng.com/">https://tinypng.com/</a></td>
</tr>
<tr>
<td>图片去底</td>
<td><a href="https://www.aigei.com/bgremover/">https://www.aigei.com/bgremover/</a></td>
</tr>
<tr>
<td>图片调亮度</td>
<td><a href="https://www.yasuotu.com/mohu">https://www.yasuotu.com/mohu</a></td>
</tr>
<tr>
<td>常用颜色</td>
<td><a href="https://flatuicolors.com/">https://flatuicolors.com/</a></td>
</tr>
<tr>
<td>颜色转换</td>
<td><a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">https://www.sioe.cn/yingyong/yanse-rgb-16/</a></td>
</tr>
<tr>
<td>颜色搭配</td>
<td><a href="https://colorbrewer2.org/">https://colorbrewer2.org/</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><div class="table-container">
<table>
<thead>
<tr>
<th>工具</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>PDF 操作</td>
<td><a href="https://smallpdf.com/">https://smallpdf.com/</a></td>
</tr>
<tr>
<td>文档翻译</td>
<td><a href="https://www.onlinedoctranslator.com/">https://www.onlinedoctranslator.com/</a></td>
</tr>
<tr>
<td>视频编辑</td>
<td><a href="https://www.veed.io/">https://www.veed.io/</a></td>
</tr>
<tr>
<td>模型取名</td>
<td><a href="http://acronymify.com/">http://acronymify.com/</a></td>
</tr>
<tr>
<td>模型记录</td>
<td><a href="https://www.wandb.com/">https://www.wandb.com/</a></td>
</tr>
<tr>
<td>云端应用</td>
<td><a href="https://www.uzer.me/">https://www.uzer.me/</a></td>
</tr>
<tr>
<td>临时邮箱</td>
<td><a href="http://24mail.chacuo.net/">http://24mail.chacuo.net/</a></td>
</tr>
<tr>
<td>代码展示</td>
<td><a href="https://carbon.now.sh/">https://carbon.now.sh/</a></td>
</tr>
<tr>
<td>代码分享</td>
<td><a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></td>
</tr>
<tr>
<td>接收短信</td>
<td><a href="https://www.freeonlinephone.org/">https://www.freeonlinephone.org/</a></td>
</tr>
<tr>
<td>油猴脚本</td>
<td><a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a></td>
</tr>
<tr>
<td>百度网盘直链下载助手</td>
<td><a href="https://www.baiduyun.wiki/">https://www.baiduyun.wiki/</a></td>
</tr>
<tr>
<td>优质机场推荐</td>
<td><a href="https://www.iszy.cc/2019/01/03/sci-conn/">https://www.iszy.cc/2019/01/03/sci-conn/</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>工具与资源</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>常用资源</title>
    <url>/2021/03/23/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">资源</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CCF 推荐目录</td>
<td><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation/By_category/</a></td>
</tr>
<tr>
<td style="text-align:left">中科院分区表</td>
<td><a href="http://www.fenqubiao.com/">http://www.fenqubiao.com/</a></td>
</tr>
<tr>
<td style="text-align:left">计算机会议汇总</td>
<td><a href="https://www.guide2research.com/conferences/">https://www.guide2research.com/conferences/</a></td>
</tr>
<tr>
<td style="text-align:left">AI 顶会接收率</td>
<td><a href="https://github.com/lixin4ever/Conference-Acceptance-Rate/">https://github.com/lixin4ever/Conference-Acceptance-Rate/</a></td>
</tr>
<tr>
<td style="text-align:left">AI 顶会最新信息</td>
<td><a href="https://github.com/JackieTseng/conference_call_for_paper/">https://github.com/JackieTseng/conference_call_for_paper/</a></td>
</tr>
<tr>
<td style="text-align:left">论文索引</td>
<td><a href="https://dblp.org/db/conf/">https://dblp.org/db/conf/</a></td>
</tr>
<tr>
<td style="text-align:left">Paper Code</td>
<td><a href="https://paperswithcode.com/">https://paperswithcode.com/</a></td>
</tr>
<tr>
<td style="text-align:left">Sci-Hub</td>
<td><a href="https://sci-hub.se/">https://sci-hub.se/</a></td>
</tr>
<tr>
<td style="text-align:left">Library Genesis</td>
<td><a href="http://libgen.rs/">http://libgen.rs/</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">工具</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">W3Cschool</td>
<td><a href="https://www.w3cschool.cn/tutorial/">https://www.w3cschool.cn/tutorial/</a></td>
</tr>
<tr>
<td style="text-align:left">C++ 文档</td>
<td><a href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a></td>
</tr>
<tr>
<td style="text-align:left">Pytorch 文档</td>
<td><a href="https://pytorch.apachecn.org/">https://pytorch.apachecn.org/</a></td>
</tr>
<tr>
<td style="text-align:left">TensorFlow 文档</td>
<td><a href="https://tensorflow.google.cn/tutorials/">https://tensorflow.google.cn/tutorials/</a></td>
</tr>
<tr>
<td style="text-align:left">Keras 文档</td>
<td><a href="https://keras-cn.readthedocs.io/en/latest/">https://keras-cn.readthedocs.io/en/latest/</a></td>
</tr>
<tr>
<td style="text-align:left">Numpy 文档</td>
<td><a href="https://www.numpy.org.cn/user/">https://www.numpy.org.cn/user/</a></td>
</tr>
<tr>
<td style="text-align:left">SciPy 文档</td>
<td><a href="https://docs.scipy.org/doc/scipy/reference/index.html">https://docs.scipy.org/doc/scipy/reference/index.html</a></td>
</tr>
<tr>
<td style="text-align:left">Pandas 文档</td>
<td><a href="https://www.pypandas.cn/docs/">https://www.pypandas.cn/docs/</a></td>
</tr>
<tr>
<td style="text-align:left">Matplotlib 文档</td>
<td><a href="https://www.matplotlib.org.cn/tutorials/#序言">https://matplotlib.org/gallery/index.html</a></td>
</tr>
<tr>
<td style="text-align:left">NetworkX 文档</td>
<td><a href="https://networkx.github.io/documentation/stable/tutorial.html">https://networkx.github.io/documentation/stable/tutorial.html</a></td>
</tr>
<tr>
<td style="text-align:left">数列大全</td>
<td><a href="http://oeis.org/">http://oeis.org/</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">资源</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数学基础</td>
<td><a href="https://www.matongxue.com/madocs/">https://www.matongxue.com/madocs/</a></td>
</tr>
<tr>
<td style="text-align:left">英语进阶指南</td>
<td><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese/">https://github.com/byoungd/English-level-up-tips-for-Chinese/</a></td>
</tr>
<tr>
<td style="text-align:left">深度学习花书</td>
<td><a href="https://github.com/exacity/deeplearningbook-chinese/">https://github.com/exacity/deeplearningbook-chinese/</a></td>
</tr>
<tr>
<td style="text-align:left">可解释机器学习</td>
<td><a href="https://christophm.github.io/interpretable-ml-book/">https://christophm.github.io/interpretable-ml-book/</a></td>
</tr>
<tr>
<td style="text-align:left">深度学习500问</td>
<td><a href="https://github.com/scutan90/DeepLearning-500-questions/">https://github.com/scutan90/DeepLearning-500-questions/</a></td>
</tr>
<tr>
<td style="text-align:left">AI 算法工程师手册</td>
<td><a href="http://www.huaxiaozhuan.com/">http://www.huaxiaozhuan.com/</a></td>
</tr>
<tr>
<td style="text-align:left">动手深度学习</td>
<td><a href="https://tangshusen.me/Dive-into-DL-PyTorch/">https://tangshusen.me/Dive-into-DL-PyTorch/</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">资源</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Kaggle Notebook</td>
<td><a href="https://www.kaggle.com/notebooks">https://www.kaggle.com/notebooks</a></td>
</tr>
<tr>
<td style="text-align:left">Colaboratory</td>
<td><a href="https://colab.research.google.com/notebooks/intro.ipynb">https://colab.research.google.com/notebooks/intro.ipynb</a></td>
</tr>
<tr>
<td style="text-align:left">Google Drive</td>
<td><a href="https://drive.google.com/drive/my-drive">https://drive.google.com/drive/my-drive</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>工具与资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器基本环境</title>
    <url>/2021/03/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install apt-transport-https vim wget -y</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h1><ul>
<li>更换apt-get源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>
<ul>
<li>更换pip源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;.pip</span><br><span class="line">vim ~&#x2F;.pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>
<h1 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h1><ul>
<li>安装并配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install ssh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<ul>
<li>重启服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br></pre></td></tr></table></figure>
<ul>
<li>设置密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h1 id="更改中文"><a href="#更改中文" class="headerlink" title="更改中文"></a>更改中文</h1><ul>
<li>生成中文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install language-pack-zh-hans</span><br><span class="line">locale-gen zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<ul>
<li>更改配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;default&#x2F;locale</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE&#x3D;&quot;zh_CN:zh:en_US:en&quot;</span><br><span class="line">LC_NUMERIC&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TIME&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MONETARY&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_PAPER&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NAME&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_ADDRESS&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_ALL&#x3D;zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<ul>
<li>重启</li>
</ul>
]]></content>
      <categories>
        <category>配置与命令</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基本环境</title>
    <url>/2021/03/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><ul>
<li>驱动下载</li>
</ul>
<p><a href="https://www.nvidia.com/Download/index.aspx">https://www.nvidia.com/Download/index.aspx</a></p>
<a id="more"></a>
<ul>
<li>安装可能需要的依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dkms build-essential linux-headers-generic gcc-multilib xorg-dev freeglut3-dev libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>禁用<code>nouveau</code>驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;echo blacklist nouveau &gt; &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nvidia-nouveau.conf&quot;</span><br><span class="line">sudo bash -c &quot;echo options nouveau modeset&#x3D;0 &gt;&gt; &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nvidia-nouveau.conf&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>安装<code>NVIDIA</code>驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash NVIDIA-Linux-x86_64-xxx.xx.bin</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<h1 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h1><ul>
<li><code>NVIDIA</code>和<code>CUDA</code>对应版本</li>
</ul>
<p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a></p>
<ul>
<li>下载</li>
</ul>
<p><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash cuda_xx.x.x_xxx.xx.xx_linux.run</span><br></pre></td></tr></table></figure>
<ul>
<li>添加环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CUDA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-xx.x</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-xx.x&#x2F;lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-xx.x&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<h1 id="CUDNN安装"><a href="#CUDNN安装" class="headerlink" title="CUDNN安装"></a>CUDNN安装</h1><ul>
<li>下载</li>
</ul>
<p><a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p>
<p>选择cuDNN Library for Linux (x86_64)</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf cudnn-x.x-linux-x64-vx.x.xx.tgz</span><br><span class="line">sudo cp cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;</span><br><span class="line">sudo cp cuda&#x2F;lib64&#x2F;libcudnn* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;</span><br><span class="line">sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h</span><br><span class="line">sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;libcudnn*</span><br></pre></td></tr></table></figure>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul>
<li>下载</li>
</ul>
<p><a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a></p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-20xx.xx-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><ul>
<li>安装</li>
</ul>
<p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
<p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch.backends import cudnn</span><br><span class="line">print(&#39;torch:&#39;, torch.__version__)</span><br><span class="line">print(&#39;cuda:&#39;, torch.version.cuda)</span><br><span class="line">print(&#39;cudnn:&#39;, cudnn.version())</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	print(&quot;Support CUDA:&quot;, torch.cuda.is_available())</span><br><span class="line">	x &#x3D; torch.Tensor([1.0])</span><br><span class="line">	xx &#x3D; x.cuda()</span><br><span class="line">	print(xx)</span><br><span class="line"></span><br><span class="line">	y &#x3D; torch.randn(2, 3)</span><br><span class="line">	yy &#x3D; y.cuda()</span><br><span class="line">	print(yy)</span><br><span class="line"></span><br><span class="line">	zz &#x3D; xx + yy</span><br><span class="line">	print(zz)</span><br><span class="line"></span><br><span class="line">	print(&quot;Support cudnn:&quot;, cudnn.is_acceptable(xx))</span><br></pre></td></tr></table></figure>
<h1 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h1><ul>
<li>版本对应</li>
</ul>
<p><a href="https://tensorflow.google.cn/install/source#gpu_support_3">https://tensorflow.google.cn/install/source#gpu_support_3</a></p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import tensorflow.keras as keras</span><br><span class="line">import tensorflow.keras.layers as layers</span><br><span class="line">print(tf.__version__)</span><br><span class="line"></span><br><span class="line">(x_train, y_train), (x_test, y_test) &#x3D; keras.datasets.boston_housing.load_data()</span><br><span class="line">print(x_train.shape, &#39; &#39;, y_train.shape)</span><br><span class="line">print(x_test.shape, &#39; &#39;, y_test.shape)</span><br><span class="line"></span><br><span class="line">model &#x3D; keras.Sequential([</span><br><span class="line">    layers.Dense(32, activation&#x3D;&#39;sigmoid&#39;, input_shape&#x3D;(13,)),</span><br><span class="line">    layers.Dense(32, activation&#x3D;&#39;sigmoid&#39;),</span><br><span class="line">    layers.Dense(32, activation&#x3D;&#39;sigmoid&#39;),</span><br><span class="line">    layers.Dense(1)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer&#x3D;keras.optimizers.SGD(0.1),</span><br><span class="line">             loss&#x3D;&#39;mean_squared_error&#39;,  # keras.losses.mean_squared_error</span><br><span class="line">             metrics&#x3D;[&#39;mse&#39;])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size&#x3D;50, epochs&#x3D;50, validation_split&#x3D;0.1, verbose&#x3D;1)</span><br></pre></td></tr></table></figure>
<h1 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h1><ul>
<li>生成配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>
<ul>
<li>生成密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook password</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.jupyter&#x2F;jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip &#x3D; &#39;*&#39;</span><br><span class="line">c.NotebookApp.port &#x3D; 8088</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False</span><br><span class="line">c.NotebookApp.allow_root &#x3D; True</span><br></pre></td></tr></table></figure>
<ul>
<li>安装<code>nbextension</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">pip install nbconvert&#x3D;&#x3D;5.6.1 -i https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple</span><br><span class="line">jupyter contrib nbextension install --user --skip-running-check</span><br></pre></td></tr></table></figure>
<ul>
<li>修改背景行距</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U jupyterthemes</span><br><span class="line">jt --lineh 140 -f consolamono -tf ptmono -t onedork -ofs 14 -nfs 14 -tfs 14 -fs 14 -T -N -cellw 1500</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置与命令</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招算法模板</title>
    <url>/2021/04/15/%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>目的</li>
</ul>
<p>以更小的时间复杂度（近$O(logn)$），维护和查找分组。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/zhxmdefj/p/11117791.html">并查集到带权并查集</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	pre[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findd</span><span class="params">(<span class="keyword">int</span> x)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[x] == x?x:pre[x] = findd(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = findd(x), yy = findd(y);</span><br><span class="line">    <span class="keyword">if</span>(xx != yy)	pre[xx] = yy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ul>
<li>目的</li>
</ul>
<p>以更小的时间复杂度（$O(logn)$），维护和查找前缀和。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[<span class="number">50005</span>] = &#123;<span class="number">0</span>&#125;, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[pos] += x;</span><br><span class="line">        pos += lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += tree[pos];</span><br><span class="line">        pos -= lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul>
<li>目标</li>
</ul>
<p>以更小的时间复杂度（$O(logn)$），维护和查找区间和。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/106118909">知乎：算法学习笔记(14): 线段树</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,lazy;</span><br><span class="line">&#125;tree[<span class="number">400005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[pos].x = tree[pos&lt;&lt;<span class="number">1</span>].x+tree[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[pos].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[pos&lt;&lt;<span class="number">1</span>].x += (tree[pos&lt;&lt;<span class="number">1</span>].r-tree[pos&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tree[pos].lazy;</span><br><span class="line">        tree[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].x += (tree[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tree[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tree[pos].lazy;</span><br><span class="line">        tree[pos&lt;&lt;<span class="number">1</span>].lazy += tree[pos].lazy;</span><br><span class="line">        tree[pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy += tree[pos].lazy;    </span><br><span class="line">        tree[pos].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[pos].l = l;</span><br><span class="line">    tree[pos].r = r;</span><br><span class="line">    tree[pos].lazy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[pos].x = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    build(pos&lt;&lt;<span class="number">1</span>, l, mid);</span><br><span class="line">    build(pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    pushup(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; tree[pos].l || tree[pos].r &lt; l)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[pos].l &amp;&amp; tree[pos].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[pos].x = (tree[pos].r-tree[pos].l+<span class="number">1</span>)*x;</span><br><span class="line">        tree[pos].lazy = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(pos);</span><br><span class="line">    update(pos&lt;&lt;<span class="number">1</span>, l, r, x);</span><br><span class="line">    update(pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, l, r, x);</span><br><span class="line">    pushup(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; tree[pos].l || tree[pos].r &lt; l)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[pos].l &amp;&amp; tree[pos].r &lt;= r)    <span class="keyword">return</span> tree[pos].x;</span><br><span class="line">    pushdown(pos);</span><br><span class="line">    <span class="keyword">return</span>  getsum(pos&lt;&lt;<span class="number">1</span>, l, r)+getsum(pos&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ul>
<li>目标</li>
</ul>
<p>维护单调递增或递减的栈。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/shawshawwan/p/10166459.html">单调栈总结</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Leetcode 42，柱状图中的最大储水量，使用单调递减的栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; height[s.top()] &lt; height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(s.empty())   <span class="keyword">break</span>;</span><br><span class="line">                ans += (min(height[i], height[s.top()])-h)*(i-s.top()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Leetcode 84，柱状图中的最大矩阵面积，使用单调递增的栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(&#123;<span class="number">-1</span>&#125;)</span></span>;</span><br><span class="line">    heights.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">1</span> &amp;&amp; heights[s.top()] &gt; heights[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">            s.pop();</span><br><span class="line">            ans = max(ans, h*(i-s.top()<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><ul>
<li>目标</li>
</ul>
<p>预处理（$O(nlogn)$）后，快速查找（$O(1)$）区间最小值或最大值。</p>
<ul>
<li><p>思路</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mm[<span class="number">100005</span>],dp[<span class="number">100005</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mm[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mm[i] = (i&amp;(i<span class="number">-1</span>)) == <span class="number">0</span>?mm[i<span class="number">-1</span>]+<span class="number">1</span>:mm[i<span class="number">-1</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; i++)  dp[i][j] = min(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = mm[b-a+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> min(dp[a][k], dp[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><ul>
<li>目标</li>
</ul>
<p>求两个字符串的最长公共子序列，不要求连续子串。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/moongeek/p/7530730.html">最长公共子序列（LCS）</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Leetcode 1143</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])  dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printflcs(s1, s2, len1, len2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printflcs</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(s1[x<span class="number">-1</span>] == s2[y<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        printflcs(s1, s2, x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s1[x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp[x][y<span class="number">-1</span>] &gt; dp[x<span class="number">-1</span>][y])    printflcs(s1, s2, x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span>    printflcs(s1, s2, x<span class="number">-1</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><ul>
<li>目标</li>
</ul>
<p>求数组的最长递增子序列。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/812-xiao-wen/p/10992613.html">求最长上升子序列的三种经典方案</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Leetcode 300</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = lower_bound(b, b+len, a[i])-b;</span><br><span class="line">        b[t] = a[i];</span><br><span class="line">        <span class="keyword">if</span>(t == len)    len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul>
<li>目标</li>
</ul>
<p>给定 $n$ 个物品的重量 $w$ 和价值 $v$，求总重量不超过 $m$ 的最大价值和，物品不可重复使用。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/coin-change/solution/bei-bao-wen-ti-zhi-01bei-bao-wen-ti-ke-pu-wen-ji-c/">背包问题之 01 背包问题</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//百炼 2773</span></span><br><span class="line"><span class="comment">//数量n，背包m，重量w，价值v</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>], v[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--)	dp[j] = max(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><ul>
<li>目标</li>
</ul>
<p>给定 $n$ 个物品的重量 $w$ 和价值 $v$，求总重量不超过 $m$ 的最大价值和，物品可重复使用。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/labuladong/p/13927918.html">经典动态规划：完全背包问题</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ 1384</span></span><br><span class="line"><span class="comment">//完全背包初始化分两种情况：</span></span><br><span class="line"><span class="comment">//1、如果背包要求正好装满则初始化 dp[0] = 0, dp[1~m] = -INF</span></span><br><span class="line"><span class="comment">//2、如果不需要正好装满 dp[0~m] = 0</span></span><br><span class="line"><span class="comment">//该题为求刚好装满的最小价值和</span></span><br><span class="line"><span class="comment">//数量n，背包m，重量w，价值v</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n, m, e, f;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">505</span>], v[<span class="number">505</span>], dp[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; e &gt;&gt; f &gt;&gt; n;</span><br><span class="line">        m = f-e;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; j++)	dp[j] = min(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[m] == INF)    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is impossible.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The minimum amount of money in the piggy-bank is &quot;</span> &lt;&lt; dp[m] &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路Dijkstra"><a href="#最短路Dijkstra" class="headerlink" title="最短路Dijkstra"></a>最短路Dijkstra</h2><ul>
<li>目标</li>
</ul>
<p>求图上的最短路径。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">图最短路径算法之迪杰斯特拉算法（Dijkstra）</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w;</span><br><span class="line">    xxx(<span class="keyword">int</span> a, <span class="keyword">int</span> b):to(a), w(b)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(xxx X, xxx Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> X.w &gt; Y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;xxx&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dis[beg] = <span class="number">0</span>;</span><br><span class="line">    q.push(xxx(beg, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().to;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])    <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[now].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = v[now][i].to, w = v[now][i].w;</span><br><span class="line">            <span class="keyword">if</span>(!vis[t] &amp;&amp; dis[now]+w &lt; dis[t])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[t] = dis[now]+w;</span><br><span class="line">                q.push(xxx(t, dis[t]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树prim"><a href="#最小生成树prim" class="headerlink" title="最小生成树prim"></a>最小生成树prim</h2><ul>
<li>目标</li>
</ul>
<p>以每次加点的形式，构建最小生成树。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/zui-xiao-sheng-cheng-shu-primsuan-fa-by-kobe24o/">最小生成树Prim + kruskal算法</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w;</span><br><span class="line">    xxx(<span class="keyword">int</span> a, <span class="keyword">int</span> b):to(a), w(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(xxx a, xxx b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;xxx&gt; q;</span><br><span class="line">    q.push(xxx(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().to, w = q.top().w;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])	<span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        ans += q.top().w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[now].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = v[now][i].to, ww = v[now][i].w;</span><br><span class="line">            <span class="keyword">if</span>(vis[t])  <span class="keyword">continue</span>;</span><br><span class="line">            q.push(xxx(t, ww));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树kruskal"><a href="#最小生成树kruskal" class="headerlink" title="最小生成树kruskal"></a>最小生成树kruskal</h2><ul>
<li>目标</li>
</ul>
<p>以每次加边的形式，构建最小生成树。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/zui-xiao-sheng-cheng-shu-primsuan-fa-by-kobe24o/">最小生成树Prim + kruskal算法</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;</span><br><span class="line">    xxx(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):from(a), to(b), w(c)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(xxx a, xxx b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;xxx&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findd</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[x] == x?x:findd(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	pre[i] = i;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = findd(v[i].from), y = findd(v[i].to);</span><br><span class="line">        <span class="keyword">if</span>(x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += v[i].w;</span><br><span class="line">            pre[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul>
<li>目标</li>
</ul>
<p>字符串匹配算法，给定两个字符串 $s1$ 和 $s2$，其长度分别为 $n$ 和 $m$，KMP算法将从 $s1$ 中匹配 $s2$ 的复杂度 $O(nm)$，降低为 $O(m)$ 的预处理和 $O(n+m)$ 的匹配过程。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">阮一峰的网络日志：字符串匹配的KMP算法</a></p>
<p><a href="https://www.zhihu.com/question/21923021">知乎：如何更好地理解和掌握 KMP 算法?</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ 3461</span></span><br><span class="line"><span class="comment">//求s1在s2中的出现次数</span></span><br><span class="line"><span class="comment">//ne数组：对于s1，匹配失败后，回溯的最佳位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ne[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || s[i] == s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[++i] == s[++j]) ne[i] = ne[j];</span><br><span class="line">            <span class="keyword">else</span> ne[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_next(s1);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s2.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || s1[j] == s2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span>(j == s1.length())</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                j = ne[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><ul>
<li>目标</li>
</ul>
<p>求字符串 $s$ 的最长回文子串</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://blog.csdn.net/qq_43456058/article/details/94588721">彻底搞懂马拉车（Manacher）</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Leetcode 5</span></span><br><span class="line"><span class="comment">//a数组：处理过后的数组，解决奇偶不一致问题</span></span><br><span class="line"><span class="comment">//p数组：每个位置为中心的最长回文串的半长((len+1)/2)</span></span><br><span class="line"><span class="comment">//字符串：abaa</span></span><br><span class="line"><span class="comment">//i:	0 1 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">//a[i]:	@ # a # b # a # a # $</span></span><br><span class="line"><span class="comment">//p[i]:	1 1 2 1 4 1 2 3 2 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">200005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a = <span class="string">&quot;@&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)  </span><br><span class="line">    &#123;</span><br><span class="line">        a.append(<span class="number">1</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        a.append(<span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    a.append(<span class="number">1</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    a.append(<span class="number">1</span>, <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i)    p[i] = min(p[<span class="number">2</span>*pos-i], mx-i);</span><br><span class="line">        <span class="keyword">else</span>    p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i+p[i]] == a[i-p[i]])   p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = p[i]+i;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = p[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.substr((pos-mx)/<span class="number">2</span>, mx<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> mx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><ul>
<li>目标</li>
</ul>
<p>将多个单词按字母以树的形式存储数量，查找数量。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://blog.csdn.net/forever_dreams/article/details/81009580">Trie树（字典树，单词查找树）</a></p>
<p><a href="https://www.cnblogs.com/bonelee/p/8830825.html">Trie（前缀树/字典树）及其应用</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch[<span class="number">500000</span>][<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">500005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[now][c-<span class="string">&#x27;a&#x27;</span>])	ch[now][c-<span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">        now = ch[now][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnum</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[now][c-<span class="string">&#x27;a&#x27;</span>])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        now = ch[now][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><ul>
<li>目标</li>
</ul>
<p>使用多个模式串建树，求字符串中出现模式串的个数。</p>
<ul>
<li>思路</li>
</ul>
<p><a href="https://www.cnblogs.com/nullzx/p/7499397.html">多模字符串匹配算法之AC自动机—原理与实现</a></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洛谷 3808</span></span><br><span class="line"><span class="comment">//文本中出现模式串的数量，一个模式串不多次计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">500005</span>][<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">500005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[now][c-<span class="string">&#x27;a&#x27;</span>]) ch[now][c-<span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">        now = ch[now][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[ch[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">            q.push(ch[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[now][i])</span><br><span class="line">            &#123;</span><br><span class="line">                fa[ch[now][i]] = ch[fa[now]][i];</span><br><span class="line">                q.push(ch[now][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    ch[now][i] = ch[fa[now]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        now = ch[now][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = now; t &amp;&amp; val[t]; t = fa[t])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += val[t];</span><br><span class="line">            val[t] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    build();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; query(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 133. Clone Graph</title>
    <url>/2021/05/18/133.%20Clone%20Graph/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory">connected</a>#Connected_graph)</strong> undirected graph.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> (clone) of the graph.</p>
<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你无向 <strong>连通</strong> 图中一个节点的引用，请你返回该图的 <strong>深拷贝</strong>（克隆）。</p>
<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><strong>Test case format:</strong></p>
<p>For simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>
<p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>
<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList &#x3D; [[]]</span><br><span class="line">Output: [[]]</span><br><span class="line">Explanation: Note that the input contains one empty list. The graph consists of only one node with val &#x3D; 1 and it does not have any neighbors.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList &#x3D; []</span><br><span class="line">Output: []</span><br><span class="line">Explanation: This an empty graph, it does not have any nodes.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList &#x3D; [[2],[1]]</span><br><span class="line">Output: [[2],[1]]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>BFS，开一个map记录两个图对应的节点，遍历一遍所有的节点和邻节点即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; mp;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;Node*&gt; <span class="title">q</span><span class="params">(&#123;node&#125;)</span></span>;</span><br><span class="line">        mp[node] = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:now-&gt;neighbors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!mp.count(n))</span><br><span class="line">                &#123;</span><br><span class="line">                    mp[n] = <span class="keyword">new</span> Node(n-&gt;val);</span><br><span class="line">                    q.push(n);</span><br><span class="line">                &#125;</span><br><span class="line">                mp[now]-&gt;neighbors.emplace_back(mp[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val = 0, neighbors = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors if neighbors is not None else []</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(node)</span><br><span class="line">        mp = &#123;node:Node(node.val)&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = q.get()</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> now.neighbors:</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                    mp[n] = Node(n.val)</span><br><span class="line">                    q.put(n)</span><br><span class="line">                mp[now].neighbors.append(mp[n])</span><br><span class="line">        <span class="keyword">return</span> mp[node]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 134. Gas Station</title>
    <url>/2021/05/18/134.%20Gas%20Station/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p>
<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>在一条环路上有 <code>N</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明</strong>: </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>贪心可得，由于每一步过后，累计的 gas 必然非负。</p>
<p>因此当从 $l$ 到 $r$ 的路径中，$r$ 节点不可到下一节点时，那么从 $l$ 至 $r$ 中的任意一点，也无法到达 $r$ 的下一节点。</p>
<p>只要遍历一遍环，判断是否有合法的起点即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.size(), pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (pos+cnt)%n;</span><br><span class="line">                sum += gas[t]-cost[t];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n)    <span class="keyword">return</span> pos;</span><br><span class="line">            <span class="keyword">else</span>    pos += cnt+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(gas)</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pos &lt; n:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cnt &lt; n:</span><br><span class="line">                t = (pos+cnt)%n</span><br><span class="line">                <span class="built_in">sum</span> += gas[t]-cost[t]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == n:</span><br><span class="line">                <span class="keyword">return</span> pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos += cnt+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 135. Candy</title>
    <url>/2021/05/18/135.%20Candy/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>老师想给孩子们分发糖果，有 <code>N</code> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ratings &#x3D; [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ratings &#x3D; [1,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.</span><br><span class="line">The third child gets 1 candy because it satisfies the above two conditions.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑两个方向均扫一遍，当当前位置比上一位置大时，将值置位上一位置的值+1，否则为1。</p>
<p>最终每个位置的最小糖果数量为两个方向的最大值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.size();</span><br><span class="line">        vector&lt;int&gt; l(n, 1), r(n, 1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">-1</span>])   l[i] = l[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>])   r[i] = r[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  ans += max(l[i], r[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        l = [<span class="number">1</span>]*n</span><br><span class="line">        r = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i-<span class="number">1</span>]:</span><br><span class="line">                l[i] = l[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i+<span class="number">1</span>]:</span><br><span class="line">                r[i] = r[i+<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">max</span>(l[i], r[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 136. Single Number</title>
    <url>/2021/05/18/136.%20Single%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>
<p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明</strong>：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将整个数组异或一遍，出现两次的数通过异或操作后变为0，故最终结果为出现一次的那个数。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)    ans ^= x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ans ^= num</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 137. Single Number II</title>
    <url>/2021/05/18/137.%20Single%20Number%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code> where every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>
<p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑每个位的和，若和不为3的倍数，则说明出现一次的数在这个位上有值。</p>
<p>需要注意最高位的符号位情况。</p>
<p>时间复杂度 $O(nlog32)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) sum += (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum%<span class="number">3</span>)   ans |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="built_in">sum</span> += (x&gt;&gt;i)&amp;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>%<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">31</span>:</span><br><span class="line">                    ans -= (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans |= (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 138. Copy List with Random Pointer</title>
    <url>/2021/05/18/138.%20Copy%20List%20with%20Random%20Pointer/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>
<p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>
<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>
<p>Return <em>the head of the copied linked list</em>.</p>
<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>
<ul>
<li><code>val</code>: an integer representing <code>Node.val</code></li>
<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>
<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li>
</ul>
<p>你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[1,1],[2,1]]</span><br><span class="line">Output: [[1,1],[2,1]]</span><br></pre></td></tr></table></figure>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The given linked list is empty (null pointer), so return null.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先复制整个列表和 next 指针，并用 map 记录对应的指针，然后遍历一遍，复制 random 指针。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; mp;</span><br><span class="line">        mp[head] = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">        Node *now = head;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[now]-&gt;next = <span class="keyword">new</span> Node(now-&gt;next-&gt;val);</span><br><span class="line">            mp[now-&gt;next] = mp[now]-&gt;next;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        now = head;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;random) mp[now]-&gt;random = mp[now-&gt;random];</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mp = &#123;head:Node(head.val)&#125;</span><br><span class="line">        now = head</span><br><span class="line">        <span class="keyword">while</span> now.<span class="built_in">next</span>:</span><br><span class="line">            mp[now].<span class="built_in">next</span> = Node(now.<span class="built_in">next</span>.val)</span><br><span class="line">            mp[now.<span class="built_in">next</span>] = mp[now].<span class="built_in">next</span></span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        now = head</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            <span class="keyword">if</span>(now.random):</span><br><span class="line">                mp[now].random = mp[now.random]</span><br><span class="line">            now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> mp[head]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 139. Word Break</title>
    <url>/2021/05/18/139.%20Word%20Break/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非空字符串 <code>s</code> 和一个包含非空单词的列表 <code>wordDict</code>，判定 <code>s</code> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：DFS"><a href="#一：DFS" class="headerlink" title="一：DFS"></a>一：DFS</h2><p>dfs(string s, int l) 返回的值表示从 l 位置开始，后续的子串是否可由单词构成。</p>
<p>对于每一个 l 的起始，枚举 r 的位置。</p>
<p>在整个 dfs 的过程中，由于会多次重复判断相同的 l，故加上记忆化。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<h2 id="二：DP"><a href="#二：DP" class="headerlink" title="二：DP"></a>二：DP</h2><p>dp[i] 表示 i 位置之前的子串是否可由单词构成。</p>
<p>若 dp[l] 为1，且 l~r 子串在单词中，则 dp[r+1] 也为1。</p>
<p>时间复杂度 $O(n^2logm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; cant;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cant.count(l))   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == n)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(s.substr(l, r-l+<span class="number">1</span>)) &amp;&amp; dfs(s, r+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cant[l] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:wordDict)   st.insert(word);</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">st</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= r; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[l] &amp;&amp; st.count(s.substr(l, r-l+<span class="number">1</span>)))   dp[r+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, s, l</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">in</span> self.cant:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l == self.n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, self.n):</span><br><span class="line">            <span class="keyword">if</span> s[l:r+<span class="number">1</span>] <span class="keyword">in</span> self.st <span class="keyword">and</span> self.dfs(s, r+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        self.cant.add(l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line">        self.n = <span class="built_in">len</span>(s)</span><br><span class="line">        self.st = <span class="built_in">set</span>(wordDict)</span><br><span class="line">        self.cant = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">return</span> self.dfs(s, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        st = <span class="built_in">set</span>(wordDict)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(r+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[l] <span class="keyword">and</span> s[l:r+<span class="number">1</span>] <span class="keyword">in</span> st:</span><br><span class="line">                    dp[r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 140. Word Break II</title>
    <url>/2021/05/18/140.%20Word%20Break%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>
<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非空字符串 <code>s</code> 和一个包含非空单词列表的字典 <code>wordDict</code>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p>说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 139. Word Break 的基础上，输出所有结果。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(now[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; now.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.back().append(<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                ans.back().append(now[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(s.substr(l, r-l+<span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                now.emplace_back(s.substr(l, r-l+<span class="number">1</span>));</span><br><span class="line">                dfs(s, r+<span class="number">1</span>, now);</span><br><span class="line">                now.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:wordDict)   st.insert(word);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; now;</span><br><span class="line">        dfs(s, <span class="number">0</span>, now);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, s, l, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == self.n:</span><br><span class="line">            self.ans.append(<span class="string">&#x27; &#x27;</span>.join(now))</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l, self.n):</span><br><span class="line">            <span class="keyword">if</span> s[l:r+<span class="number">1</span>] <span class="keyword">in</span> self.st:</span><br><span class="line">                now.append(s[l:r+<span class="number">1</span>])</span><br><span class="line">                self.dfs(s, r+<span class="number">1</span>, now)</span><br><span class="line">                now.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line">        self.n = <span class="built_in">len</span>(s)</span><br><span class="line">        self.st = <span class="built_in">set</span>(wordDict)</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        st = <span class="built_in">set</span>(wordDict)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(r+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[l] <span class="keyword">and</span> s[l:r+<span class="number">1</span>] <span class="keyword">in</span> st:</span><br><span class="line">                    dp[r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 141. Linked List Cycle</title>
    <url>/2021/05/20/141.%20Linked%20List%20Cycle/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 <code>0</code> 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意</strong>：<code>pos</code> <strong>不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>进阶</strong>：</p>
<p>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>快慢指针，若存在环，则两者必定相遇。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p == q)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 142. Linked List Cycle II</title>
    <url>/2021/05/20/142.%20Linked%20List%20Cycle%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>快慢指针，若存在环，则两者必定相遇。</p>
<p>相遇之后，可知快指针多走的距离（n圈+相遇点到环入口+环入口到相遇点）等于慢指针从起点到相遇点（起点到环入口+环入口到相遇点）。</p>
<p>可知，n圈+相遇点到环入口 = 起点到环入口。</p>
<p>因此，再让一个指针从首节点开始，与从相遇点开始的指针一起动，他们最终会在环的入口相遇。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p == q)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                t = head</span><br><span class="line">                <span class="keyword">while</span> t != p:</span><br><span class="line">                    t = t.<span class="built_in">next</span></span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 143. Reorder List</title>
    <url>/2021/05/20/143.%20Reorder%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given the head of a singly linked-list. The list can be represented as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure>
<p><em>Reorder the list to be on the following form:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure>
<p>You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个单链表 <code>L：L0→L1→…→Ln-1→Ln</code><br>将其重新排列后变为： <code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code></p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4]</span><br><span class="line">Output: [1,4,2,3]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先用快慢指针找到链表中点，然后将后一段翻转，合并两段链表。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span>;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next &amp;&amp; q-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l1 = head, *l2 = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="number">0</span>;</span><br><span class="line">        ListNode *now = l2, *pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = t;</span><br><span class="line">        &#125;</span><br><span class="line">        l2 = pre;</span><br><span class="line">        <span class="keyword">while</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t1 = l1-&gt;next, *t2 = l2-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2-&gt;next = t1;</span><br><span class="line">            l1 = t1;</span><br><span class="line">            l2 = t2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        now = l2</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            t = now.<span class="built_in">next</span></span><br><span class="line">            now.<span class="built_in">next</span> = pre</span><br><span class="line">            pre, now = now, t</span><br><span class="line">        l2 = pre</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            t1, t2 = l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span></span><br><span class="line">            l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> = l2, t1</span><br><span class="line">            l1, l2 = t1, t2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 144. Binary Tree Preorder Traversal</title>
    <url>/2021/05/20/144.%20Binary%20Tree%20Preorder%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：DFS"><a href="#一：DFS" class="headerlink" title="一：DFS"></a>一：DFS</h2><p>dfs 遍历每个节点。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：Morris"><a href="#二：Morris" class="headerlink" title="二：Morris"></a>二：Morris</h2><p>不需要额外空间的遍历。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        ans.emplace_back(now-&gt;val);</span><br><span class="line">        dfs(now-&gt;left);</span><br><span class="line">        dfs(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode *now = root, *p;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            p = now-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;right &amp;&amp; p-&gt;right != now)  p = p-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.emplace_back(now-&gt;val);</span><br><span class="line">                    p-&gt;right = now;</span><br><span class="line">                    now = now-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    p-&gt;right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    ans.emplace_back(now-&gt;val);</span><br><span class="line">            now = now-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.ans.append(now.val)</span><br><span class="line">        self.dfs(now.left)</span><br><span class="line">        self.dfs(now.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        now = root</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            p = now.left</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">while</span> p.right <span class="keyword">and</span> p.right != now:</span><br><span class="line">                    p = p.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p.right:</span><br><span class="line">                    ans.append(now.val)</span><br><span class="line">                    p.right = now</span><br><span class="line">                    now = now.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.right = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(now.val)</span><br><span class="line">            now = now.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 145. Binary Tree Postorder Traversal</title>
    <url>/2021/05/20/145.%20Binary%20Tree%20Postorder%20Traversal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre3.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：DFS"><a href="#一：DFS" class="headerlink" title="一：DFS"></a>一：DFS</h2><p>dfs 遍历每个节点。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="二：Morris"><a href="#二：Morris" class="headerlink" title="二：Morris"></a>二：Morris</h2><p>不需要额外空间的遍历。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(now-&gt;left);</span><br><span class="line">        dfs(now-&gt;right);</span><br><span class="line">        ans.emplace_back(now-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, TreeNode *now)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.emplace_back(now-&gt;val);</span><br><span class="line">            now = now-&gt;right;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.end()-cnt, ans.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode *now = root, *p;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            p = now-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(p-&gt;right &amp;&amp; p-&gt;right != now)  p = p-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;right = now;</span><br><span class="line">                    now = now-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;right = <span class="number">0</span>;</span><br><span class="line">                    addPath(ans, now-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(now.left)</span><br><span class="line">        self.dfs(now.right)</span><br><span class="line">        self.ans.append(now.val)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addPath</span>(<span class="params">self, ans, now</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            ans.append(now.val)</span><br><span class="line">            now = now.right</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        ans[-cnt:] = ans[-cnt:][::-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        now = root</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            p = now.left</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">while</span> p.right <span class="keyword">and</span> p.right != now:</span><br><span class="line">                    p = p.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p.right:</span><br><span class="line">                    p.right = now</span><br><span class="line">                    now = now.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.right = <span class="literal">None</span></span><br><span class="line">                    self.addPath(ans, now.left);</span><br><span class="line">            now = now.right</span><br><span class="line">        self.addPath(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 146. LRU Cache</title>
    <url>/2021/05/20/146.%20LRU%20Cache/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Design a data structure that follows the constraints of a <strong><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a></strong>.</p>
<p>Implement the <code>LRUCache</code> class:</p>
<ul>
<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
</ul>
<p><strong>Follow up:</strong><br>Could you do <code>get</code> and <code>put</code> in <code>O(1)</code> time complexity?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>运用你所掌握的数据结构，设计和实现一个  <code>LRU (最近最少使用) 缓存机制</code> 。<br>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; cache is &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; cache is &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; return 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; LRU key was 2, evicts key 2, cache is &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; LRU key was 1, evicts key 1, cache is &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; return -1 (not found)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; return 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; return 4</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>使用散列表和双向链表。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    Node *pre, *next;</span><br><span class="line">    Node():key(<span class="number">0</span>), value(<span class="number">0</span>), pre(<span class="number">0</span>), next(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v):key(k), value(v), pre(<span class="number">0</span>), next(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node*&gt; cache;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> size, capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        now-&gt;pre = head;</span><br><span class="line">        now-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;pre = now;</span><br><span class="line">        head-&gt;next = now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        now-&gt;pre-&gt;next = now-&gt;next;</span><br><span class="line">        now-&gt;next-&gt;pre = now-&gt;pre;</span><br><span class="line">        addToHead(now);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeTail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *now = tail-&gt;pre;</span><br><span class="line">        <span class="keyword">int</span> key = now-&gt;key;</span><br><span class="line">        now-&gt;pre-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = now-&gt;pre;</span><br><span class="line">        <span class="keyword">delete</span> now;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    LRUCache(<span class="keyword">int</span> c):capacity(c), size(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node *now = cache[key];</span><br><span class="line">            moveToHead(now);</span><br><span class="line">            <span class="keyword">return</span> now-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node *now = cache[key];</span><br><span class="line">            now-&gt;value = value;</span><br><span class="line">            moveToHead(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node *now = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            cache[key] = now;</span><br><span class="line">            addToHead(now);</span><br><span class="line">            <span class="keyword">if</span>(++size &gt; capacity)   cache.erase(removeTail());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span>, pre=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.pre = pre</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        now.pre = self.head</span><br><span class="line">        now.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.pre = now</span><br><span class="line">        self.head.<span class="built_in">next</span> = now</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        now.pre.<span class="built_in">next</span> = now.<span class="built_in">next</span></span><br><span class="line">        now.<span class="built_in">next</span>.pre = now.pre</span><br><span class="line">        self.addToHead(now)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        now = self.tail.pre</span><br><span class="line">        key = now.key</span><br><span class="line">        now.pre.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = now.pre</span><br><span class="line">        <span class="keyword">del</span>(now)</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            now = self.cache[key]</span><br><span class="line">            self.moveToHead(now)</span><br><span class="line">            <span class="keyword">return</span> now.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            now = self.cache[key]</span><br><span class="line">            now.value = value</span><br><span class="line">            self.moveToHead(now)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            now = Node(key, value)</span><br><span class="line">            self.cache[key] = now;</span><br><span class="line">            self.addToHead(now)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                self.cache.pop(self.removeTail())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 147. Insertion Sort List</title>
    <url>/2021/05/20/147.%20Insertion%20Sort%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list’s head</em>.</p>
<p>The steps of the <strong>insertion sort</strong> algorithm:</p>
<ol>
<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>
<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>
<li>It repeats until no input elements remain.</li>
</ol>
<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>对链表进行插入排序。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p><strong>插入排序算法：</strong></p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>链表的插入排序，增加一个首节点，模拟插入排序即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *now = head;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p = ans;</span><br><span class="line">            <span class="keyword">while</span>(p != now &amp;&amp; p-&gt;next-&gt;val &lt;= now-&gt;next-&gt;val)   p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p != now)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *t = now-&gt;next-&gt;next;</span><br><span class="line">                now-&gt;next-&gt;next = p-&gt;next;</span><br><span class="line">                p-&gt;next = now-&gt;next;</span><br><span class="line">                now-&gt;next = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        ans = ListNode()</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        now = head</span><br><span class="line">        <span class="keyword">while</span> now.<span class="built_in">next</span>:</span><br><span class="line">            p = ans</span><br><span class="line">            <span class="keyword">while</span> p != now <span class="keyword">and</span> p.<span class="built_in">next</span>.val &lt;= now.<span class="built_in">next</span>.val:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p != now:</span><br><span class="line">                t = now.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                now.<span class="built_in">next</span>.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">                p.<span class="built_in">next</span> = now.<span class="built_in">next</span></span><br><span class="line">                now.<span class="built_in">next</span> = t</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 148. Sort List</title>
    <url>/2021/05/20/148.%20Sort%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>
<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>进阶</strong>：</p>
<p>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>链表的归并排序。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* now1, ListNode* now2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *now = ans;</span><br><span class="line">        <span class="keyword">while</span>(now1 &amp;&amp; now2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;val &lt;= now2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                now-&gt;next = now1;</span><br><span class="line">                now1 = now1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                now-&gt;next = now2;</span><br><span class="line">                now2 = now2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now1)    now-&gt;next = now1;</span><br><span class="line">        <span class="keyword">if</span>(now2)    now-&gt;next = now2;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)    <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next &amp;&amp; q-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l1 = head, *l2 = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeList(sortList(l1), sortList(l2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">self, now1, now2</span>):</span></span><br><span class="line">        ans = ListNode()</span><br><span class="line">        now = ans</span><br><span class="line">        <span class="keyword">while</span> now1 <span class="keyword">and</span> now2:</span><br><span class="line">            <span class="keyword">if</span> now1.val &lt;= now2.val:</span><br><span class="line">                now.<span class="built_in">next</span> = now1</span><br><span class="line">                now1 = now1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now.<span class="built_in">next</span> = now2</span><br><span class="line">                now2 = now2.<span class="built_in">next</span></span><br><span class="line">            now =  now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> now1:</span><br><span class="line">            now.<span class="built_in">next</span> = now1</span><br><span class="line">        <span class="keyword">if</span> now2:</span><br><span class="line">            now.<span class="built_in">next</span> = now2</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeList(self.sortList(l1), self.sortList(l2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 149. Max Points on a Line</title>
    <url>/2021/05/20/149.%20Max%20Points%20on%20a%20Line/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二维平面，平面上有 <em>n</em> 个点，求最多有多少个点在同一条直线上。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>枚举每一个点，记录经过该点所有斜率的直线和斜率无穷大的直线，分别统计重合的点数量和每条直线上的点数量。</p>
<p>可用 HashMap 记录所有直线。</p>
<p>对于每一个点，可以不被下一轮的点统计，因为两者形成的直线已经被计算过。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)   <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> same_cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(points[i] == points[j])  same_cnt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>])   cnt[<span class="number">1e9</span>]++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> k = (<span class="keyword">double</span>)(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])/(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]);</span><br><span class="line">                    cnt[k]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:cnt)    ans = max(ans, same_cnt+it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            same_cnt = <span class="number">1</span></span><br><span class="line">            cnt = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] <span class="keyword">and</span> points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]:</span><br><span class="line">                    same_cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>]:</span><br><span class="line">                    cnt[<span class="number">1e9</span>] = cnt.get(<span class="number">1e9</span>, <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = (points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])/(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])</span><br><span class="line">                    cnt[k] = cnt.get(k, <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> cnt.values():</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, same_cnt+v)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 150. Evaluate Reverse Polish Notation</title>
    <url>/2021/05/20/150.%20Evaluate%20Reverse%20Polish%20Notation/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p>
<p><strong>Note</strong> that division between two integers should truncate toward zero.</p>
<p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>根据 <strong>逆波兰表示法</strong>，求表达式的值。</p>
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用栈保存数字，每当遇到符号，出栈两个数，计算入栈。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> token:tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(token == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> x = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(x+y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> x = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(x-y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> x = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(x*y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> x = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(x/y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    st.push(atoi(token.c_str()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                y = st.pop()</span><br><span class="line">                x = st.pop()</span><br><span class="line">                st.append(x+y)</span><br><span class="line">            <span class="keyword">elif</span> token == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                y = st.pop()</span><br><span class="line">                x = st.pop()</span><br><span class="line">                st.append(x-y)</span><br><span class="line">            <span class="keyword">elif</span> token == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                y = st.pop()</span><br><span class="line">                x = st.pop()</span><br><span class="line">                st.append(x*y)</span><br><span class="line">            <span class="keyword">elif</span> token == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                y = st.pop()</span><br><span class="line">                x = st.pop()</span><br><span class="line">                st.append(<span class="built_in">int</span>(x/y))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 151. Reverse Words in a String</title>
    <url>/2021/05/22/151.%20Reverse%20Words%20in%20a%20String/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>无空格字符构成一个 <strong>单词</strong> 。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;  hello world  &quot;</span><br><span class="line">Output: &quot;world hello&quot;</span><br><span class="line">Explanation: Your reversed string should not contain leading or trailing spaces.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a good   example&quot;</span><br><span class="line">Output: &quot;example good a&quot;</span><br><span class="line">Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">Output: &quot;Alice Loves Bob&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;Alice does not even like bob&quot;</span><br><span class="line">Output: &quot;bob like even not does Alice&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>把每个单词分出来，然后反转组成串即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans, now;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)    </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    reverse(now.begin(), now.end());</span><br><span class="line">                    ans.append(now);</span><br><span class="line">                    ans.append(<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                now.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    now.append(<span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now.length())</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(now.begin(), now.end());</span><br><span class="line">            ans.append(now);</span><br><span class="line">            ans.append(<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">reversed</span>(s.split()))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 152. Maximum Product Subarray</title>
    <url>/2021/05/22/152.%20Maximum%20Product%20Subarray/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code>, find a contiguous non-empty subarray within the array that has the largest product, and return <em>the product</em>.</p>
<p>It is <strong>guaranteed</strong> that the answer will fit in a <strong>32-bit</strong> integer.</p>
<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为需要考虑每个串乘积的正负值，故使用动态规划的思想。</p>
<p>$maxx[i]$ 表示以 $i$ 位置为结尾的子串的最大乘积。</p>
<p>$minn[i]$ 表示以 $i$ 位置为结尾的子串的最小乘积。</p>
<p>$maxx[i] = max(nums[i], maxx[i-1]<em>nums[i], minn[i-1]</em>nums[i])$。</p>
<p>$minn[i] = min(nums[i], maxx[i-1]<em>nums[i], minn[i-1]</em>nums[i])$。</p>
<p>另外可继续在空间上优化数组。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>], maxx = nums[<span class="number">0</span>], minn = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ma = maxx, mi = minn;</span><br><span class="line">            maxx = max(&#123;nums[i], ma*nums[i], mi*nums[i]&#125;);</span><br><span class="line">            minn = min(&#123;nums[i], ma*nums[i], mi*nums[i]&#125;);</span><br><span class="line">            ans = max(ans, maxx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        maxx = nums[<span class="number">0</span>]</span><br><span class="line">        minn = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ma = maxx</span><br><span class="line">            mi = minn</span><br><span class="line">            maxx = <span class="built_in">max</span>(nums[i], ma*nums[i], mi*nums[i])</span><br><span class="line">            minn = <span class="built_in">min</span>(nums[i], ma*nums[i], mi*nums[i])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, maxx)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 153. Find Minimum in Rotated Sorted Array</title>
    <url>/2021/05/22/153.%20Find%20Minimum%20in%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>
<ul>
<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>
<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>
<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>
<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>
<p>You must write an algorithm that runs in <code>O(log n) time.</code></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The original array was [1,2,3,4,5] rotated 3 times.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [11,13,15,17]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The original array was [11,13,15,17] and it was rotated 4 times. </span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先二分找扭转的位置，即第一个使得 $nums[i] \le nums.back()$ 成立的 $i$。</p>
<p>注：该位置为扭转位置的前提为，数组中无重复元素。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums.back()) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[-<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 154. Find Minimum in Rotated Sorted Array II</title>
    <url>/2021/05/22/154.%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>
<ul>
<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>
<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>
<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>
<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,2,0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>与 LeetCode 153. Find Minimum in Rotated Sorted Array 相似，但此题元素可重复。</p>
<p>由于起始段元素与尾元素可能相同，这使得二分找扭转位置难以实现。</p>
<p>首先，判断起始元素是否为小于末尾元素，即起始位置是否为最小元素。</p>
<p>若不是，为了避免重复元素的影响，将二分查找的首位置置于第一个与起始元素不同的位置。</p>
<p>然后二分找扭转的位置，即第一个使得 $nums[i] \le nums.back()$ 成立的 $i$。</p>
<p>还需要注意整个数组元素均相同的情况。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums.back())   <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; nums.size() &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])    l++;</span><br><span class="line">        <span class="keyword">if</span>(l == nums.size())    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums.back()) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &lt; nums[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        l, r = <span class="number">1</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[l] == nums[l-<span class="number">1</span>]:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[-<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 155. Min Stack</title>
    <url>/2021/05/22/155.%20Min%20Stack/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>Implement the <code>MinStack</code> class:</p>
<ul>
<li><code>MinStack()</code> initializes the stack object.</li>
<li><code>void push(val)</code> pushes the element <code>val</code> onto the stack.</li>
<li><code>void pop()</code> removes the element on the top of the stack.</li>
<li><code>int top()</code> gets the top element of the stack.</li>
<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 <code>x</code> 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    &#x2F;&#x2F; return 0</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -2</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在维护一个栈的同时，开另一个栈同步记录当栈的最小元素。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st, minn;</span><br><span class="line">    MinStack() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())  st.pop();</span><br><span class="line">        <span class="keyword">while</span>(!minn.empty())    minn.pop();</span><br><span class="line">        minn.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st.push(val);</span><br><span class="line">        minn.push(min(val, minn.top()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st.pop();</span><br><span class="line">        minn.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minn.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.st = []</span><br><span class="line">        self.minn = [<span class="number">1e18</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.st.append(val)</span><br><span class="line">        self.minn.append(<span class="built_in">min</span>(val, self.minn[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.st.pop()</span><br><span class="line">        self.minn.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.st[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.minn[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160. Intersection of Two Linked Lists</title>
    <url>/2021/05/22/160.%20Intersection%20of%20Two%20Linked%20Lists/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>
<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p>
<p>It is <strong>guaranteed</strong> that there are no cycles anywhere in the entire linked structure.</p>
<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>在节点 <code>c1</code> 开始相交。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">Output: Intersected at &#39;8&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">Output: Intersected at &#39;2&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="一：哈希表"><a href="#一：哈希表" class="headerlink" title="一：哈希表"></a>一：哈希表</h2><p>遍历每个节点，用哈希表记录，找到第一个重复的节点。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h2 id="二：双指针"><a href="#二：双指针" class="headerlink" title="二：双指针"></a>二：双指针</h2><p>创建两个指针，同时分别从两个链表遍历到尾，再遍历对方链表。</p>
<p>若两个指针相遇，则会在两链表相交起始点相遇。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode *now1 = headA, *now2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(now1)</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(now1);</span><br><span class="line">            now1 = now1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(now2))   <span class="keyword">return</span> now2;</span><br><span class="line">            now2 = now2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *now1 = headA, *now2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(now1 != now2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now1)    now1 = now1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>    now1 = headB;</span><br><span class="line">            <span class="keyword">if</span>(now2)    now2 = now2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>    now2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        now1 = headA</span><br><span class="line">        now2 = headB</span><br><span class="line">        <span class="keyword">while</span> now1:</span><br><span class="line">            s.add(now1)</span><br><span class="line">            now1 = now1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> now2:</span><br><span class="line">            <span class="keyword">if</span> now2 <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> now2</span><br><span class="line">            now2 = now2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        now1 = headA</span><br><span class="line">        now2 = headB</span><br><span class="line">        <span class="keyword">while</span> now1 != now2:</span><br><span class="line">            <span class="keyword">if</span> now1:</span><br><span class="line">                now1 = now1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now1 = headB</span><br><span class="line">            <span class="keyword">if</span> now2:</span><br><span class="line">                now2 = now2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now2 = headA</span><br><span class="line">        <span class="keyword">return</span> now1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 162. Find Peak Element</title>
    <url>/2021/05/22/162.%20Find%20Peak%20Element/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A peak element is an element that is strictly greater than its neighbors.</p>
<p>Given an integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给你一个输入数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分，每次缩减一半区间，并保证左右边界均满足一半的条件。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>]) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 164. Maximum Gap</title>
    <url>/2021/05/22/164.%20Maximum%20Gap/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>
<p>如果数组元素个数小于 2，则返回 0。</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给你一个输入数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,6,9,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The array contains less than 2 elements, therefore return 0.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>分桶解决，构造每个桶的大小为 $(maxx-minn)/(n-1)$，可以保证最大 gap 在桶之间。</p>
<p>因此计算每个桶的最大值和最小值，在计算桶之间最小值和最大值的差值，即可得到最大 gap。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = *min_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> maxx = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> d = max(<span class="number">1</span>, (maxx-minn)/(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> m = (maxx-minn)/d+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bucket(m, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = (nums[i]-minn)/d;</span><br><span class="line">            <span class="keyword">if</span>(bucket[p].first == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bucket[p].first = nums[i];</span><br><span class="line">                bucket[p].second = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                bucket[p].first = min(bucket[p].first, nums[i]);</span><br><span class="line">                bucket[p].second = max(bucket[p].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].first == <span class="number">-1</span>)   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (last != <span class="number">-1</span>) ans = max(ans, bucket[i].first-bucket[last].second);</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minn = <span class="built_in">min</span>(nums)</span><br><span class="line">        maxx = <span class="built_in">max</span>(nums)</span><br><span class="line">        d = <span class="built_in">max</span>(<span class="number">1</span>, (maxx-minn)//(n-<span class="number">1</span>))</span><br><span class="line">        m = (maxx-minn)//d+<span class="number">1</span></span><br><span class="line">        bucket = [[-<span class="number">1</span>, -<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            p = (nums[i]-minn)//d</span><br><span class="line">            <span class="keyword">if</span> bucket[p][<span class="number">0</span>] == -<span class="number">1</span>:</span><br><span class="line">                bucket[p][<span class="number">0</span>] = nums[i]</span><br><span class="line">                bucket[p][<span class="number">1</span>] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[p][<span class="number">0</span>] = <span class="built_in">min</span>(bucket[p][<span class="number">0</span>], nums[i])</span><br><span class="line">                bucket[p][<span class="number">1</span>] = <span class="built_in">max</span>(bucket[p][<span class="number">1</span>], nums[i])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        last = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> bucket[i][<span class="number">0</span>] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> last != -<span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i][<span class="number">0</span>]-bucket[last][<span class="number">1</span>])</span><br><span class="line">            last = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 165. Compare Version Numbers</title>
    <url>/2021/05/22/165.%20Compare%20Version%20Numbers/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two version numbers, <code>version1</code> and <code>version2</code>, compare them.</p>
<p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot <code>&#39;.&#39;</code>. Each revision consists of <strong>digits</strong> and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example <code>2.5.33</code> and <code>0.1</code> are valid version numbers.</p>
<p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their <strong>integer value ignoring any leading zeros</strong>. This means that revisions <code>1</code> and <code>001</code> are considered <strong>equal</strong>. If a version number does not specify a revision at an index, then <strong>treat the revision as <code>0</code></strong>. For example, version <code>1.0</code> is less than version <code>1.1</code> because their revision 0s are the same, but their revision 1s are <code>0</code> and <code>1</code> respectively, and <code>0 &lt; 1</code>.</p>
<p><em>Return the following:</em></p>
<ul>
<li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li>
<li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li>
<li>Otherwise, return <code>0</code>.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 <code>0</code> 开始，最左边的修订号下标为 <code>0</code>，下一个修订号下标为 <code>1</code> ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 <code>version1 &gt; version2</code> 返回 <code>1</code>，</li>
<li>如果 <code>version1 &lt; version2</code> 返回 <code>-1</code>，</li>
<li>除此之外返回 0。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,6,9,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The array contains less than 2 elements, therefore return 0.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左到右分别比较每个数字的大小，若该位置不存在，则初始为0。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = version1.length(), len2 = version2.length();</span><br><span class="line">        <span class="keyword">int</span> now1 = <span class="number">0</span>, now2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now1 &lt; len1 || now2 &lt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(now1 &lt; len1 &amp;&amp; version1[now1] != <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                sum1 = sum1*<span class="number">10</span>+version1[now1]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                now1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(now2 &lt; len2 &amp;&amp; version2[now2] != <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                sum2 = sum2*<span class="number">10</span>+version2[now2]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                now2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum1 &lt; sum2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum1 &gt; sum2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            now1++;</span><br><span class="line">            now2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        nums1 = version1.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        nums2 = version2.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(len1, len2)):</span><br><span class="line">            sum1 = <span class="built_in">int</span>(nums1[i]) <span class="keyword">if</span> i &lt; len1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum2 = <span class="built_in">int</span>(nums2[i]) <span class="keyword">if</span> i &lt; len2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sum1 &lt; sum2:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sum1 &gt; sum2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 166. Fraction to Recurring Decimal</title>
    <url>/2021/05/22/166.%20Fraction%20to%20Recurring%20Decimal/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>If multiple answers are possible, return <strong>any of them</strong>.</p>
<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>104</code> for all the given inputs.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>
<p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 $10^4$ 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 3</span><br><span class="line">Output: &quot;0.(6)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numerator &#x3D; 4, denominator &#x3D; 333</span><br><span class="line">Output: &quot;0.(012)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 5</span><br><span class="line">Output: &quot;0.2&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>模拟除法，记录每次分母的位置，即可处理循环节的问题。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!numerator)  <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = numerator, y = denominator;</span><br><span class="line">        <span class="keyword">if</span>((x&lt;<span class="number">0</span>)^(y&lt;<span class="number">0</span>)) ans.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        x = <span class="built_in">abs</span>(x);</span><br><span class="line">        y = <span class="built_in">abs</span>(y);</span><br><span class="line">        ans.append(to_string(x/y));</span><br><span class="line">        x %= y;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)  <span class="keyword">return</span> ans;</span><br><span class="line">        ans.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> index = ans.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">while</span>(x &amp;&amp; !record.count(x))</span><br><span class="line">        &#123;</span><br><span class="line">            record[x] = ++index;</span><br><span class="line">            x *= <span class="number">10</span>;</span><br><span class="line">            ans.append(to_string(x/y));</span><br><span class="line">            x %= y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(record.count(x))</span><br><span class="line">        &#123;</span><br><span class="line">            ans.insert(record[x], <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            ans.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span>(<span class="params">self, numerator: <span class="built_in">int</span>, denominator: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        x, y = numerator, denominator</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)^(y&lt;<span class="number">0</span>):</span><br><span class="line">            ans.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line">        y = <span class="built_in">abs</span>(y)</span><br><span class="line">        ans.append(<span class="built_in">str</span>(x//y))</span><br><span class="line">        x %= y</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br><span class="line">        ans.append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        index = <span class="built_in">len</span>(ans)-<span class="number">1</span></span><br><span class="line">        record = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            record[x] = index</span><br><span class="line">            x *= <span class="number">10</span></span><br><span class="line">            ans.append(<span class="built_in">str</span>(x//y))</span><br><span class="line">            x %= y</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> record:</span><br><span class="line">            ans.insert(record[x], <span class="string">&quot;(&quot;</span>)</span><br><span class="line">            ans.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 167. Two Sum II - Input array is sorted</title>
    <url>/2021/05/22/167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order\</em></strong>, find two numbers such that they add up to a specific <code>target</code> number.</p>
<p>Return <em>the indices of the two numbers (<strong>1-indexed</strong>) as an integer array</em> <code>answer</code> <em>of size</em> <code>2</code><em>, where</em> <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code>.</p>
<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个已按照 <strong>升序排列</strong>  的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值。<code>numbers</code> 的下标 从 <code>1</code> <strong>开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,3,4], target &#x3D; 6</span><br><span class="line">Output: [1,3]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [-1,0], target &#x3D; -1</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为数组有序，可直接使用双指针从两边开始扫。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[l]+numbers[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)   <span class="keyword">return</span> &#123;l+<span class="number">1</span>, r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)   l++;</span><br><span class="line">            <span class="keyword">else</span>    r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="built_in">sum</span> = numbers[l]+numbers[r]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                <span class="keyword">return</span> [l+<span class="number">1</span>, r+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 168. Excel Sheet Column Title</title>
    <url>/2021/05/22/168.%20Excel%20Sheet%20Column%20Title/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnNumber &#x3D; 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnNumber &#x3D; 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnNumber &#x3D; 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnNumber &#x3D; 2147483647</span><br><span class="line">Output: &quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>10进制到26进制的转化，1~26 对应 A~Z，注意不是 0~25。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span>(columnNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            s.append(<span class="number">1</span>, columnNumber%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> columnNumber:</span><br><span class="line">            columnNumber -= <span class="number">1</span></span><br><span class="line">            ans.append(<span class="built_in">chr</span>(columnNumber%<span class="number">26</span>+<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)))</span><br><span class="line">            columnNumber //= <span class="number">26</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169. Majority Element</title>
    <url>/2021/05/22/169.%20Majority%20Element/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>
<p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个大小为 <code>n</code> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于需要找的元素超过了半数，将数组扫一遍，统计当前累计的元素数量（相同+1，不同-1）。</p>
<p>最终剩余的元素必定为需要寻找的元素。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt)    now = x;</span><br><span class="line">            <span class="keyword">if</span>(now == x)    cnt++;</span><br><span class="line">            <span class="keyword">else</span>    cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                now = x</span><br><span class="line">            <span class="keyword">if</span> now == x:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Divide and Conquer</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 171. Excel Sheet Column Number</title>
    <url>/2021/05/22/171.%20Excel%20Sheet%20Column%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>columnTitle</code> that represents the column title as appear in an Excel sheet, return <em>its corresponding column number</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;FXSHRXW&quot;</span><br><span class="line">Output: 2147483647</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol>
<li>Excel Sheet Column Title 的逆过程。</li>
</ol>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> columnTitle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:columnTitle) ans = ans*<span class="number">26</span>-<span class="string">&#x27;A&#x27;</span>+c+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, columnTitle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> columnTitle:</span><br><span class="line">            ans = ans*<span class="number">26</span>+<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 172. Factorial Trailing Zeroes</title>
    <url>/2021/05/22/172.%20Factorial%20Trailing%20Zeroes/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in <code>n!</code></em>.</p>
<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数 <code>n</code>，返回 <code>n!</code> 结果尾数中零的数量。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! &#x3D; 6, no trailing zero.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>结尾 0 由因子 2 和因子 5 构成，由于 2 的数量必定大于 5，故仅需要计算因子 5 的数量。</p>
<p>只需要计算，1~n 中，有多少 5 的倍数、25 的倍数、125 的倍数…..</p>
<p>将数量相加，即为 5 的因子数量。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n //= <span class="number">5</span></span><br><span class="line">            ans += n</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 173. Binary Search Tree Iterator</title>
    <url>/2021/05/22/173.%20Binary%20Search%20Tree%20Iterator/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR">in-order traversal</a>)</strong> of a binary search tree (BST):</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>
<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>
<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>
</ul>
<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>
<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>实现一个二叉搜索树迭代器类 <code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>
<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>
</ul>
<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 3, 7, true, 9, true, 15, true, 20, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">BSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]);</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 3</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 7</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 9</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 15</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 20</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return False</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先将数的中序遍历转化为数组，然后进行相应操作。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(now-&gt;left);</span><br><span class="line">        v.push_back(now-&gt;val);</span><br><span class="line">        dfs(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BSTIterator(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt; v.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(now.left)</span><br><span class="line">        self.v.append(now.val)</span><br><span class="line">        self.dfs(now.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: TreeNode</span>):</span></span><br><span class="line">        self.v = []</span><br><span class="line">        self.p = <span class="number">0</span></span><br><span class="line">        self.dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        v = self.v[self.p]</span><br><span class="line">        self.p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.p &lt; <span class="built_in">len</span>(self.v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = BSTIterator(root)</span></span><br><span class="line"><span class="comment"># param_1 = obj.next()</span></span><br><span class="line"><span class="comment"># param_2 = obj.hasNext()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 174. Dungeon Game</title>
    <url>/2021/05/22/174.%20Dungeon%20Game/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight’s health (represented by positive integers).</p>
<p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p>
<p>Return <em>the knight’s minimum initial health so that he can rescue the princess</em>.</p>
<p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dungeon &#x3D; [[-2,-3,3],[-5,-10,1],[10,30,-5]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dungeon &#x3D; [[0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$dp[i][j]$  表示从 $i,j$ 位置到右下角所需要的最小健康度，从右下往左上 dp。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon.size(), m = dungeon[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">1e9</span>));</span><br><span class="line">        dp[n<span class="number">-1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        dp[n][m<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = max(<span class="number">1</span>, min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>])-dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span>(<span class="params">self, dungeon: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(dungeon)</span><br><span class="line">        m = <span class="built_in">len</span>(dungeon[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">1e9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[n-<span class="number">1</span>][m] = <span class="number">1</span></span><br><span class="line">        dp[n][m-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>])-dungeon[i][j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 179. Largest Number</title>
    <url>/2021/05/22/179.%20Largest%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number.</p>
<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10]</span><br><span class="line">Output: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将数字转化为字符串，排序。</p>
<p>时间复杂度 $O(nlenlogn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)    strs.emplace_back(to_string(x));</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)&#123;<span class="keyword">return</span> s1+s2 &gt; s2+s1;&#125;;</span><br><span class="line">        sort(strs.begin(), strs.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s:strs)  ans.append(s);</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)   <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; str:</span></span><br><span class="line">        strs = <span class="built_in">map</span>(<span class="built_in">str</span>, nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        strs = <span class="built_in">sorted</span>(strs, key=functools.cmp_to_key(cmp), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(strs)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 187. Repeated DNA Sequences</title>
    <url>/2021/05/22/187.%20Repeated%20DNA%20Sequences/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>
<ul>
<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>
</ul>
<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>
<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>所有 DNA 都由一系列缩写为 <code>&#39;A&#39;</code>，<code>&#39;C&#39;</code>，<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 的核苷酸组成，例如：<code>&quot;ACGAATTCCG&quot;</code>。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 <code>s</code> 中出现次数超过一次。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">Output: [&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">Output: [&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>哈希，每次只差首位两个字符，故可使用上一步的哈希值快速计算下一步的哈希值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">        mp[<span class="string">&#x27;G&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        mp[<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        mp[<span class="string">&#x27;T&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">9</span>; r &lt; s.size(); l++, r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += mp[s[i]]*now;</span><br><span class="line">                    now *= <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                now /= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    sum = (sum-mp[s[l<span class="number">-1</span>]])/<span class="number">4</span>+mp[s[r]]*now;</span><br><span class="line">            <span class="keyword">if</span>(st.count(sum))   ans.insert(s.substr(l, <span class="number">10</span>));</span><br><span class="line">            <span class="keyword">else</span>    st.insert(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(ans.begin(), ans.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        mp = &#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;G&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;T&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">        st = <span class="built_in">set</span>()</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">9</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        now = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">                    <span class="built_in">sum</span> += mp[s[i]]*now</span><br><span class="line">                    now *= <span class="number">4</span></span><br><span class="line">                now //= <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">sum</span> = (<span class="built_in">sum</span>-mp[s[l-<span class="number">1</span>]])//<span class="number">4</span>+mp[s[r]]*now</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">in</span> st:</span><br><span class="line">                ans.add(s[l:r+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.add(<span class="built_in">sum</span>)</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 188. Best Time to Buy and Sell Stock IV</title>
    <url>/2021/05/22/188.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>k</code>.</p>
<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>依旧是 123. Best Time to Buy and Sell Stock III 的思路。</p>
<p>$buy[i][j]$ 表示在前 $i$ 天，第 $j+1$ 次买股票时的最大收益；$sell[i][j]$ 表示在前 $i$ 天，第 $j+1$ 次卖股票时的最大收益。</p>
<p>可优化掉一维空间，次数由后往前dp。</p>
<p>时间复杂度 $O(nk)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buy</span><span class="params">(k, <span class="number">-1e9</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sell</span><span class="params">(k, <span class="number">-1e9</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                sell[i] = max(sell[i], buy[i]+x);</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)   buy[i] = max(buy[i], sell[i<span class="number">-1</span>]-x);</span><br><span class="line">                <span class="keyword">else</span>    buy[i] = max(buy[i], -x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sell.emplace_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> *max_element(sell.begin(), sell.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy = [-<span class="number">1e9</span>]*k</span><br><span class="line">        sell = [-<span class="number">1e9</span>]*k</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                sell[i] = <span class="built_in">max</span>(sell[i], buy[i]+x)</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    buy[i] = <span class="built_in">max</span>(buy[i], sell[i-<span class="number">1</span>]-x)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    buy[i] = <span class="built_in">max</span>(buy[i], -x)</span><br><span class="line">        sell.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sell)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 189. Rotate Array</title>
    <url>/2021/05/22/189.%20Rotate%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>进阶</strong>：</p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先将整体翻转，然后把 k 位置前后两段分别翻转。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.begin()+k);</span><br><span class="line">        reverse(nums.begin()+k, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        k %= <span class="built_in">len</span>(nums)</span><br><span class="line">        nums[:] = nums[::-<span class="number">1</span>]</span><br><span class="line">        nums[:k] = nums[:k][::-<span class="number">1</span>]</span><br><span class="line">        nums[k:] = nums[k:][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 190. Reverse Bits</title>
    <url>/2021/05/22/190.%20Reverse%20Bits/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>
</ul>
<p><strong>Follow up</strong>:</p>
<p>If this function is called many times, how would you optimize it?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p><strong>提示</strong>：</p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>
</ul>
<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>按位翻转。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans&lt;&lt;<span class="number">1</span>)|(n&amp;<span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            ans = (ans&lt;&lt;<span class="number">1</span>)|(n&amp;<span class="number">1</span>)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 191. Number of 1 Bits</title>
    <url>/2021/05/22/191.%20Number%20of%201%20Bits/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>).</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p><strong>提示</strong>：</p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>计算位的和。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += n&amp;<span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ans += n&amp;<span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 198. House Robber</title>
    <url>/2021/05/22/198.%20House%20Robber/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$dp[i]$ 表示到 $i$ 位置的最大可偷金额。</p>
<p>有 $dp[i] = max(dp[i-1], dp[i-2]+nums[i])$。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)  dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 199. Binary Tree Right Side View</title>
    <url>/2021/05/22/199.%20Binary%20Tree%20Right%20Side%20View/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1,3,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,3]</span><br><span class="line">Output: [1,3]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二叉树的层级遍历，记录每一层的最右元素。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = q.size();</span><br><span class="line">            <span class="keyword">while</span>(l--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *now = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(!l)  ans.emplace_back(now-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;left)   q.push(now-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(now-&gt;right)  q.push(now-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(root)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            l = q.qsize()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                now = q.get()</span><br><span class="line">                <span class="keyword">if</span> i == l-<span class="number">1</span>:</span><br><span class="line">                    ans.append(now.val)</span><br><span class="line">                <span class="keyword">if</span> now.left:</span><br><span class="line">                    q.put(now.left)</span><br><span class="line">                <span class="keyword">if</span> now.right:</span><br><span class="line">                    q.put(now.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200. Number of Islands</title>
    <url>/2021/05/22/200.%20Number%20of%20Islands/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历每个 1 的位置，只要是未遍历的连通团，dfs 把该连通团的位置全标记一遍。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i == n || j &lt; <span class="number">0</span> || j == m || vis[i][j] || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)    <span class="keyword">return</span>;</span><br><span class="line">        vis[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(grid, vis, i<span class="number">-1</span>, j);</span><br><span class="line">        dfs(grid, vis, i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, vis, i, j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid, vis, i, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(grid, vis, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i == self.n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == self.m <span class="keyword">or</span> self.vis[i][j] <span class="keyword">or</span> self.grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.vis[i][j] = <span class="number">1</span></span><br><span class="line">        self.dfs(i-<span class="number">1</span>, j)</span><br><span class="line">        self.dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        self.dfs(i, j-<span class="number">1</span>)</span><br><span class="line">        self.dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        self.grid = grid</span><br><span class="line">        self.n, self.m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        self.vis = [[<span class="number">0</span>]*self.m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n)]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                <span class="keyword">if</span> self.vis[i][j] <span class="keyword">or</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                self.dfs(i, j)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 201. Bitwise AND of Numbers Range</title>
    <url>/2021/05/24/201.%20Bitwise%20AND%20of%20Numbers%20Range/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、<code>right</code> 端点）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: left &#x3D; 5, right &#x3D; 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: left &#x3D; 0, right &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: left &#x3D; 1, right &#x3D; 2147483647</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>l~r 之间的所有数字，按位来看，只要有一个数字在该位的值为 0，那么最终结果在该位的位置为 0。</p>
<p>可每次清除 r 的最右侧 1（变为 0），直至 l &gt; r，那么此时得到的 r 即为 l~r 区间所有数字的按位与。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            right &amp;= (right<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            right &amp;= right-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 202. Happy Number</title>
    <url>/2021/05/24/202.%20Happy%20Number/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write an algorithm to determine if a number <code>n</code> is happy.</p>
<p>A <strong>happy number</strong> is a number defined by the following process:</p>
<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>
<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>
</ul>
<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>「快乐数」定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果 <strong>可以变为</strong>  1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不断模拟即可，过程中判断这个数是否已经出现过。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !s.count(n))</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(n);</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n)</span><br><span class="line">            &#123;</span><br><span class="line">                t += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            s.add(n)</span><br><span class="line">            t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                t += (n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">                n //= <span class="number">10</span></span><br><span class="line">            n = t</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 203. Remove Linked List Elements</title>
    <url>/2021/05/24/203.%20Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [], val &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [7,7,7,7], val &#x3D; 7</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>新建一个首节点，遍历一遍链表，若值需要删去，则将对应节点删去。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ans-&gt;next = head;</span><br><span class="line">        ListNode *now = ans;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;next-&gt;val == val)   now-&gt;next = now-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>    now = now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        ans = ListNode()</span><br><span class="line">        ans.<span class="built_in">next</span> = head</span><br><span class="line">        now = ans</span><br><span class="line">        <span class="keyword">while</span> now.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> now.<span class="built_in">next</span>.val == val:</span><br><span class="line">                now.<span class="built_in">next</span> = now.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = now.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 204. Count Primes</title>
    <url>/2021/05/24/204.%20Count%20Primes/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Count the number of prime numbers less than a non-negative number, <code>n</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>素数筛。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) primes.emplace_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i*primes[j] &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i*primes[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i%primes[j] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        vis = [<span class="number">0</span>]*n</span><br><span class="line">        primes = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> vis[i]:</span><br><span class="line">                primes.append(i)</span><br><span class="line">            <span class="keyword">for</span> prime <span class="keyword">in</span> primes:</span><br><span class="line">                <span class="keyword">if</span> i*prime &gt;= n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                vis[i*prime] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i%prime == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(primes)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 205. Isomorphic Strings</title>
    <url>/2021/05/24/205.%20Isomorphic%20Strings/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>
<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code>，判断它们是否是同构的。</p>
<p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>维护两个map，遍历两个串，查看是否冲突。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; mp1, mp2;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp1.count(s[i]))    mp1[s[i]] = t[i];</span><br><span class="line">            <span class="keyword">if</span>(!mp2.count(t[i]))    mp2[t[i]] = s[i];</span><br><span class="line">            <span class="keyword">if</span>(mp1[s[i]] != t[i] || mp2[t[i]] != s[i])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        mp1 = &#123;&#125;</span><br><span class="line">        mp2 = &#123;&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> mp1:</span><br><span class="line">                mp1[s[i]] = t[i]</span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">not</span> <span class="keyword">in</span> mp2:</span><br><span class="line">                mp2[t[i]] = s[i]</span><br><span class="line">            <span class="keyword">if</span> mp1[s[i]] != t[i] <span class="keyword">or</span> mp2[t[i]] != s[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206. Reverse Linked List</title>
    <url>/2021/05/24/206.%20Reverse%20Linked%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>链表反转。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *now = head, *pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        now = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            t = now.<span class="built_in">next</span></span><br><span class="line">            now.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = now</span><br><span class="line">            now = t</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 207. Course Schedule</title>
    <url>/2021/05/24/207.%20Course%20Schedule/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p>
<ul>
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>
<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code>则 <strong>必须</strong> 先学习课程  <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>拓扑排序。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[numCourses];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            v[x[<span class="number">1</span>]].emplace_back(x[<span class="number">0</span>]);</span><br><span class="line">            deg[x[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!deg[i]) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:v[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--deg[x] == <span class="number">0</span>)   q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[i])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        v = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        deg = [<span class="number">0</span>]*numCourses</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prerequisites:</span><br><span class="line">            v[x[<span class="number">1</span>]].append(x[<span class="number">0</span>])</span><br><span class="line">            deg[x[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">            <span class="keyword">if</span> deg[i] == <span class="number">0</span>:</span><br><span class="line">                q.put(i)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = q.get()</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> v[now]:</span><br><span class="line">                deg[x] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg[x] == <span class="number">0</span>:</span><br><span class="line">                    q.put(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(deg) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 208. Implement Trie (Prefix Tree)</title>
    <url>/2021/05/24/208.%20Implement%20Trie%20(Prefix%20Tree)/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A <a href="https://en.wikipedia.org/wiki/Trie"><strong>trie</strong></a> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>
<p>Implement the Trie class:</p>
<ul>
<li><code>Trie()</code> Initializes the trie object.</li>
<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>
<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>
<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p><code>Trie</code>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>字典树。</p>
<p>时间复杂度 $O(len)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; ch;</span><br><span class="line">    Node():word(<span class="number">0</span>), ch(<span class="number">26</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie():root(<span class="keyword">new</span> Node())&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        now-&gt;word = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word = <span class="literal">False</span></span>):</span></span><br><span class="line">        self.word = <span class="number">0</span></span><br><span class="line">        self.ch = [<span class="literal">None</span>]*<span class="number">26</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        now = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = Node()</span><br><span class="line">            now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        now.word = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        now = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="keyword">return</span> now.word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        now = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Tire</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209. Minimum Size Subarray Sum</title>
    <url>/2021/05/24/209.%20Minimum%20Size%20Subarray%20Sum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>双指针，每次移动右侧指针，将左侧指针往右缩进，使得区间尽可能小。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, minn = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span>(sum-nums[l] &gt;= target)    sum -= nums[l++];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target)   minn = min(minn, r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minn == <span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        minn = <span class="number">1e9</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">sum</span> += nums[r]</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span>-nums[l] &gt;= target:</span><br><span class="line">                <span class="built_in">sum</span> -= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, r-l+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> minn == <span class="number">1e9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> minn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 210. Course Schedule II</title>
    <url>/2021/05/24/210.%20Course%20Schedule%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p>
<ul>
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>
<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>现在你总共有 <code>n</code> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 207. Course Schedule 的基础上，记录任意一种答案。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[numCourses];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deg</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            v[x[<span class="number">1</span>]].emplace_back(x[<span class="number">0</span>]);</span><br><span class="line">            deg[x[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!deg[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:v[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--deg[x] == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(x);</span><br><span class="line">                    ans.emplace_back(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[i])  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        v = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        deg = [<span class="number">0</span>]*numCourses</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prerequisites:</span><br><span class="line">            v[x[<span class="number">1</span>]].append(x[<span class="number">0</span>])</span><br><span class="line">            deg[x[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">            <span class="keyword">if</span> deg[i] == <span class="number">0</span>:</span><br><span class="line">                q.put(i)</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            now = q.get()</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> v[now]:</span><br><span class="line">                deg[x] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg[x] == <span class="number">0</span>:</span><br><span class="line">                    q.put(x)</span><br><span class="line">                    ans.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(deg) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 211. Design Add and Search Words Data Structure</title>
    <url>/2021/05/24/211.%20Design%20Add%20and%20Search%20Words%20Data%20Structure/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>
<p>Implement the <code>WordDictionary</code> class:</p>
<ul>
<li><code>WordDictionary()</code> Initializes the object.</li>
<li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li>
<li><code>bool search(word)</code> Returns <code>true</code> if there is any string in the data structure that matches <code>word</code> or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 <code>WordDictionary</code> ：</p>
<ul>
<li><code>WordDictionary()</code> 初始化词典对象</li>
<li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li>
<li><code>bool search(word)</code> 如果数据结构中存在字符串与 <code>word</code> 匹配，则返回 <code>true</code> ；否则，返回  <code>false</code> 。<code>word</code> 中可能包含一些 <code>&#39;.&#39;</code> ，每个 <code>.</code> 都可以表示任何一个字母。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">WordDictionary wordDictionary &#x3D; new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); &#x2F;&#x2F; return False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); &#x2F;&#x2F; return True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); &#x2F;&#x2F; return True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>字典树，在 LeetCode 208. Implement Trie (Prefix Tree) 的基础上，增加了包含 . 字符的查询，遇到 . 时，遍历当前节点的所有子节点。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; ch;</span><br><span class="line">    Node():word(<span class="number">0</span>), ch(<span class="number">26</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary():root(<span class="keyword">new</span> Node())&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *now = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        now-&gt;word = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(Node *now, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p; i &lt; word.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(Node *ch:now-&gt;ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch &amp;&amp; searchWord(ch, word, i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchWord(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word = <span class="literal">False</span></span>):</span></span><br><span class="line">        self.word = <span class="number">0</span></span><br><span class="line">        self.ch = [<span class="literal">None</span>]*<span class="number">26</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        now = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = Node()</span><br><span class="line">            now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        now.word = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchWord</span>(<span class="params">self, now, word, p</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p, <span class="built_in">len</span>(word)):</span><br><span class="line">            c = word[i]</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">for</span> ch <span class="keyword">in</span> now.ch:</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">and</span> self.searchWord(ch, word, i+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="keyword">return</span> now.word</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.searchWord(self.root, word, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDictionary()</span></span><br><span class="line"><span class="comment"># obj.addWord(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
        <tag>Depth-first Search</tag>
        <tag>Design</tag>
        <tag>Tire</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 212. Word Search II</title>
    <url>/2021/05/24/212.%20Word%20Search%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>
<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words &#x3D; [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 79. Word Search 的基础上，增加了多个单词。</p>
<p>考虑到单词间的前缀关系，使用字典树减少冗余的搜索过程。</p>
<p>在每一步 dfs 搜索过程中，标记当前走过的位置，并需要回溯。</p>
<p>字典树，在 LeetCode 208. Implement Trie (Prefix Tree) 的基础上，增加了包含 . 字符的查询，遇到 . 时，遍历当前节点的所有子节点。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; ch;</span><br><span class="line">    Node():word(<span class="string">&quot;&quot;</span>), ch(<span class="number">26</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis, <span class="keyword">int</span> x, <span class="keyword">int</span> y, Node *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now-&gt;ch[board[x][y]-<span class="string">&#x27;a&#x27;</span>])   <span class="keyword">return</span>;</span><br><span class="line">        now = now-&gt;ch[board[x][y]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;word.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.emplace_back(now-&gt;word);</span><br><span class="line">            now-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x+dx[i], yy = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx &lt; <span class="number">0</span> || xx == n || yy &lt; <span class="number">0</span> || yy == m || vis[xx][yy])   <span class="keyword">continue</span>;</span><br><span class="line">            dfs(board, vis, xx, yy, now);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = board.size();</span><br><span class="line">        m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:words)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *now = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:word)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>]) now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">                now = now-&gt;ch[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;word = word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)    </span><br><span class="line">            &#123;</span><br><span class="line">                dfs(board, vis, i, j, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word = <span class="literal">False</span></span>):</span></span><br><span class="line">        self.word = <span class="literal">None</span></span><br><span class="line">        self.ch = [<span class="literal">None</span>]*<span class="number">26</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, x, y, now</span>):</span></span><br><span class="line">        now = now.ch[<span class="built_in">ord</span>(self.board[x][y])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">        <span class="keyword">if</span> now.word:</span><br><span class="line">            self.ans.append(now.word)</span><br><span class="line">            now.word = <span class="literal">None</span></span><br><span class="line">        self.vis[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            xx = x+self.dx[i]</span><br><span class="line">            yy = y+self.dy[i];</span><br><span class="line">            <span class="keyword">if</span> xx &lt; <span class="number">0</span> <span class="keyword">or</span> xx == self.n <span class="keyword">or</span> yy &lt; <span class="number">0</span> <span class="keyword">or</span> yy == self.m <span class="keyword">or</span> self.vis[xx][yy]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> now.ch[<span class="built_in">ord</span>(self.board[xx][yy])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                self.dfs(xx, yy, now)</span><br><span class="line">        self.vis[x][y] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]], words: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        self.board = board</span><br><span class="line">        self.n, self.m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        self.vis = [[<span class="number">0</span>]*self.m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n)]</span><br><span class="line">        self.dx = [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        self.dy = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        root = Node()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            now = root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                    now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = Node()</span><br><span class="line">                now = now.ch[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]</span><br><span class="line">            now.word = word</span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                <span class="keyword">if</span> root.ch[<span class="built_in">ord</span>(self.board[i][j])-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)]:</span><br><span class="line">                    self.dfs(i, j, root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
        <tag>Tire</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 213. House Robber II</title>
    <url>/2021/05/24/213.%20House%20Robber%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 198. House Robber 的基础上，需要考虑首尾不能同时选。</p>
<p>考虑到首尾至少一个点不能选，我们可以分为 0~n-2 和 1~n-1 计算，结果为两者的最大值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(r+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[l] = nums[l];</span><br><span class="line">        dp[l+<span class="number">1</span>] = max(nums[l], nums[l+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">2</span>; i &lt; r; i++)    dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)   <span class="keyword">return</span> *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> max(cal(nums, <span class="number">0</span>, n<span class="number">-1</span>), cal(nums, <span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        dp = [<span class="number">0</span>]*r</span><br><span class="line">        dp[l] = nums[l]</span><br><span class="line">        dp[l+<span class="number">1</span>] = <span class="built_in">max</span>(nums[l], nums[l+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">2</span>, r):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[r-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.cal(nums, <span class="number">0</span>, n-<span class="number">1</span>), self.cal(nums, <span class="number">1</span>, n))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 214. Shortest Palindrome</title>
    <url>/2021/05/24/214.%20Shortest%20Palindrome/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given a string <code>s</code>. You can convert <code>s</code> to a palindrome by adding characters in front of it.</p>
<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个字符串 <code>s</code>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aacecaaa&quot;</span><br><span class="line">Output: &quot;aaacecaaa&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcd&quot;</span><br><span class="line">Output: &quot;dcbabcd&quot;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用马拉车算法处理每个中心的最长回文串，然后找最长的回文串前缀。</p>
<p>把字符串中该前缀的剩余部分翻转拼接在前面就可以了。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> a = <span class="string">&quot;@&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            a.append(<span class="number">1</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            a.append(<span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">        a.append(<span class="string">&quot;#$&quot;</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(a.length())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mx &gt; i)  p[i] = min(p[<span class="number">2</span>*pos-i], mx-i);</span><br><span class="line">            <span class="keyword">else</span>    p[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(a[i+p[i]] == a[i-p[i]])   p[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i+p[i] &gt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                mx = i+p[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == i &amp;&amp; p[i] &gt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                mx = p[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ss = s.substr(mx<span class="number">-1</span>);</span><br><span class="line">        reverse(ss.begin(), ss.end());</span><br><span class="line">        <span class="keyword">return</span> ss+s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        a = [<span class="string">&#x27;@&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            a.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            a.append(c)</span><br><span class="line">        a.append(<span class="string">&#x27;#$&#x27;</span>)</span><br><span class="line">        a = <span class="string">&#x27;&#x27;</span>.join(a)</span><br><span class="line">        p = [<span class="number">0</span>]*<span class="built_in">len</span>(a)</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(a)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mx &gt; i:</span><br><span class="line">                p[i] = <span class="built_in">min</span>(p[<span class="number">2</span>*pos-i], mx-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> a[i+p[i]] == a[i-p[i]]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i+p[i] &gt; mx:</span><br><span class="line">                mx = i+p[i]</span><br><span class="line">                pos = i</span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">            <span class="keyword">if</span> p[i] == i <span class="keyword">and</span> p[i] &gt; mx:</span><br><span class="line">                mx = p[i]</span><br><span class="line">                pos = i</span><br><span class="line">        <span class="keyword">return</span> s[mx-<span class="number">1</span>:][::-<span class="number">1</span>]+s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 215. Kth Largest Element in an Array</title>
    <url>/2021/05/24/215.%20Kth%20Largest%20Element%20in%20an%20Array/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p>
<p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>在未排序的数组中找到第 <code>k</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>采用快排的思想，不断将数组划分成大小两部分。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = rand()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">        swap(nums[p], nums[l]);</span><br><span class="line">        p = l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[l])   swap(nums[p++], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l], nums[--p]);</span><br><span class="line">        <span class="keyword">if</span>(p == k<span class="number">-1</span>)    <span class="keyword">return</span> nums[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; k<span class="number">-1</span>)    <span class="keyword">return</span> find(nums, l+<span class="number">1</span>, r, k);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> find(nums, l, r<span class="number">-1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, nums, l, r, k</span>):</span></span><br><span class="line">        p = random.randint(l,r)</span><br><span class="line">        nums[p], nums[l] = nums[l], nums[p]</span><br><span class="line">        p = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">1</span>, r+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[l]:</span><br><span class="line">                nums[p], nums[i] = nums[i], nums[p]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">        p -= <span class="number">1</span></span><br><span class="line">        nums[l], nums[p] = nums[p], nums[l]</span><br><span class="line">        <span class="keyword">if</span> p == k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">elif</span> p &lt; k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find(nums, l+<span class="number">1</span>, r, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find(nums, l, r-<span class="number">1</span>, k)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, k)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 216. Combination Sum III</title>
    <url>/2021/05/24/216.%20Combination%20Sum%20III/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>
<ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
</ul>
<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合。组合中只允许含有 <code>1 - 9</code> 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 &#x3D; 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">Output: [[1,2,6],[1,3,5],[2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 6 &#x3D; 9</span><br><span class="line">1 + 3 + 5 &#x3D; 9</span><br><span class="line">2 + 3 + 4 &#x3D; 9</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 4, n &#x3D; 1</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations. [1,2,1] is not valid because 1 is used twice.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 9, n &#x3D; 45</span><br><span class="line">Output: [[1,2,3,4,5,6,7,8,9]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 &#x3D; 45</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs, 记录每一步剩余的个数和值，回溯过程中注意维护当前 nums 数组。</p>
<p>时间复杂度 $O(9\times2^9)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> now, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.emplace_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n &lt; now)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = now; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.emplace_back(i);</span><br><span class="line">            dfs(nums, i+<span class="number">1</span>, k<span class="number">-1</span>, n-i);</span><br><span class="line">            nums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        dfs(nums, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nums, now, k, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">            self.ans.append(nums[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> n &lt; now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(now, <span class="number">10</span>):</span><br><span class="line">            nums.append(i)</span><br><span class="line">            self.dfs(nums, i+<span class="number">1</span>, k-<span class="number">1</span>, n-i)</span><br><span class="line">            nums.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs([], <span class="number">1</span>, k, n)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 217. Contains Duplicate</title>
    <url>/2021/05/24/217.%20Contains%20Duplicate/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>扫一遍，哈希表记录所有值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(x))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            s.add(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 218. The Skyline Problem</title>
    <url>/2021/05/24/218.%20The%20Skyline%20Problem/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>A city’s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>
<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [lefti, righti, heighti]</code>:</p>
<ul>
<li><code>lefti</code> is the x coordinate of the left edge of the <code>ith</code> building.</li>
<li><code>righti</code> is the x coordinate of the right edge of the <code>ith</code> building.</li>
<li><code>heighti</code> is the height of the <code>ith</code> building.</li>
</ul>
<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>
<p>The <strong>skyline</strong> should be represented as a list of “key points” <strong>sorted by their x-coordinate</strong> in the form <code>[[x1,y1],[x2,y2],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.</p>
<p><strong>Note:</strong> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 <strong>天际线</strong> 。</p>
<p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p>
<ul>
<li><code>lefti</code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。</li>
<li><code>righti</code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。</li>
<li><code>heighti</code> 是第 <code>i</code> 座建筑物的高度。</li>
</ul>
<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式 <code>[[x1,y1],[x2,y2],...]</code> ，并按 <strong>x 坐标</strong> 进行 排序 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，<code>y</code> 坐标始终为 <code>0</code> ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p><strong>注意</strong>：输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">Explanation:</span><br><span class="line">Figure A shows the buildings of the input.</span><br><span class="line">Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: buildings &#x3D; [[0,2,3],[2,5,3]]</span><br><span class="line">Output: [[0,3],[5,0]]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将每个矩形的左右两条边按照从左到右，从低到高排序。</p>
<p>扫一遍所有边，维护一个 multiset，每次取 multiset 中的最大值，只要与上一个不同，便为关键点。</p>
<p>扫一遍，哈希表记录所有值。</p>
<p>时间复杂度 $O(nlogn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> b:buildings)</span><br><span class="line">        &#123;</span><br><span class="line">            h.push_back(&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">            h.push_back(&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(h.begin(), h.end());</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second &lt; <span class="number">0</span>)    m.insert(-x.second);</span><br><span class="line">            <span class="keyword">else</span>    m.erase(m.find(x.second));</span><br><span class="line">            <span class="keyword">int</span> now = *m.rbegin();</span><br><span class="line">            <span class="keyword">if</span>(now != pre)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(&#123;x.first, now&#125;);</span><br><span class="line">                pre = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSkyline</span>(<span class="params">self, buildings: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> buildings:</span><br><span class="line">            h.append((b[<span class="number">0</span>], -b[<span class="number">2</span>]))</span><br><span class="line">            h.append((b[<span class="number">1</span>], b[<span class="number">2</span>]))</span><br><span class="line">        h = <span class="built_in">sorted</span>(h)</span><br><span class="line">        mp = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        ans = []</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> h:</span><br><span class="line">            <span class="keyword">if</span> x[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                mp[-x[<span class="number">1</span>]] = mp.get(-x[<span class="number">1</span>], <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mp[x[<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(mp[x[<span class="number">1</span>]] == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">del</span> mp[x[<span class="number">1</span>]]</span><br><span class="line">            now = <span class="built_in">max</span>(mp.keys())</span><br><span class="line">            <span class="keyword">if</span> now != pre:</span><br><span class="line">                ans.append([x[<span class="number">0</span>], now])</span><br><span class="line">                pre = now</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>Binary Indexed Tree</tag>
        <tag>Segment Tree</tag>
        <tag>Line Sweep</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 219. Contains Duplicate II</title>
    <url>/2021/05/24/219.%20Contains%20Duplicate%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if there are two <strong>distinct indices</strong> <code>i</code> and <code>j</code> in the array such that <code>nums[i] == nums[j]</code> and <code>abs(i - j) &lt;= k</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数数组和一个整数 <code>k</code>，判断数组中是否存在两个不同的索引 <code>i</code> 和 <code>j</code>，使得 <code>nums [i] = nums [j]</code>，并且 <code>i</code> 和 <code>j</code> 的差的 <strong>绝对值</strong> 至多为 <code>k</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用一个区间扫一遍数组，维护一个散列表，区间头加元素，区间尾减元素，判断区间内是否有相同元素</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(nums[i]))    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            s.insert(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)  s.erase(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            s.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                s.remove(nums[i-k])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 220. Contains Duplicate III</title>
    <url>/2021/05/24/220.%20Contains%20Duplicate%20III/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code> and two integers <code>k</code> and <code>t</code>, return <code>true</code> if there are <strong>two distinct indices</strong> <code>i</code> and <code>j</code> in the array such that <code>abs(nums[i] - nums[j]) &lt;= t</code> and <code>abs(i - j) &lt;= k</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 219. Contains Duplicate II 的基础上，把数字看为 t+1 的桶，那么保证了找到两个符合的数之前，一个桶内不会有包含两个数。</p>
<p>对于每个数，与之对应的可能的数必定在同一个桶或相邻桶内，依次查看是否存在即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = t+<span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> id = nums[i]/l;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>) id = (nums[i]+<span class="number">1</span>)/l<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(id))    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(id<span class="number">-1</span>) &amp;&amp; nums[i]-mp[id<span class="number">-1</span>] &lt;= t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(id+<span class="number">1</span>) &amp;&amp; mp[id+<span class="number">1</span>]-nums[i] &lt;= t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            mp[id] = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                id = nums[i-k]/l;</span><br><span class="line">                <span class="keyword">if</span>(nums[i-k] &lt; <span class="number">0</span>) id = (nums[i-k]+<span class="number">1</span>)/l<span class="number">-1</span>;</span><br><span class="line">                mp.erase(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        l = t+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">id</span> = nums[i]//l</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span> <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span>-<span class="number">1</span> <span class="keyword">in</span> mp <span class="keyword">and</span> nums[i]-mp[<span class="built_in">id</span>-<span class="number">1</span>] &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span>+<span class="number">1</span> <span class="keyword">in</span> mp <span class="keyword">and</span> mp[<span class="built_in">id</span>+<span class="number">1</span>]-nums[i] &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            mp[<span class="built_in">id</span>] = nums[i]</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="built_in">id</span> = nums[i-k]//l</span><br><span class="line">                <span class="keyword">del</span>(mp[<span class="built_in">id</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 221. Maximal Square</title>
    <url>/2021/05/24/221.%20Maximal%20Square/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>‘s and <code>1</code>‘s, <em>find the largest square containing only</em> <code>1</code>‘s <em>and return its area</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[&quot;0&quot;]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dp，$dp[i][j]$ 表示在以 $i,j$ 位置为右下角的最大正方形的边长。</p>
<p>$dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1$。</p>
<p>时间复杂度 $O(nm)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = min(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)  maxx = max(maxx, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx*maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">        maxx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> maxx*maxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 222. Count Complete Tree Nodes</title>
    <url>/2021/05/24/222.%20Count%20Complete%20Tree%20Nodes/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>
<p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p>
<p>Design an algorithm that runs in less than <code>O(n)</code> time complexity.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 1~ $2^h$ 个节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二分点的个数，每次判断的过程根据点个数每一位的二进制判断向左还是向右。</p>
<p>时间复杂度 $O(log^2n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(TreeNode *now, <span class="keyword">int</span> cnt, <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(now &amp;&amp; bits)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;bits)    now = now-&gt;right;</span><br><span class="line">            <span class="keyword">else</span>    now = now-&gt;left;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *now = root;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            now = now-&gt;left;</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>&lt;&lt;d, r = (<span class="number">1</span>&lt;&lt;(d+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok(root, mid, <span class="number">1</span>&lt;&lt;(d<span class="number">-1</span>))) l = mid;</span><br><span class="line">            <span class="keyword">else</span>    r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self, now, cnt, bits</span>):</span></span><br><span class="line">        <span class="keyword">while</span> now <span class="keyword">and</span> bits:</span><br><span class="line">            <span class="keyword">if</span> cnt&amp;bits:</span><br><span class="line">                now = now.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = now.left</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        now = root</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> now.left:</span><br><span class="line">            now = now.left</span><br><span class="line">            d += <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">1</span>&lt;&lt;d, (<span class="number">1</span>&lt;&lt;(d+<span class="number">1</span>))-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.ok(root, mid, <span class="number">1</span>&lt;&lt;(d-<span class="number">1</span>)):</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 223. Rectangle Area</title>
    <url>/2021/05/24/223.%20Rectangle%20Area/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the coordinates of two <strong>rectilinear</strong> rectangles in a 2D plane, return <em>the total area covered by the two rectangles</em>.</p>
<p>The first rectangle is defined by its <strong>bottom-left</strong> corner <code>(ax1, ay1)</code> and its <strong>top-right</strong> corner <code>(ax2, ay2)</code>.</p>
<p>The second rectangle is defined by its <strong>bottom-left</strong> corner <code>(bx1, by1)</code> and its <strong>top-right</strong> corner <code>(bx2, by2)</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong> 矩形，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>
<ul>
<li>第一个矩形由其左下顶点 <code>(ax1, ay1)</code> 和右上顶点 <code>(ax2, ay2)</code> 定义。</li>
<li>第二个矩形由其左下顶点 <code>(bx1, by1)</code> 和右上顶点 <code>(bx2, by2)</code> 定义。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png" alt="Rectangle Area"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ax1 &#x3D; -3, ay1 &#x3D; 0, ax2 &#x3D; 3, ay2 &#x3D; 4, bx1 &#x3D; 0, by1 &#x3D; -1, bx2 &#x3D; 9, by2 &#x3D; 2</span><br><span class="line">Output: 45</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ax1 &#x3D; -2, ay1 &#x3D; -2, ax2 &#x3D; 2, ay2 &#x3D; 2, bx1 &#x3D; -2, by1 &#x3D; -2, bx2 &#x3D; 2, by2 &#x3D; 2</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>分别计算两个矩阵的面积和重合部分的面积。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> ax1, <span class="keyword">int</span> ay1, <span class="keyword">int</span> ax2, <span class="keyword">int</span> ay2, <span class="keyword">int</span> bx1, <span class="keyword">int</span> by1, <span class="keyword">int</span> bx2, <span class="keyword">int</span> by2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = (ax2-ax1)*(ay2-ay1);</span><br><span class="line">        <span class="keyword">int</span> s2 = (bx2-bx1)*(by2-by1);</span><br><span class="line">        <span class="keyword">if</span>(ax1 &gt; bx2 || ax2 &lt; bx1 || ay1 &gt; by2 || ay2 &lt; by1)    <span class="keyword">return</span> s1+s2;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(ax1, bx1);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(ax2, bx2);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(ay1, by1);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(ay2, by2);</span><br><span class="line">        <span class="keyword">int</span> s3 = (x2-x1)*(y2-y1);</span><br><span class="line">        <span class="keyword">return</span> s1+s2-s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeArea</span>(<span class="params">self, ax1: <span class="built_in">int</span>, ay1: <span class="built_in">int</span>, ax2: <span class="built_in">int</span>, ay2: <span class="built_in">int</span>, bx1: <span class="built_in">int</span>, by1: <span class="built_in">int</span>, bx2: <span class="built_in">int</span>, by2: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        s1 = (ax2-ax1)*(ay2-ay1);</span><br><span class="line">        s2 = (bx2-bx1)*(by2-by1);</span><br><span class="line">        <span class="keyword">if</span> ax1 &gt; bx2 <span class="keyword">or</span> ax2 &lt; bx1 <span class="keyword">or</span> ay1 &gt; by2 <span class="keyword">or</span> ay2 &lt; by1:</span><br><span class="line">            <span class="keyword">return</span> s1+s2;</span><br><span class="line">        x1 = <span class="built_in">max</span>(ax1, bx1);</span><br><span class="line">        x2 = <span class="built_in">min</span>(ax2, bx2);</span><br><span class="line">        y1 = <span class="built_in">max</span>(ay1, by1);</span><br><span class="line">        y2 = <span class="built_in">min</span>(ay2, by2);</span><br><span class="line">        s3 = (x2-x1)*(y2-y1);</span><br><span class="line">        <span class="keyword">return</span> s1+s2-s3;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 224. Basic Calculator</title>
    <url>/2021/05/24/224.%20Basic%20Calculator/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code> representing an expression, implement a basic calculator to evaluate it.</p>
<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于只有加减法和括号，只需要推断每个数字前的符号，然后相加即可。</p>
<p>用栈记录括号之前的符号，并维护当前环境（如在括号内）的正负符号。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(&#123;<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span>) sign = st.top();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;-&#x27;</span>)    sign = -st.top();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)    st.push(sign);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)    st.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; <span class="built_in">isdigit</span>(s[i])) now = now*<span class="number">10</span>+(s[i++]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i--;</span><br><span class="line">                ans += sign*now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        l = <span class="built_in">len</span>(s)</span><br><span class="line">        st = [<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; l:</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">                sign = st[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span>(s[i] == <span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">                sign = -st[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span>(s[i] == <span class="string">&#x27;(&#x27;</span>):</span><br><span class="line">                st.append(sign)</span><br><span class="line">            <span class="keyword">elif</span>(s[i] == <span class="string">&#x27;)&#x27;</span>):</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">elif</span>(s[i].isdigit()):</span><br><span class="line">                now = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; l <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    now = now*<span class="number">10</span>+<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                ans += sign*now</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 225. Implement Stack using Queues</title>
    <url>/2021/05/24/225.%20Implement%20Stack%20using%20Queues/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue), as long as you use only a queue’s standard operations.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请你仅使用两个队列实现一个后入先出（<code>LIFO</code>）的栈，并支持普通队列的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 <code>x</code> 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 <code>list</code> （列表）或者 <code>deque</code>（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack &#x3D; new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); &#x2F;&#x2F; return 2</span><br><span class="line">myStack.pop(); &#x2F;&#x2F; return 2</span><br><span class="line">myStack.empty(); &#x2F;&#x2F; return False</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用两个队列模拟栈，元素入栈的时候，为保证先入先出，需要将元素先加进空队列，然后把原有队列元素重新加进该队列。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())  q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty())  q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        q2.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.q1 = queue.Queue()</span><br><span class="line">        self.q2 = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.q2.put(x)</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</span><br><span class="line">            self.q2.put(self.q1.get())</span><br><span class="line">        self.q1, self.q2 = self.q2, self.q1</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.q1.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        x = self.q1.get()</span><br><span class="line">        self.q2.put(x)</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">not</span> self.q1.empty()):</span><br><span class="line">            self.q2.put(self.q1.get())</span><br><span class="line">        self.q1, self.q2 = self.q2, self.q1</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.q1.empty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <url>/2021/05/24/226.%20Invert%20Binary%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>翻转一棵二叉树。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: [2,3,1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归将每个节点的左右子树交换。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 227. Basic Calculator II</title>
    <url>/2021/05/24/227.%20Basic%20Calculator%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>. </p>
<p>The integer division should truncate toward zero.</p>
<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于只有加减乘除四种符号，故先处理乘和除，将所有结果连带符号保存，最终一起加起来。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="title">op</span><span class="params">(&#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))   now = now*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(op.count(s[i]) || i == s.length()<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">&#x27;+&#x27;</span>) st.push_back(now);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">&#x27;-&#x27;</span>)    st.push_back(-now);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">&#x27;*&#x27;</span>)    st.back() *= now;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">&#x27;/&#x27;</span>)    st.back() /= now;</span><br><span class="line">                sign = s[i];</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(st.begin(), st.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        op = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;</span><br><span class="line">        st = []</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                now = now*<span class="number">10</span>+<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> op <span class="keyword">or</span> i == <span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">                print(now)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    st.append(now)</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    st.append(-now)</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    st[-<span class="number">1</span>] *= now</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st[-<span class="number">1</span>] &gt; <span class="number">0</span>):</span><br><span class="line">                        st[-<span class="number">1</span>] //= now</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        st[-<span class="number">1</span>] = (st[-<span class="number">1</span>]+now-<span class="number">1</span>)//now</span><br><span class="line">                sign = s[i]</span><br><span class="line">                now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(st)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 228. Summary Ranges</title>
    <url>/2021/05/24/228.%20Summary%20Ranges/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>
<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>
<p>Each range <code>[a,b]</code> in the list should be output as:</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>
<li><code>&quot;a&quot;</code> if <code>a == b</code></li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p>
<p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 <code>x</code> 。</p>
<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li>
<li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1]</span><br><span class="line">Output: [&quot;-1&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [&quot;0&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>扫一遍，找所有数字连续的子数组。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; l = r+<span class="number">1</span>, r = l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(r+<span class="number">1</span> &lt; n &amp;&amp; nums[r]+<span class="number">1</span> == nums[r+<span class="number">1</span>])    r++;</span><br><span class="line">            <span class="built_in">string</span> t = to_string(nums[l]);</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                t.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                t.append(to_string(nums[r]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">while</span> r+<span class="number">1</span> &lt; n <span class="keyword">and</span> nums[r]+<span class="number">1</span> == nums[r+<span class="number">1</span>]:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            t = <span class="built_in">str</span>(nums[l])</span><br><span class="line">            <span class="keyword">if</span> l &lt; r:</span><br><span class="line">                t += <span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(nums[r])</span><br><span class="line">            ans.append(t)</span><br><span class="line">            l = r+<span class="number">1</span></span><br><span class="line">            r = l</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 229. Majority Element II</title>
    <url>/2021/05/24/229.%20Majority%20Element%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>⌊ n/3 ⌋</code> times.</p>
<p><strong>Follow-up:</strong> Could you solve the problem in linear time and in O(1) space?</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个大小为 <code>n</code> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><strong>进阶</strong>：尝试设计时间复杂度为 <code>O(n)</code>、空间复杂度为 <code>O(1)</code>的算法解决此问题。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在 LeetCode 169. Majority Element 的基础上扩展，最多可能有两个数字符合。</p>
<p>注意需要判断是否存在。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = nums[<span class="number">0</span>], cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = nums[<span class="number">0</span>], cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == num1)   cnt1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == num2)  cnt2++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num1 = x;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num2 = x;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt1--;</span><br><span class="line">                cnt2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt1 = <span class="number">0</span>;</span><br><span class="line">        cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == num1)   cnt1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == num2)  cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 &gt; nums.size()/<span class="number">3</span>)    ans.emplace_back(num1);</span><br><span class="line">        <span class="keyword">if</span>(cnt2 &gt; nums.size()/<span class="number">3</span>)    ans.emplace_back(num2);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        num1, cnt1 = nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        num2, cnt2 = nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == num1:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x == num2:</span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cnt1 == <span class="number">0</span>:</span><br><span class="line">                num1 = x</span><br><span class="line">                cnt1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cnt2 == <span class="number">0</span>:</span><br><span class="line">                num2 = x</span><br><span class="line">                cnt2 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 -= <span class="number">1</span></span><br><span class="line">                cnt2 -= <span class="number">1</span></span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == num1:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x == num2:</span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> cnt1 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            ans.append(num1)</span><br><span class="line">        <span class="keyword">if</span> cnt2 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            ans.append(num2)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 230. Kth Smallest Element in a BST</title>
    <url>/2021/05/24/230.%20Kth%20Smallest%20Element%20in%20a%20BST/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> (<strong>1-indexed</strong>) <em>smallest element in the tree</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在中序遍历的过程中计数，找到第 k 个元素。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *now, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span>;</span><br><span class="line">        dfs(now-&gt;left, k);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)  </span><br><span class="line">        &#123;</span><br><span class="line">            ans = now-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(now-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(now.left, k)</span><br><span class="line">        self.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(self.cnt == k):</span><br><span class="line">            self.ans = now.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(now.right, k)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.dfs(root, k)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 231. Power of Two</title>
    <url>/2021/05/24/231.%20Power%20of%20Two/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that $n == 2^x$.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>若为2的倍数，则其二进制只含一个1，使用 lowbit，判断其是否等于自身。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;-n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> (n&amp;-n) == n</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 232. Implement Queue using Stacks</title>
    <url>/2021/05/24/232.%20Implement%20Queue%20using%20Stacks/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 <code>x</code> 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 <code>list</code> 或者 <code>deque</code>（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>进阶</strong>：</p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyQueue myQueue &#x3D; new MyQueue();</span><br><span class="line">myQueue.push(1); &#x2F;&#x2F; queue is: [1]</span><br><span class="line">myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); &#x2F;&#x2F; return 1</span><br><span class="line">myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]</span><br><span class="line">myQueue.empty(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>用两个栈模拟队列，当出队时，需要将栈的元素倒进另一个栈中，以实现队列的先进先出。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())  s1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!s2.empty())  s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.empty() &amp;&amp; s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s1 = []</span><br><span class="line">        self.s2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.s2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.s1):</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.s2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.s1):</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.s1) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.s2) == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 234. Palindrome Linked List</title>
    <url>/2021/05/24/233.%20Number%20of%20Digit%20One/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请判断一个链表是否为回文链表。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>十进制按位计算每位1的数量，如通过 x%100 计算十位上1的数量。</p>
<p>注意需要考虑不足 $10^{(i+1)}$ 时，$i$ 位上1的数量，需要加上。 </p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d = i*<span class="number">10</span>;</span><br><span class="line">            cnt += n/d*i+min(max(n%d-i+<span class="number">1</span>, <span class="number">0LL</span>), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">            d = i*<span class="number">10</span></span><br><span class="line">            cnt += n//d*i+<span class="built_in">min</span>(<span class="built_in">max</span>(n%d-i+<span class="number">1</span>, <span class="number">0</span>), i)</span><br><span class="line">            i *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 233. Number of Digit One</title>
    <url>/2021/05/24/234.%20Palindrome%20Linked%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>n</code>, count <em>the total number of digit</em> <code>1</code> <em>appearing in all non-negative integers less than or equal to</em> <code>n</code>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先用快慢指针找到链表中点，然后将后一段翻转，判断两段链表是否相等。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next &amp;&amp; q-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l1 = head, *l2 = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="number">0</span>;</span><br><span class="line">        ListNode *now = l2, *pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = t;</span><br><span class="line">        &#125;</span><br><span class="line">        l2 = pre;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val != l2-&gt;val)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        now = l2</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            t = now.<span class="built_in">next</span></span><br><span class="line">            now.<span class="built_in">next</span> = pre</span><br><span class="line">            pre, now = now, t</span><br><span class="line">        l2 = pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val != l2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/2021/05/24/235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1], p &#x3D; 2, q &#x3D; 1</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从根节点开始，比较两个节点与当前节点的大小，若当前节点处于两者之间，则当前节点为最小公共祖先，否者根据大小向左或右移动。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; q-&gt;val) swap(p, q);</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;val &lt; p-&gt;val || root-&gt;val &gt; q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val)  root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span>    root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> p.val &gt; q.val:</span><br><span class="line">            p, q = q, p</span><br><span class="line">        <span class="keyword">while</span> root.val &lt; p.val <span class="keyword">or</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 236. Lowest Common Ancestor of a Binary Tree</title>
    <url>/2021/05/24/236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs搜每个节点的子树中包含几个目标节点，包含两个且最底层的节点即为最小公共祖先。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* now, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!now)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(now-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">int</span> r = dfs(now-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">int</span> nowp = now == p, nowq = now == q;</span><br><span class="line">        <span class="keyword">if</span>(l+r+nowp+nowq == <span class="number">2</span>)  ans = now;</span><br><span class="line">        <span class="keyword">return</span> l || r || nowp || nowq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.dfs(now.left, p, q)</span><br><span class="line">        r = self.dfs(now.right, p, q)</span><br><span class="line">        nowp = now == p</span><br><span class="line">        nowq = now == q</span><br><span class="line">        <span class="keyword">if</span> l+r+nowp+nowq == <span class="number">2</span>:</span><br><span class="line">            self.ans = now</span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">or</span> r <span class="keyword">or</span> nowp <span class="keyword">or</span> nowq</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        self.dfs(root, p, q)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 237. Delete Node in a Linked List</title>
    <url>/2021/05/24/237.%20Delete%20Node%20in%20a%20Linked%20List/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>
<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4], node &#x3D; 3</span><br><span class="line">Output: [1,2,4]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0,1], node &#x3D; 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-3,5,-99], node &#x3D; -3</span><br><span class="line">Output: [5,-99]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于不知道当前节点的上一节点，无法修改节点的链接，故直接将当前节点的值修改为下一节点。</p>
<p>时间复杂度 $O(1)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 238. Product of Array Except Self</title>
    <url>/2021/05/24/238.%20Product%20of%20Array%20Except%20Self/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>
<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>
<p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code>，其中 <code>n &gt; 1</code>，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,1,0,-3,3]</span><br><span class="line">Output: [0,0,9,0,0]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>构造两个数组，分别为左到右的累积和右到左的累积。</p>
<p>对于每个位置的结果，时候两边的累积相乘即可。</p>
<p>此外，可在遍历过程中节约一个数组的空间。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  ans[i] = ans[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = ans[i]*r;</span><br><span class="line">            r *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = [<span class="number">0</span>]*n</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            ans[i] = ans[i]*r</span><br><span class="line">            r *= nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 239. Sliding Window Maximum</title>
    <url>/2021/05/24/239.%20Sliding%20Window%20Maximum/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">Output: [1,-1]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">Output: [11]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>维护一个单调递减的双向队列，只要保证当前队列元素都是区间内的，那么队首即为当前区间的最大值。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])  q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(q.front() &lt;= i-k) q.pop_front();</span><br><span class="line">                ans.push_back(nums[q.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(q) <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i-k:</span><br><span class="line">                    q.popleft()</span><br><span class="line">                ans.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Sliding Window</tag>
        <tag>Heap</tag>
        <tag>Dequeue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 240. Search a 2D Matrix II</title>
    <url>/2021/05/24/240.%20Search%20a%202D%20Matrix%20II/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Write an efficient algorithm that searches for a <code>target</code> value in an <code>m x n</code> integer <code>matrix</code>. The <code>matrix</code> has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从左下开始搜，当前值比目标值大则向上，小则向右。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> x = n<span class="number">-1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &lt; target)   y++;</span><br><span class="line">            <span class="keyword">else</span>    x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        x = n-<span class="number">1</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; m:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &lt; target:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 241. Different Ways to Add Parentheses</title>
    <url>/2021/05/24/241.%20Different%20Ways%20to%20Add%20Parentheses/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 <code>+</code>, <code>-</code> 以及 <code>*</code> 。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: expression &#x3D; &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) &#x3D; 0 </span><br><span class="line">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: expression &#x3D; &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34,-14,-10,-10,10]</span><br><span class="line">Explanation:</span><br><span class="line">(2*(3-(4*5))) &#x3D; -34 </span><br><span class="line">((2*3)-(4*5)) &#x3D; -14 </span><br><span class="line">((2*(3-4))*5) &#x3D; -10 </span><br><span class="line">(2*((3-4)*5)) &#x3D; -10 </span><br><span class="line">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>递归分治，对于每一个子串，遍历每个符号，递归计算左右两部分可能的结果。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> expression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = diffWaysToCompute(expression.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = diffWaysToCompute(expression.substr(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l:left) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r:right) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)    ans.push_back(l+r);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)   ans.push_back(l-r);</span><br><span class="line">                        <span class="keyword">else</span>    ans.push_back(l*r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == <span class="number">0</span>) ans.push_back(stoi(expression));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, expression: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(expression)):</span><br><span class="line">            c = expression[i]</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                left = self.diffWaysToCompute(expression[:i])</span><br><span class="line">                right = self.diffWaysToCompute(expression[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            ans.append(l+r)</span><br><span class="line">                        <span class="keyword">elif</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            ans.append(l-r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            ans.append(l*r)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span>:</span><br><span class="line">            ans.append(<span class="built_in">int</span>(expression))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 242. Valid Anagram</title>
    <url>/2021/05/24/242.%20Valid%20Anagram/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>哈希表记录第一个串每个字母的次数，然后检查第二个串是否符合。</p>
<p>时间复杂度 $O(n)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)   mp[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--mp[c] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            mp[c] = mp.get(c, <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mp[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mp[c] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 257. Binary Tree Paths</title>
    <url>/2021/05/24/257.%20Binary%20Tree%20Paths/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [&quot;1&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>dfs搜索，记录当前路径并回溯。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *now, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.push_back(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!now-&gt;left &amp;&amp; !now-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = to_string(path[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; path.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                s.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                s.append(to_string(path[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left)   dfs(now-&gt;left, path);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right)  dfs(now-&gt;right, path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(root, path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, now, path</span>):</span></span><br><span class="line">        path.append(<span class="built_in">str</span>(now.val))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> now.left <span class="keyword">and</span> <span class="keyword">not</span> now.right:</span><br><span class="line">            self.ans.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(path))</span><br><span class="line">        <span class="keyword">if</span> now.left:</span><br><span class="line">            self.dfs(now.left, path)</span><br><span class="line">        <span class="keyword">if</span> now.right:</span><br><span class="line">            self.dfs(now.right, path)</span><br><span class="line">        path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[str]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 258. Add Digits</title>
    <url>/2021/05/24/258.%20Add%20Digits/</url>
    <content><![CDATA[<h1 id="题目描述-英文"><a href="#题目描述-英文" class="headerlink" title="题目描述(英文)"></a>题目描述(英文)</h1><p>Given an integer <code>num</code>, repeatedly add all its digits until the result has only one digit, and return it.</p>
<a id="more"></a>
<h1 id="题目描述-中文"><a href="#题目描述-中文" class="headerlink" title="题目描述(中文)"></a>题目描述(中文)</h1><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; 38</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The process is</span><br><span class="line">38 --&gt; 3 + 8 --&gt; 11</span><br><span class="line">11 --&gt; 1 + 1 --&gt; 2 </span><br><span class="line">Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不断模拟即可。</p>
<p>时间复杂度 $O(logn)$。</p>
<h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num)</span><br><span class="line">            &#123;</span><br><span class="line">                x += num%<span class="number">10</span>;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">while</span> num &gt;= <span class="number">10</span>:</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> num:</span><br><span class="line">                x += num%<span class="number">10</span></span><br><span class="line">                num //= <span class="number">10</span></span><br><span class="line">            num = x</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
</search>
